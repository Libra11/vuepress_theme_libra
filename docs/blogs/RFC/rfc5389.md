---
title: rfc5389
category: rfc
desc: rfc5389
tag:
  - rfc
picture: https://libra321.oss-cn-huhehaote.aliyuncs.com/img/boxmodel.png
date: "2023-04-23"
---

# 预备知识

## `NAT`

`NAT`（`Network Address Translation`）是一种网络协议，它通常用于在私有网络和公共网络之间进行通信。在私有网络中，每个设备都被分配了一个内部 `IP` 地址，而在公共网络中，每个设备都被分配了一个唯一的公共 `IP` 地址。当一个设备在私有网络中尝试与公共网络中的设备通信时，`NAT` 会将该设备的内部 `IP` 地址转换为公共 `IP` 地址，以便使其能够在公共网络中进行通信。这种技术被广泛应用于家庭和办公网络中，以及在互联网服务提供商（`ISP`）网络中。

`NAT` 转换的内部 `IP` 原理是在 `NAT` 设备内部维护一个转换表，记录内部 `IP` 和端口号和外部 `IP` 和端口号之间的对应关系。当内部主机向外部发送数据时，`NAT` 设备会将源 `IP` 和端口号替换成映射表中对应的外部 `IP` 和端口号，从而达到将内部主机和外部主机通信的目的。当外部主机向内部主机发送数据时，`NAT` 设备会根据目标 `IP` 和端口号在映射表中查找对应的内部 `IP` 和端口号，然后将数据转发给内部主机。

`NAT` 设备会维护一个 `NAT` 会话表，用于记录内部主机和外部主机之间的会话状态。当内部主机向外部主机发起连接时，`NAT` 设备会在 `NAT` 会话表中创建一个新的会话，并分配一个唯一的标识符。当外部主机向内部主机发送数据时，`NAT` 设备会根据目标 `IP` 和端口号匹配会话表中的会话，并将数据转发给对应的内部主机。在会话结束后，`NAT` 设备会清除会话表中的记录。

大多数路由器具有 `NAT` 功能

# 简介

`STUN` 是一种用于解决 `NAT`（网络地址转换）的协议，它可以让网络终端设备（如计算机、手机等）知道它在 `NAT` 后面的公网 `IP` 地址和端口号。这个协议还可以帮助网络终端设备保持与公网的连接，防止被 `NAT` 的“坏心情”断开。`STUN` `协议是一个可扩展的协议，支持多种传输协议，有两种身份验证方式。STUN` 还可以用于实现其他网络协议，比如 `ICE` 协议和 `SIP Outbound` 协议。`STUN` 协议通过不同的“用法”来实现不同的功能，每种“用法”都会定义 `STUN` 消息的内容和处理方式，可以通过扩展 `STUN` 协议来实现新的“用法”。

> `NAT` 的“坏心情”指的是网络地址转换（`NAT`）技术给网络通信带来的一些问题和限制，它可能导致一些本来可以直接通信的设备在网络通信时无法直接建立连接，从而影响通信的质量和效率。这是因为 `NAT` 技术通常会使得私有网络内的设备共享同一个公网 `IP` 地址，因此在进行网络通信时，需要对 `IP` 地址和端口进行转换，这可能会导致连接中断、延迟增加、数据包丢失等问题。此外，`NAT` 技术通常会对一些传输协议（如 `UDP`）造成一些限制，也会给一些应用带来不便。为了解决 `NAT` 带来的问题，出现了一些相关的技术，如 `STUN`、`TURN`、`ICE` 等。

# 从 `rfc3489` 的演变

`RFC 3489` 是一份关于 `NAT` 穿透的规范，其中定义了`classic STUN`，即一种解决 `NAT` 穿透问题的方法。但是，实践证明，这种方法并不完全可靠。因为它不能保证获得的公网 `IP` 地址和端口一定可用于通信，而且它的 `NAT` 类型分类算法也有缺陷。此外，它还存在安全漏洞，攻击者可以提供错误的映射地址。因此，`RFC 5389` 取代了 `RFC 3489`，重新定义了 `STUN`，将其作为完整 `NAT` 穿透方案的一部分工具来使用。例如，`ICE` 是一个基于 `Offer/Answer` 方法论的完整的 `NAT` 穿透方案，而 `SIP Outbound` 是一个用于 `SIP` 信令穿透的完整方案，这些方案都使用 `STUN`。尽管有可能单独使用 `STUN` 来实现 `NAT` 穿透，但这种做法并不推荐，因为它有安全漏洞，并且不够可靠。`RFC 5389` 对 `classic STUN` 协议进行了一些修改和扩展，如增加了 `TCP` 协议的支持、改进了映射地址编码格式等。此外，`RFC 5389` 将 `STUN` 的含义从`Simple Traversal of UDP through NAT`更名为`Session Traversal Utilities for NAT`。

# 操作概述

`STUN` 协议是一种用于处理 `NAT` 的工具，它提供了一种方式让终端设备确定其私有 `IP` 地址和端口号在 `NAT` 映射下所对应的公共 `IP` 地址和端口号，**并且保持 `NAT` 绑定状态的存活性。** 它通过客户端和服务器之间的请求/响应或指示交互来实现这些功能，客户端和服务器都需要实现 `STUN` 协议。当客户端发送绑定请求给服务器时，这个请求可能要通过多个 `NAT` 转发，每次转发都会改变源地址。在此过程中，服务器将原始的源地址存储在一个特殊的 `XOR-MAPPED-ADDRESS` 属性中，并将这个属性值通过响应返回给客户端。这个属性值包含了客户端的公共 `IP` 地址和端口号，客户端可以从中获得其相对于服务器的反射传输地址。除了绑定方法，`STUN` 协议还提供了多种机制来进行 `DNS` 发现、重定向、指纹验证、认证和消息完整性交换等操作，以便实现完整的 `NAT` 遍历解决方案。

```

                               /-----\
                             // STUN  \\
                            |   Server  |
                             \\       //
                               \-----/




                          +--------------+             Public Internet
          ................|     NAT 2    |.......................
                          +--------------+



                          +--------------+             Private NET 2
          ................|     NAT 1    |.......................
                          +--------------+




                              /-----\
                            //  STUN \\
                           |    Client |
                            \\       //               Private NET 1
                              \-----/

```

上图中，有两个实体（称为 `STUN` 代理），它们实现了 `STUN` 协议。图中较低的代理是客户端，连接到私有网络 1。此网络通过 `NAT 1` 连接到私有网络 2。私有网络 2 通过 `NAT 2` 连接到公共互联网。图中较高的代理是服务器，位于公共互联网上。

`STUN` 是一种`client-server`协议。它支持两种类型的事务(`transactions`)。一种是请求/响应(`request/response`)事务，在其中客户端向服务器发送请求，服务器返回响应。第二种是提示(`indication`)事务，在其中任一代理（客户端或服务器）发送提示，这不会产生响应。这两种类型的事务都包括一个事务 `ID`，这是一个随机选择的 96 位数字。对于请求/响应事务，此事务 `ID` 允许客户端将响应与生成它的请求关联起来；对于提示，事务 `ID` 用作调试工具。

所有 `STUN` 消息都以固定的头开始，其中包括方法(`method`)、类(`class`)和事务 `ID`。

- 方法表明了这是各种事务中的哪一个；本规范仅定义了一种方法，即绑定(`Binding`)，但计划在其他文档中定义一些其他的方法。
- 类表明了这是请求、成功响应、错误响应还是提示。
- 在固定头之后是零个或多个属性，这些属性是 `Type-Length-Value` 扩展，用于传递特定消息的其他信息。

本文档定义了一种名为绑定的方法。绑定方法可以在请求/响应事务或提示事务中使用。

- 在请求/响应事务中使用时，绑定方法可以用于确定 `NAT` 为 `STUN` 客户端分配的特定, 也就是 `NAT` 映射了哪个 `IP` 地址和端口号。
- 在请求/响应或提示事务中使用时，绑定方法还可以用于保持这些绑定处于活动状态, 以确保这些映射不会过期。

当 `Stun` 客户端想要知道其公网 `IP` 地址和端口号时，它会向 `Stun` 服务器发送一个绑定请求，`Stun` 服务器会将反射性传输地址(`reflexive transport address`)（即该请求经过 `NAT` 后对应的公网 `IP` 地址和端口号）作为响应的 `XOR-MAPPED-ADDRESS` 属性返回给 `Stun` 客户端。

在绑定请求/响应事务中，`STUN` 客户端向 `STUN` 服务器发送绑定请求。当绑定请求到达 `STUN` 服务器时，它可能已经通过 `STUN` 客户端和 `STUN` 服务器之间的一个或多个 `NAT`（在图 1 中有两个这样的 `NAT`）传递。当绑定请求消息通过 `NAT` 时，`NAT` 将修改数据包的源传输地址（即源 `IP` 地址和源端口）。因此，服务器接收到的请求的源传输地址将是最靠近服务器的 `NAT` 创建的公共 `IP` 地址和端口。这称为反射性传输地址。`STUN` 服务器将该源传输地址复制到 `STUN` 绑定响应中的 `XOR-MAPPED-ADDRESS` 属性中，并将绑定响应发送回 `STUN` 客户端。当此数据包经过 `NAT` 返回时，`NAT` 将修改 `IP` 头中的目标传输地址(`NAT` 需要将数据包的目标传输地址修改为 `STUN` 客户端的私有 `IP` 地址和端口号，以确保 `STUN` 客户端能够正确接收到响应消息。)，但 `STUN` 响应主体中的 `XOR-MAPPED-ADDRESS` 属性中的传输地址将保持不变。通过这种方式，客户端可以了解其相对于 `STUN` 服务器最外层 `NAT` 分配的反射性传输地址。

在某些用法中，必须将 `STUN` 与其他协议（例如[`MMUSIC-ICE`]，[`SIP-OUTBOUND`]）进行多路复用。在这些用法中，必须有一种方法来检查数据包并确定它是否为 `STUN` 数据包。`STUN` 在 `STUN` 头中定义了三个带有固定值的字段，可用于此目的。如果这不足够，则 `STUN` 数据包还可以包含指纹值，这可以进一步用于区分数据包。

`STUN` 定义了一组可选的机制(`mechanisms`)，这些机制是可选的,包括 `DNS` 发现、重定向到备用服务器的技术、用于多路复用的指纹属性以及两个身份验证和消息完整性交换。**身份验证机制围绕使用用户名、密码和消息完整性值展开。** 本规范定义了两种身份验证机制，即**长期凭证机制和短期凭证机制。** 每个用法都指定允许使用的机制。

```
DNS 发现（DNS Discovery）是一个过程，通过查询 Domain Name System（DNS）来查找和获取网络服务或设备的相关信息。DNS 本身是互联网的一项基本服务，将人类可读的域名（如 example.com）转换为与之对应的 IP 地址（如 192.0.2.1），从而使计算机和其他设备能够找到并访问这些服务或资源。

DNS 发现的一些常见应用包括：

- 服务发现：通过 DNS 查询，客户端可以发现提供特定服务的服务器。例如，客户端可能需要找到提供电子邮件服务的服务器，或者寻找负责处理特定 API 请求的服务器。

- 负载均衡：DNS 发现可以用于实现负载均衡，通过将不同的 IP 地址分配给相同的域名，从而使流量在多个服务器之间分散。当客户端查询该域名时，DNS 服务器可以根据负载均衡策略返回不同的 IP 地址。

- 故障切换：当一个服务的主服务器出现故障时，DNS 发现可以将流量重新路由到备用服务器。这可以通过修改 DNS 记录实现，将域名映射到其他可用的 IP 地址。

- 地理定位：DNS 发现还可以用于根据客户端的地理位置返回最佳的服务器地址。例如，如果一个全球性的网站在不同地区有多个数据中心，DNS 服务器可以根据客户端的位置返回最近的数据中心的 IP 地址，从而减少延迟并提高性能。
```

在长期凭证机制中，客户端和服务器共享预配置的用户名和密码，并执行受 `HTTP` [RFC2617]定义的摘要挑战/响应交换(`digest challenge/ response exchange`)（在细节上有所不同）。在短期凭证机制中，客户端和服务器通过某种方法交换用户名和密码，然后执行 `STUN` 交换(当客户端想要知道其公网 `IP` 地址和端口号时，它会向 `STUN` 服务器发送绑定请求，这是一种使用请求/响应事务的 `STUN` 交换。)。例如，在 `ICE` 用法[`MMUSIC-ICE`]中，两个端点使用信令交换用户名和密码。这些用于完整性保护和身份验证请求和响应。不需要使用 `nonce`(一种随机数，用于防止重放攻击，但在短期凭证机制中不使用它)。

> 重放攻击是指攻击者窃取并重复使用已经传输的数据包，以模拟合法用户的身份来执行欺骗性操作。在 `STUN` 协议中，重放攻击可能会导致身份验证失效，因此使用长期凭证机制时需要使用 `nonce` 来防止重放攻击。`nonce` 是服务器生成的随机数，客户端和服务器通过摘要挑战/响应交换使用 `nonce` 来保护请求和响应的完整性和身份验证。

# 定义

`STUN` 代理(`STUN Agent`)：实现 `STUN` 协议的实体。该实体可以是 `STUN` 客户端或 `STUN` 服务器。

`STUN` 客户端(`STUN Client`)：发送 `STUN` 请求并接收 `STUN` 响应的实体。`STUN` 客户端也可以发送指示。在本规范中，`STUN` 客户端和客户端是同义词。

`STUN` 服务器(`STUN Server`)：接收 `STUN` 请求并发送 `STUN` 响应的实体。`STUN` 服务器也可以发送指示。在本规范中，`STUN` 服务器和服务器是同义词。

传输地址(`Transport Address`)：`IP` 地址和端口号的组合（例如 `UDP` 或 `TCP` 端口号）。

反射性传输地址(`Reflexive Transport Address`)：客户端学习到的传输地址，用于标识该客户端在 `IP` 网络上被另一个主机（通常是 `STUN` 服务器）看到的方式。当客户端和其他主机之间有一个中间的 `NAT` 时，反射性传输地址表示分配给客户端的映射地址，该映射地址位于 `NAT` 的公共侧。反射性传输地址是从 `STUN` 响应中的映射地址属性（`MAPPED-ADDRESS` 或 `XOR-MAPPED-ADDRESS`）中学习到的。

映射地址(`Mapped Address`)：与反射地址的含义相同。仅出于历史原因和 `MAPPED-ADDRESS` 和 `XOR-MAPPED-ADDRESS` 属性的命名原因，保留了此术语。

长期凭证(`Long-Term Credential`)：代表客户端和服务器之间的共享秘密的用户名和关联密码。当用户订阅某项服务时，通常会向客户端授予长期凭证，直至用户取消订阅该服务或明确更改凭证为止。

长期密码(`Long-Term Password`)：长期凭证的密码。

短期凭证(`Short-Term Credential`)：表示客户端和服务器之间共享的临时用户名和相关密码的共享密码。短期凭证是通过客户端和服务器之间的某种协议机制获得的，在 `STUN` 交换之前。短期凭证具有显式的时间范围，可以基于特定的时间量（例如 5 分钟）或事件（例如 `SIP` 对话的终止）等。短期凭证的具体范围由应用程序使用定义。

短期密码(`Short-Term Password`)：短期凭证的密码组件。

`STUN` 指示(`STUN Indication`)：不接收响应的 `STUN` 消息。

属性(`Attribute`)：可以添加到 `STUN` 消息中的类型-长度-值（`TLV`）对象的 `STUN` 术语。属性分为两种类型：理解所需和理解可选(`comprehension-required and comprehension-optional`)。`STUN` 代理可以安全地忽略它们不理解的可选属性，但如果消息包含未被理解的所需属性，则无法成功处理该消息。

`RTO`：重传超时，定义请求传输和第一次重传之间的初始时间段。

# `stun` 消息结构

`STUN` 消息使用面向网络的格式进行二进制编码（最高有效字节或八位字节优先，也常称为大端）。消息的传输顺序在 `RFC` 791 [`RFC0791`]的附录 `B` 中详细描述。除非另有说明，数字常量均为十进制（基数 10）。

> 大端（`Big-endian`）是一种数据的排序方式，其中数值的高位保存在内存低地址中，而数值的低位保存在内存高地址中。这种排序方式是网络字节序的标准排序方式，也被称为网络字节序的高位优先（`Most Significant Byte First，MSB First`）。与之相对的是小端（`Little-endian`）排序方式，其中数值的低位保存在内存低地址中，而数值的高位保存在内存高地址中。

所有 `STUN` 消息必须以 20 字节的头部开始，然后是零个或多个属性。`STUN` 头包含 `STUN` 消息类型、`Magic Cookie`、事务 `ID` 和消息长度。

```
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0|     STUN Message Type     |         Message Length        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Magic Cookie                          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                     Transaction ID (96 bits)                  |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

```

每个 `STUN` 消息的最高有效 2 位必须为零。当 `STUN` 与其他协议在同一个端口上复用时，可以使用此特性来区分 `STUN` 数据包和其他协议的数据包。消息类型定义了 `STUN` 消息的消息类（请求、成功响应、失败响应或指示）和 消息方法。虽然有四个消息类，但是 `STUN` 中只有两种类型的事务：请求/响应事务（包括请求消息和响应消息）和指示事务（包括单个指示消息）。为了快速处理 `STUN` 消息，响应类被分为错误响应和成功响应。消息类型字段进一步分解为以下结构：

```
                        0                 1
                        2  3  4 5 6 7 8 9 0 1 2 3 4 5

                       +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
                       |M |M |M|M|M|C|M|M|M|C|M|M|M|M|
                       |11|10|9|8|7|1|6|5|4|0|3|2|1|0|
                       +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
                  0  0  0  0  0 0 0 1 0 0 0 0 0 0 0 1 = 0x0101(成功响应)
                  0  0  0  0  0 0 0 0 0 0 0 0 0 0 0 1 = 0x0001(请求)
                  0  0  0  0  0 0 0 0 0 0 0 1 0 0 0 1 = 0x0011(指示)
                  0  0  0  0  0 0 0 1 0 0 0 1 0 0 0 1 = 0x0111(错误响应)
```

这里显示了消息类型字段中的位，从最高有效位（`M11`）到最低有效位（`M0`）。`M11` 到 `M0` 表示方法的 12 位编码。C1 和 C0 表示类的 2 位编码。类为 `0b00` 表示请求，类为 `0b01` 表示指示，类为 `0b10` 表示成功响应，类为 `0b11` 表示错误响应。本规范定义了一个单一的方法 `Binding`。方法和类是正交的，因此对于每个方法，该方法的请求、成功响应、错误响应和指示都是可能的。定义新方法的扩展必须指出该方法允许哪些类。例如，`Binding` 请求的类=`0b00`（请求）和方法=`0b000000000001`（Binding），编码为前 16 位为 `0x0001`。`Binding` 响应的类=`0b10`（成功响应）和方法=`0b000000000001`，编码为前 16 位为 `0x0101`。注意：这种不幸的编码是由于[`RFC3489`]中赋值没有考虑使用位字段对指示、成功和错误进行编码。

> 一共 16 位：最高有效位： 2 位，类： 2 位，方法： 12 位，2 + 2 + 12 = 16 位， 类别和方法的值在编码时被合并到一个 16 位的值中。

> 消息头部一共 20 字节：消息类型 2 字节 + 消息长度 2 字节 + `Magic Cookie` 4 字节 + 事务 `ID` 12 字节 = 20 字节。

`Magic Cookie` 字段必须包含网络字节序中的固定值 `0x2112A442`。在 [`RFC3489`]中，此字段是事务 `ID` 的一部分；将 `Magic Cookie` 放置在此位置允许服务器检测客户端是否理解在此修订规范中添加的某些属性。此外，当 `STUN` 与其他协议在同一端口上复用时，它有助于区分 `STUN` 数据包和其他协议的数据包。事务 `ID` 是一个 96 位的标识符，用于唯一标识 `STUN` 事务。对于请求/响应事务，事务 `ID` 由 `STUN` 客户端为请求选择，服务器在响应中回显。对于指示，它是由发送指示的代理选择的。它主要用于将请求与响应相关联，但它还在帮助防止某些类型的攻击方面发挥了一定作用。服务器还将事务 `ID` 用作在所有客户端之间唯一标识每个事务的关键。因此，事务 `ID` 必须从区间 0~2^{96-1} 中均匀随机选择，并且应该是加密随机的。相同请求的重新发送重用相同的事务 `ID`，但是除非新的请求与先前的请求在位上完全相同并从相同的传输地址发送到相同的 `IP` 地址，否则客户端必须为新的事务选择新的事务 `ID`。**成功和错误响应必须携带与其对应的请求相同的事务 `ID`**。当一个代理在同一个端口上充当 `STUN` 服务器和 `STUN` 客户端时，代理发送的请求中的事务 `ID` 与代理接收到的请求中的事务 `ID` 没有关系。

消息长度必须包含消息的大小（以字节为单位），不包括 20 字节的 `STUN` 头。由于所有 `STUN` 属性都填充为 4 字节的倍数，因此此字段的最后 2 位始终为零。这提供了另一种区分 `STUN` 数据包和其他协议数据包的方法。
在 `STUN` 头的固定部分之后是零个或多个属性。每个属性都是 `TLV`（类型-长度-值）编码的。编码的细节和属性本身的细节在第 15 节中给出。

# 基本协议流程

本节定义了 `STUN` 协议的基本流程。它描述了如何构建消息，如何发送消息，以及在接收到消息时如何处理。同时，它还详细定义了 `Binding` 方法的处理。本文档的其他部分描述了在某些情况下，某个用法可能选择使用的可选流程。其他文档可能通过添加新方法、新属性或新错误响应代码来定义 `STUN` 的其他扩展。

## 构建请求或指示

当构建请求或指示消息时，代理必须遵循第 6 节中创建头部的规则。此外，消息类别必须为 `Request`（请求）或 `Indication`（指示），方法必须为 `Binding` 或其他文档中定义的某种方法。

代理接着添加由方法或用法指定的任何属性。例如，某些用法可能要求代理使用身份验证方法（第 10 节）或 `FINGERPRINT` 属性（第 8 节）。

如果代理正在发送请求，它应在请求中添加一个 `SOFTWARE` 属性。代理可以根据方法在指示中包含 `SOFTWARE` 属性。`STUN` 的扩展应讨论在新指示中 `SOFTWARE` 是否有用。

对于没有身份验证的 `Binding` 方法，除非用法另有规定，否则不需要任何属性。

所有通过 `UDP` 发送的 `STUN` 消息的大小应该小于路径 `MTU`（如果已知）。如果路径 `MTU` 未知，`IPv4` 的消息应小于 576 字节和第一跳 `MTU` [`RFC1122`]，`IPv6` 的消息应小于 1280 字节 [`RFC2460`]。这个值对应于 `IP` 数据包的总大小。因此，对于 `IPv4`，实际的 `STUN` 消息需要小于 548 字节（576 减去 20 字节 `IP` 头部，减去 8 字节 `UDP` 头部，假设没有使用 `IP` 选项）。`STUN` 无法处理请求小于 `MTU` 但响应大于 `MTU` 的情况。预计这种限制不会对 `STUN` 造成问题。`MTU` 限制是一个建议（`SHOULD`），而不是一个必须（`MUST`），以解决 `STUN` 本身被用于探测 `MTU` 特性 [`BEHAVE-NAT`] 的情况。在此类应用以外，必须遵循 `MTU` 约束。

> `MTU`（`Maximum Transmission Unit`，最大传输单元）是指网络中单个数据包的最大尺寸，包括数据和协议头部信息。不同类型的网络和通信链路具有不同的 `MTU` 大小。`MTU` 是网络层（如 `IP` 层）的概念，它限制了网络层所能处理的最大数据包的大小。在 `IP` 层，如果一个数据包的大小超过了 `MTU`，那么该数据包将被分片（`fragmentation`）或丢弃。

> 在 `TCP/IP` 协议栈中，`IPv4` 和 `IPv6` 的默认 `MTU` 大小分别为 576 字节和 1280 字节。当然，在实际应用中，链路层的 `MTU`（如以太网的 `MTU`）通常会更大。以太网的标准 `MTU` 为 1500 字节。

## 发送请求或指示

代理接下来发送请求或指示。本文档规定了如何通过 `UDP`、`TCP` 或 `TLS-over-TCP` 发送 `STUN` 消息；将来可能会添加其他传输协议。`STUN` 使用必须指定使用哪种传输协议，以及代理如何确定接收者的 `IP` 地址和端口。第 9 节描述了一种基于 `DNS` 的确定服务器 `IP` 地址和端口的方法，使用者可以选择使用。`STUN` 可以与任播地址（`anycast addresses`）一起使用，但仅限于使用 `UDP` 的情况，且在不使用认证的使用场景中。
在任何时候，客户端可以与同一个 `STUN` 服务器有多个未完成的 `STUN` 请求（即有不同事务 `ID` 的多个进行中事务）。如果没有其他限制新事务的速率（如 `ICE` 用于连接检查或 `STUN` 运行在 `TCP` 上时所指定的限制），客户端应该将新事务之间的间隔设置为 `RTO`，并且应该将同一个服务器的未完成事务限制在十个以内。

### 通过 `UDP` 发送

在通过 `UDP` 运行 `STUN` 时，网络可能会丢弃 `STUN` 消息。通过客户端应用程序自身重新传输请求消息来实现 `STUN` 请求/响应事务的可靠性。**`STUN` 指示不会被重传；因此，通过 `UDP` 的指示事务不是可靠的。**

客户端应该以 `RTO`（“重传超时”）间隔开始重传 `STUN` 请求消息，并在每次重传后加倍。`RTO` 是往返时间（`RTT`）的估计，并按照[`RFC2988`] 中描述的方式计算，但有两个例外。首先，`RTO` 的初始值应该是可配置的（而不是 `RFC 2988` 推荐的 3 秒），并且应该大于 500 毫秒。对于这个“应该”的例外情况是，当使用其他机制来推导拥塞阈值（如 `ICE` 为固定速率流定义的阈值），或者当 `STUN` 用于具有已知网络容量的非互联网环境时。在固定线路接入链路中，建议使用 500 毫秒的值。其次，`RTO` 的值不应四舍五入到最接近的秒。相反，应该保持 1 毫秒的精度。与 `TCP` 一样，建议使用 `Karn` 算法 [`KARN87`]。将其应用于 `STUN` 时，意味着不应从导致请求重传的 `STUN` 事务中计算 `RTT` 估计。

在事务完成后，客户端应该缓存 `RTO` 的值，并将其用作下一次事务到同一服务器的 `RTO` 的初始值（基于 `IP` 地址的相等）。这个值在 10 分钟后应被认为是过时的并被丢弃。
重传将持续进行，直到收到响应，或者直到发送了 `Rc` 个请求。`Rc` 应该是可配置的，默认值应为 7。如果在发送最后一个请求后，一个等于 `Rm` 乘以 `RTO` 的持续时间已经过去，但仍未收到响应（如果只有这个最后一个请求实际上成功，那么有足够的时间获得响应），客户端应该认为该事务失败。`Rm` 应该是可配置的，默认值应为 16。如果在一个硬 `ICMP` 错误 [`RFC1122`] 的情况下，`UDP` 上的 `STUN` 事务也被认为是失败的。例如，假设 `RTO` 为 500 毫秒，请求将在 0 毫秒、500 毫秒、1500 毫秒、3500 毫秒、7500 毫秒、15500 毫秒和 31500 毫秒时发送。如果客户端在 39500 毫秒后还没有收到响应，客户端将认为事务已超时。

> rm = 16, rto = 500ms, rc = 7: 31500 ms + rm _ rto = 31500 ms + 16 _ 500 ms = 39500 ms

### 在 `TCP` 或 `TLS-over-TCP` 上发送

对于 `TCP` 和 `TLS-over-TCP`，客户端向服务器打开 `TCP` 连接。在 `STUN` 的某些使用场景中，`STUN` 是通过 `TCP` 连接单独发送的。在这种情况下，它可以在不需要任何额外帧同步或多路复用的情况下发送。在其他使用场景或其他扩展中，`STUN` 可能与 `TCP` `连接上的其他数据进行多路复用。在这种情况下，STUN` 必须在某种帧同步协议的基础上运行，由使用场景或扩展指定，以便代理可以提取完整的 `STUN` 消息和完整的应用层消息。运行在众所周知的端口上的 `STUN` 服务，或者通过第 9 节中的 `DNS` 过程发现的端口，仅用于 `STUN` 本身，而不是与其他数据一起多路复用的 `STUN`。因此，在连接到这些服务器时不使用帧同步协议。当使用额外的帧同步时，使用场景将指定客户端如何应用它以及连接到哪个端口。例如，在 `ICE` 连接检查的情况下，此信息是通过客户端和服务器之间的带外协商获得的。

当 `STUN` 自身在 `TLS-over-TCP` 上运行时，至少必须实现 `TLS_RSA_WITH_AES_128_CBC_SHA` 密码套件。实现还可以支持任何其他密码套件。当客户端收到 `TLS` 证书消息时，应验证证书并检查证书中标识的站点。如果证书无效或被撤销，或者没有标识合适的方，客户端必须不发送 `STUN` 消息或以其他方式继续 `STUN` 事务。客户端必须验证服务器的身份。为此，它遵循 `RFC 2818` 第 3.1 节中定义的识别过程[`RFC2818`]。这些过程假设客户端正在解引用 `URI`。为了与本规范一起使用，客户端将第 8.1 节中使用的域名或 `IP` 地址视为已解引用的 `URI` 的主机部分。或者，客户端可以配置为信任一组域名或 `IP` 地址；如果收到一个标识这些域名或 `IP` 地址之一的证书，客户端就认为服务器的身份已经过验证。

当 `STUN` 与其他协议一起在 `TLS-over-TCP` 连接上多路复用时，强制性密码套件和 `TLS` 处理过程将按照这些协议定义的方式进行操作。`STUN` 在 `TCP` 和 `TLS-over-TCP` 上的可靠性是通过 `TCP` 本身处理的，`STUN` 协议级别没有重传。然而，对于请求/响应事务，如果客户端在发送 `SYN` 建立连接后的 `Ti` 秒内没有收到响应，它将认为事务已超时。`Ti` 应该是可配置的，且默认值应为 39.5 秒。该值被选择为默认初始 `RTO` 的 `TCP` 和 `UDP` 超时相等。

此外，如果客户端无法建立 `TCP` 连接，或者在收到响应之前 `TCP` 连接被重置或失败，则任何进行中的请求/响应事务都被认为是失败的。客户端可以在单个 `TCP`（或 `TLS-over-TCP`）连接上发送多个事务，也可以在收到前一个响应之前发送另一个请求。客户端应保持连接打开，直到满足以下条件：

- 没有进一步的 `STUN` 请求或指示要通过该连接发送，
- 不再计划使用通过该连接发送的 `STUN` 请求了解的任何资源（如映射地址（`MAPPED-ADDRESS` 或 `XOR-MAPPED-ADDRESS`）或中继地址[`BEHAVE-TURN`]），
- 如果在该端口上多路复用其他应用协议，则完成使用其他应用程序，
- 如果使用已学习的端口与远程对等方通信，则已与远程对等方建立通信，这是某些 `TCP NAT` 遍历技术所需的（例如，[`MMUSIC-ICE-TCP`]）。

在服务器端，服务器应保持连接打开，让客户端关闭它，除非服务器确定连接已超时（例如，由于客户端断开网络连接）。只要连接保持打开，客户端学到的绑定在 `NAT` 中将保持有效。只有客户端知道它需要绑定多长时间。服务器不应在收到连接请求后关闭连接。服务器不能向客户端打开一个连接以发送响应。服务器在过载情况下应遵循有关连接管理的最佳实践。

> 在`TCP`或`TLS-over-TCP`上发送`STUN`时，客户端会向服务器打开`TCP`连接。`STUN`可以作为唯一协议通过`TCP`发送，也可以与其他数据一起通过`TCP`连接进行多路复用。`STUN`在`TCP`和`TLS-over-TCP`上的可靠性由`TCP`本身处理。客户端可以在单个`TCP`（或`TLS-over-TCP`）连接上发送多个事务。服务器应保持连接打开，并让客户端关闭它。

## 接收 STUN 消息

本节规定了 `STUN` 消息的处理。这里规定的处理适用于本规范中定义的 `STUN` 消息；第 12 节定义了向后兼容的附加规则。这些附加程序是可选的，各种用途可以选择使用它们。首先，应用一组独立于类别的处理操作。接下来是特定于类别的处理，如下面的子节所述。

当 `STUN` 代理接收到 `STUN` 消息时，首先检查消息是否遵循第 6 节的规则。它检查前两位是否为 0，`magic cookie` 字段是否具有正确的值，消息长度是否合理，方法值是否为支持的方法。它检查消息类别是否允许特定方法。如果消息类别是“成功响应”或“错误响应”，代理检查事务 `ID` 是否与仍在进行的事务匹配。如果正在使用 `FINGERPRINT` 扩展，代理检查 `FINGERPRINT` 属性是否存在且包含正确的值。**如果检测到任何错误，消息将被静默丢弃。** 在 `STUN` 与其他协议多路复用的情况下，错误可能表明这并非真正的 `STUN` 消息；在这种情况下，代理应尝试将消息解析为其他协议。

`STUN` 代理然后执行用途指定的认证机制所需的任何检查（参见第 10 节）。

一旦完成认证检查，`STUN` 代理检查消息中的未知属性和已知但意外的属性。未知的可理解可选属性必须被代理忽略。已知但意外的属性应被代理忽略。未知的可理解必需属性会导致依赖于消息类别的处理，如下所述。此时，进一步处理取决于请求的消息类别。

### 处理请求

如果请求包含一个或多个未知的必需理解属性，服务器将回复一个带有错误代码 420（未知属性）的错误响应，并在响应中包含一个 `UNKNOWN-ATTRIBUTES` 属性，列出未知的必需理解属性。

然后，服务器进行方法或特定用途要求的任何其他检查。如果所有检查都成功，服务器会按照下面的描述制定成功响应。

在 `UDP` 上运行时，**服务器接收到的请求可能是事务的第一个请求，也可能是重传。** 服务器必须对重传进行响应，以保留以下属性：

- 如果客户端接收到重传的响应而不是发送给原始请求的响应，客户端和服务器上的整体状态与只接收到原始重传响应的情况相同，或者两个响应都接收到的情况下（此时客户端将使用第一个）。

满足此要求的最简单方法是服务器记住在过去 40 秒内通过 `UDP` 接收到的所有事务 `ID` 及其相应的响应。然而，这需要服务器保持状态，并且对于未经认证的请求是不合适的。另一种方法是重新处理请求并重新计算响应。后一种技术必须仅应用于幂等请求（当相同的请求可以安全地重复而不影响系统的整体状态时，认为请求是幂等的），并且对于相同的请求产生相同的成功响应。`Binding` 方法被认为是幂等的。请注意，某些罕见的网络事件可能导致反射传输地址值发生变化，从而导致不同成功响应中的映射地址不同。`STUN` 的扩展必须讨论不存储事务状态的服务器上请求重传的影响。

#### 生成成功或错误响应

当服务器生成响应（成功或错误）时，需要遵循第 6 节的规则。响应的方法与请求相同，消息类别是"`Success Response`"（成功响应）或"`Error Response`"（错误响应）。

对于错误响应，服务器必须添加一个 `ERROR-CODE` 属性，其中包含上述处理中指定的错误代码。原因短语不固定，但应该是适合错误代码的内容。对于某些错误，会在消息中添加额外的属性。这些属性在描述错误代码时详细说明。例如，对于错误代码 420（`Unknown Attribute`，未知属性），服务器必须包含一个 `UNKNOWN-ATTRIBUTES` 属性。某些身份验证错误也会导致添加属性（参见第 10 节）。扩展可以定义其他错误和/或在错误情况下添加额外属性。

如果服务器使用身份验证机制对请求进行了身份验证，则服务器应在响应中添加适当的身份验证属性（参见第 10 节）。

服务器还会根据特定方法或用途添加任何所需的属性。此外，服务器应在消息中添加一个 `SOFTWARE` 属性。

对于 `Binding` 方法，除非用途另有规定，否则不需要额外的检查。在生成成功响应时，服务器会在响应中添加一个 `XOR-MAPPED-ADDRESS` 属性，其中属性的内容是请求消息的源传输地址。对于 `UDP`，这是请求消息的源 `IP` 地址和源 `UDP` 端口。对于 `TCP` 和 `TLS-over-TCP`，这是服务器看到的 `TCP` 连接的源 `IP` 地址和源 `TCP` 端口。

#### 发送成功或错误响应

响应（成功或错误）将通过与接收请求相同的传输方式发送。如果请求是通过 `UDP` 接收的，响应的目标 `IP` 地址和端口与接收到的请求消息的源 `IP` 地址和端口相同，响应的源 `IP` 地址和端口与接收到的请求消息的目标 `IP` 地址和端口相同。如果请求是通过 `TCP` 或 `TLS-over-TCP` 接收的，则响应将通过与接收请求相同的 `TCP` 连接发送回去。

### 处理指示消息

**如果指示消息中包含未知的必需理解属性，该指示将被丢弃，处理终止。**

然后，代理执行该方法或特定用途所需的任何其他检查。如果所有检查都成功，则代理接着处理指示消息。对于指示消息，不会生成响应。

对于 `Binding` 方法，除非用途另有规定，否则不需要进行其他检查或处理。代理仅接收消息即刷新了中间 `NAT` 中的“绑定”。

由于指示消息在 `UDP` 上不会被重传（与请求不同），因此无需在发送代理处处理指示消息的重传。

### 处理成功响应

如果成功响应中包含未知的必需理解属性，该响应将被丢弃，且该事务被视为失败。
然后，客户端执行该方法或特定用途所需的任何其他检查。如果所有检查都成功，则客户端接着处理成功响应。

对于 `Binding` 方法，客户端检查响应中是否存在 `XOR-MAPPED-ADDRESS` 属性。客户端检查指定的地址族。如果地址族不受支持，则应忽略该属性。如果是意外的但受支持的地址族（例如，`Binding` 事务是通过 `IPv4` 发送的，但指定的地址族是 `IPv6`），则客户端可以选择接受并使用该值。

### 处理错误响应

如果错误响应中包含未知的必需理解属性，或者错误响应中不包含 `ERROR-CODE` 属性，那么事务只需被视为失败。
接着，客户端执行认证机制所指定的任何处理（参见第 10 节）。这可能导致新的事务尝试。

此时的处理取决于错误代码、方法和用途；以下是默认规则：

- 如果错误代码为 300 至 399，除非使用 `ALTERNATE-SERVER` 扩展，客户端应将事务视为失败。请参阅第 11 节。
- 如果错误代码为 400 至 499，客户端宣布事务失败；对于 420（未知属性）错误代码，响应应包含一个 `UNKNOWN-ATTRIBUTES` 属性，提供额外信息。
- 如果错误代码为 500 至 599，客户端可以选择重发请求；选择这样做的客户端必须限制他们这样做的次数。

任何其他错误代码会导致客户端将事务视为失败。

# `FINGERPRINT` 机制

本节描述了一个可选的 `STUN` 机制，有助于在将两者复用到同一传输地址时，区分 `STUN` 消息和其他协议的数据包。此机制是可选的，**`STUN` 用法必须描述是否以及何时使用它。** `FINGERPRINT` 机制与 `RFC 3489` 不向后兼容，不能在需要这种兼容性的环境中使用。

在某些用途中，`STUN` 消息与其他协议（如实时传输协议（`RTP`））复用在同一传输地址上。为了应用第 7 节描述的处理过程，首先需要将 `STUN` 消息与应用程序数据包分开。第 6 节描述了 `STUN` 标头中可用于此目的的三个固定字段。然而，在某些情况下，这三个固定字段可能不足以应对。

当使用 `FINGERPRINT` 扩展时，代理会在发送给另一个代理的消息中包含 `FINGERPRINT` 属性。第 15.5 节描述了此属性的位置和值。当代理收到其认为是 `STUN` 消息的内容时，除了进行其他基本检查之外，代理还会检查消息是否包含 `FINGERPRINT` 属性，以及属性是否包含正确的值。第 7.3 节描述了在 `STUN` 消息的整体处理过程中何时执行 `FINGERPRINT` 检查。这个额外的检查有助于代理检测到可能看似 `STUN` 消息的其他协议的消息。

# `DNS` 服务器发现

本节描述了一个可选的 `STUN` 程序，允许客户端使用 `DNS` 确定服务器的 `IP` 地址和端口。`STUN` 用法必须描述是否以及何时使用此扩展。要使用此程序，客户端必须知道服务器的域名和服务名；用法还必须描述客户端如何获取这些信息。不建议将服务器的域名硬编码到软件中，以防域名丢失或因法律或其他原因需要更改。

当客户端希望在公共互联网中找到一个接受绑定请求/响应事务的 `STUN` 服务器时，`SRV` 服务名为 "`stun`"。当它希望找到一个在 `TLS` 会话上接受绑定请求/响应事务的 `STUN` 服务器时，`SRV` 服务名为 "`stuns`"。`STUN` 用法可以定义其他 `DNS SRV` 服务名称。

使用 [`RFC2782`] 中规定的 `SRV` 程序将域名解析为传输地址。`DNS SRV` 服务名是作为此过程输入的服务名。`SRV` 查找中的协议是客户端将在其上运行 `STUN` 的传输协议："`udp`" 代表 `UDP`，"`tcp`" 代表 `TCP`。请注意，目前仅在 "`stuns`" 中定义了 "`tcp`"。

遵循 `RFC 2782` 的规程以确定要联系的服务器。`RFC 2782` 详述了一组 `SRV` 记录如何排序和尝试的细节。然而，`RFC 2782` 只是指出客户端应该 "尝试连接到（协议，地址，服务）"，而没有给出在失败情况下发生什么的详细信息。在遵循这些程序时，如果 `STUN` 事务在未收到响应的情况下超时，客户端应该将请求重试到 `RFC 2782` 定义的顺序中的下一个服务器。这种重试只适用于请求/响应传输，因为指示事务不会生成响应或超时。

`STUN` 请求的默认端口是 3478，适用于 `TCP` 和 `UDP`。`STUN` 服务器的管理员应该在他们的 `SRV` 记录中为 `UDP` 和 `TCP` 使用这个端口。在所有情况下，`DNS` 中的端口必须反映服务器正在监听的端口。`STUN over TLS` 的默认端口是 5349。如果服务器软件支持确定初始消息是 `TLS` 消息还是 `STUN` 消息，服务器可以在与 `STUN over TCP` 相同的端口上运行 `STUN over TLS`。

如果没有找到 `SRV` 记录，客户端对域名执行 `A` 或 `AAAA` 记录查找。结果将是一组 `IP` 地址，每个地址都可以使用 `UDP` 或 `TCP` 在默认端口上联系，与 `STUN` 用法无关。对于需要 `TLS` 的用法，客户端使用默认的 `STUN over TLS` 端口连接到其中一个 `IP` 地址。
