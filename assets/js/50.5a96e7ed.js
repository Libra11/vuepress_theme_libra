(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{415:function(t,v,n){"use strict";n.r(v);var a=n(12),_=Object(a.a)({},(function(){var t=this,v=t.$createElement,n=t._self._c||v;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"摘要"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[t._v("#")]),t._v(" 摘要")]),t._v(" "),n("p",[t._v("该规范定义了一种 Traversal Using Relays around NAT (TURN) 的扩展，这是一种用于网络地址转换器 (NAT) 穿越的中继协议。该扩展允许 TURN 客户端请求 TCP 分配，并为 TURN 服务器定义了新的请求和指示，以便与客户端的对等方打开和接受 TCP 连接。TURN 和该扩展都有意限制了中继地址的使用方式。特别是，它防止用户从从 TURN 服务器获取的端口运行通用服务器。")]),t._v(" "),n("h2",{attrs:{id:"简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),n("p",[t._v("Traversal Using Relays around NAT (TURN) 是会话遍历实用程序（STUN）协议的扩展。TURN 允许客户端与 TURN 服务器通信，并要求其在其主机接口之一上分配端口，然后在该端口和客户端之间中继流量。TURN 与 STUN 和 Interactive Connectivity Establishment (ICE)一起使用，形成了 UDP 媒体会话的 NAT 遍历解决方案。")]),t._v(" "),n("p",[t._v("但是，TURN 本身并没有提供一种让客户端在 TURN 服务器上分配基于 TCP 的端口的方法。在需要与对等方进行基于 TCP 的会话且 NAT 阻止直接 TCP 连接的情况下，需要这样的分配。例如，在桌面软电话之间共享应用程序或在语音通信会话期间传输图片。")]),t._v(" "),n("p",[t._v("本文档定义了 TURN 的扩展，允许客户端获取 TCP 分配。它还允许客户端从该分配发起对等方的传出 TCP 连接，并接受向该分配发出的对等方的传入 TCP 连接请求。")]),t._v(" "),n("p",[t._v("术语“TCP 分配”表示使用 TCP 作为传输协议而不是 UDP 的 TURN 分配。这种分配由其中继传输地址唯一标识，该地址由 IP 地址和 TCP 端口组成。")]),t._v(" "),n("h2",{attrs:{id:"操作概述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#操作概述"}},[t._v("#")]),t._v(" 操作概述")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("                                                      +--------+\n                                                      |        |\n                                                      | Peer1  |\n                                                   /  |        |\n                                                  /   |        |\n                                                 /    +--------+\n                                                /\n                                               /\n                                              / Peer Data 1\n                                             /\n      +--------+  Control       +--------+  /\n      |        | -------------- |        | /\n      | Client | Client Data 1  | TURN   |\n      |        | -------------- | Server | \\\n      |        | -------------- |        |  \\\n      +--------+ Client Data 2  +--------+   \\\n                                              \\\n                                               \\\n                                                \\     +--------+\n                                                 \\    |        |\n                                      Peer Data 2 \\   | Peer2  |\n                                                   \\  |        |\n                                                      |        |\n                                                      +--------+\n\n                         Figure 1: TURN TCP Model\n")])])]),n("p",[t._v("TURN-TCP 的总体模型如图 1 所示。客户端将与其 TURN 服务器具有两种不同类型的连接。对于每个分配的中继传输地址，它将具有单个控制连接。控制连接用于获取分配并打开新连接。此外，对于与对等方的每个连接，客户端将具有单个连接到其 TURN 服务器。这些连接称为数据连接。因此，从客户端到其 TURN 服务器有一个数据连接（客户端数据连接），从 TURN 服务器到对等方有一个数据连接（对等方数据连接）。实际应用程序数据在这些连接上发送。实际上，在绑定客户端数据连接到对等方数据连接的初始 TURN 消息之后，只能发送应用程序数据--没有 TURN 消息。这与控制连接相反，后者仅允许 TURN 消息而不允许应用程序数据。")]),t._v(" "),n("p",[t._v("要获取基于 TCP 的分配，客户端首先打开到其 TURN 服务器的 TCP 或 TLS 连接。然后，客户端通过该控制连接发送 Allocate 请求。该请求包含一个 REQUESTED-TRANSPORT 属性，该属性指示所需的基于 TCP 的分配。支持此扩展的服务器将分配一个 TCP 中继传输地址，并开始在其上侦听连接请求。然后，它将在 Allocate 请求的响应中将分配的中继传输地址返回给客户端。发送 Allocate 请求的连接是控制连接。")]),t._v(" "),n("p",[t._v("如果客户端希望从中继传输地址建立到对等方的 TCP 连接，则它通过控制连接向 TURN 服务器发出 Connect 请求。该请求包含一个 XOR-PEER-ADDRESS 属性，该属性标识要建立连接的对等方 IP 地址和端口（即其“传输地址”）。TURN 服务器尝试打开 TCP 连接，并假定成功后，使用成功响应响应 Connect 请求。服务器还创建与此连接关联的连接标识符，并将该连接标识符在成功响应中传递回客户端。请注意，每个分配最多只能建立到给定对等方传输地址的一个连接。")]),t._v(" "),n("blockquote",[n("p",[t._v("注意：从客户端到对等方建立中继连接分为两个步骤。首先创建分配，然后建立连接。将两者合并在一起不利于 NAT 遍历。预计在第一步和第二步之间，客户端将使用离线方式与对等方通信（例如，使用 ICE [RFC5245]），并告诉它 TURN 服务器分配的中继传输地址，并从中发起连接。然后，对等方可以“准备就绪”：在其防火墙中打开孔，尝试在 NAT 中打开孔，尝试进行 TCP 同时打开等。")])]),t._v(" "),n("p",[t._v("为了实际发送数据或以其他方式利用新连接，客户端在其 TURN 服务器上建立一个新的 TCP 连接。一旦建立，它通过该新连接向服务器发出 ConnectionBind 请求。该请求将连接标识符回显回 TURN 服务器。TURN 服务器使用它来关联这两个连接。因此，与对等方的 TCP 连接与客户端的 TCP 连接一对一关联。这两个连接现在是数据连接。此时，如果服务器从对等方接收到数据，则将该数据转发到客户端，而不进行任何封装。TURN 服务器从客户端通过客户端数据连接接收到的任何数据都将转发到对等方，同样不进行任何封装或帧化。一旦使用 ConnectionBind 请求绑定了连接，就不再允许在连接上使用 TURN 消息。")]),t._v(" "),n("p",[t._v("类似地，当对等方向中继传输地址打开 TCP 连接时，服务器会检查是否存在该对等方的权限。如果没有，则关闭连接。权限是使用 CreatePermission 请求通过控制连接创建的，就像 UDP TURN 一样。如果存在权限，则 TURN 服务器通过控制连接向客户端发送 ConnectionAttempt Indication。该指示包含连接标识符。再次，客户端通过其与 TURN 服务器的单独 TCP 连接发起连接，并在该连接上发出 ConnectionBind 请求。一旦接收到，TURN 服务器将开始中继数据。如果在超时后未收到 ConnectionBind 请求，则服务器关闭对等方数据连接。")]),t._v(" "),n("p",[t._v("如果客户端关闭客户端数据连接，则关闭相应的对等方数据连接。如果对等方关闭对等方数据连接，则关闭相应的客户端数据连接。通过这种方式，客户端直接了解连接的状态。")]),t._v(" "),n("p",[t._v("TURN 服务器将在客户端和对等方数据连接之间中继数据。中继过程维护端到端的流量控制：如果中继过程无法将数据写入中继数据的目标，则中继过程停止从源读取数据。")]),t._v(" "),n("h2",{attrs:{id:"客户端处理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#客户端处理"}},[t._v("#")]),t._v(" 客户端处理")]),t._v(" "),n("h3",{attrs:{id:"创建分配"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建分配"}},[t._v("#")]),t._v(" 创建分配")]),t._v(" "),n("p",[t._v("要创建 TCP 分配，客户端必须启动到其 TURN 服务器的新 TCP 或 TLS 连接，与[RFC5766]中定义的 TCP 或 TLS 过程相同。不能使用客户端和服务器之间的 UDP 关联来获取 TCP 分配。")]),t._v(" "),n("p",[t._v("一旦设置完成，客户端必须发送 TURN Allocate 请求。该请求必须包含一个 REQUESTED-TRANSPORT 属性，其值为 6，对应于 TCP。")]),t._v(" "),n("p",[t._v("请求不能包括 DONT-FRAGMENT、RESERVATION-TOKEN 或 EVEN-PORT 属性。相应的功能是针对基于 UDP 的功能的，TURN-TCP 不使用这些功能。但是，可以包括一个 LIFETIME 属性，其语义与 UDP 情况相同。")]),t._v(" "),n("p",[t._v("Allocate 请求的身份验证和成功和失败响应的处理程序与 UDP 相同。")]),t._v(" "),n("p",[t._v("一旦收到成功响应，TCP 连接到 TURN 服务器称为该分配的控制连接。")]),t._v(" "),n("h3",{attrs:{id:"刷新分配"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#刷新分配"}},[t._v("#")]),t._v(" 刷新分配")]),t._v(" "),n("p",[t._v("刷新分配的过程与 UDP 的过程相同。请注意，必须在控制连接上发送刷新请求。")]),t._v(" "),n("h3",{attrs:{id:"启动连接"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#启动连接"}},[t._v("#")]),t._v(" 启动连接")]),t._v(" "),n("p",[t._v("为了向对等方发起 TCP 连接，客户端必须通过所需分配的控制连接发送 Connect 请求。Connect 请求必须包含一个 XOR-PEER-ADDRESS 属性，该属性包含所需连接的对等方传输地址。")]),t._v(" "),n("p",[t._v("如果连接成功建立，客户端将收到一个成功响应。该响应将包含一个 CONNECTION-ID 属性。客户端必须使用相同的目标传输地址，通过新的 TCP 连接向服务器发起连接。此连接必须使用不同的本地传输地址进行建立。服务器对客户端的身份验证必须使用与控制连接相同的方法和凭据。一旦建立，客户端必须通过新连接发送 ConnectionBind 请求。该请求必须包含从 Connect 成功响应中回显的 CONNECTION-ID 属性。当收到 ConnectionBind 请求的响应时，如果成功，则发送该请求的 TCP 连接称为客户端数据连接，对应于对等方。")]),t._v(" "),n("p",[t._v("如果 Connect 请求的结果是错误响应，并且响应代码为 447（连接超时或失败），则表示 TURN 服务器无法连接到对等方。客户端可以使用相同的 XOR-PEER-ADDRESS 属性重试，但必须等待至少 10 秒。")]),t._v(" "),n("p",[t._v("与任何其他请求一样，可以同时发送多个 Connect 请求。但是，具有相同 XOR-PEER-ADDRESS 参数的 Connect 请求不能同时发送。")]),t._v(" "),n("h3",{attrs:{id:"接收连接"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#接收连接"}},[t._v("#")]),t._v(" 接收连接")]),t._v(" "),n("p",[t._v("在成功处理 Allocate 请求后，每当已安装权限的对等方尝试向中继传输地址发起新连接时，客户端将开始接收 ConnectionAttempt 指示。该指示将包含 CONNECTION-ID 和 XOR-PEER-ADDRESS 属性。如果客户端希望接受此连接，则必须使用与控制连接建立到服务器的相同目标传输地址，启动新的 TCP 连接。此连接必须使用不同的本地传输地址进行建立。服务器对客户端的身份验证必须使用与控制连接相同的方法和凭据。一旦建立，客户端必须通过新连接发送 ConnectionBind 请求。该请求必须包含从 ConnectionAttempt 指示中回显的 CONNECTION-ID 属性。当收到 ConnectionBind 请求的响应时，如果成功，则发送该请求的 TCP 连接称为客户端数据连接，对应于对等方。")]),t._v(" "),n("h3",{attrs:{id:"发送和接收数据"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#发送和接收数据"}},[t._v("#")]),t._v(" 发送和接收数据")]),t._v(" "),n("p",[t._v("一旦客户端数据连接建立，客户端发送的数据将原样中继到对等方，服务器将对等方发送的数据原样中继到客户端数据连接。")]),t._v(" "),n("h3",{attrs:{id:"数据连接维护"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据连接维护"}},[t._v("#")]),t._v(" 数据连接维护")]),t._v(" "),n("p",[t._v("客户端必须使用 Refresh 请求刷新分配（对应于数据连接），只要它想保持数据连接处于活动状态，就必须这样做。")]),t._v(" "),n("p",[t._v("当客户端希望终止与对等方的中继连接时，它关闭与服务器的数据连接。")]),t._v(" "),n("blockquote",[n("p",[t._v("注意：不包括保持 NAT 绑定（可能在客户端数据连接以及对等方数据连接上）的机制。TURN-TCP 不提供此服务。如果认为有必要使用此功能，则可以在更高的堆栈中实现，在 TURN-TCP 内部隧道的应用程序协议中。此外，可以使用 TCP keep-alives 来保持客户端数据连接上的 NAT 绑定处于活动状态。")])]),t._v(" "),n("h2",{attrs:{id:"turn-服务器行为"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#turn-服务器行为"}},[t._v("#")]),t._v(" TURN 服务器行为")]),t._v(" "),n("h3",{attrs:{id:"接收-tcp-分配请求"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#接收-tcp-分配请求"}},[t._v("#")]),t._v(" 接收 TCP 分配请求")]),t._v(" "),n("p",[t._v("该过程与[RFC5766]第 6.2 节中定义的过程类似，但有以下例外：")]),t._v(" "),n("ul",[n("li",[t._v("如果包括 REQUESTED-TRANSPORT 属性并指定了除 UDP 或 TCP 之外的协议，则服务器必须使用 442（不支持的传输协议）错误拒绝请求。如果值为 UDP，并且本地策略允许 UDP 传输，则服务器必须继续执行[RFC5766]的过程，而不是本文档。如果值为 UDP，并且本地策略禁止 UDP 传输，则服务器必须使用 403（禁止）错误拒绝请求。")]),t._v(" "),n("li",[t._v("如果客户端连接传输不是 TCP 或 TLS，则服务器必须使用 400（错误请求）错误拒绝请求。")]),t._v(" "),n("li",[t._v("如果请求包含 DONT-FRAGMENT、EVEN-PORT 或 RESERVATION-TOKEN 属性，则服务器必须使用 400（错误请求）错误拒绝请求。")]),t._v(" "),n("li",[t._v("必须分配 TCP 中继传输地址，而不是 UDP 中继传输地址。")]),t._v(" "),n("li",[t._v("成功响应中不能包含 RESERVATION-TOKEN 属性。")])]),t._v(" "),n("p",[t._v("如果所有检查都通过，则服务器必须开始在中继传输地址上接受传入的 TCP 连接。有关详细信息，请参见第 5.3 节。")]),t._v(" "),n("h3",{attrs:{id:"接收连接请求"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#接收连接请求"}},[t._v("#")]),t._v(" 接收连接请求")]),t._v(" "),n("p",[t._v("当服务器收到 Connect 请求时，它会按照以下方式处理请求：")]),t._v(" "),n("p",[t._v("如果请求是在不存在分配的 TCP 连接上接收到的，则服务器必须返回 437（分配不匹配）错误。")]),t._v(" "),n("p",[t._v("如果服务器当前正在处理此分配的具有相同 XOR-PEER-ADDRESS 的 Connect 请求，则必须返回 446（连接已存在）错误。")]),t._v(" "),n("p",[t._v("如果服务器已经成功处理了具有相同 XOR-PEER-ADDRESS 的此分配的 Connect 请求，并且生成的客户端和对等方数据连接处于挂起或活动状态，则必须返回 446（连接已存在）错误。")]),t._v(" "),n("p",[t._v("如果请求不包含 XOR-PEER-ADDRESS 属性，或者该属性无效，则服务器必须返回 400（错误请求）错误。")]),t._v(" "),n("p",[t._v("如果本地策略禁止新连接，则服务器必须使用 403（禁止）错误拒绝请求。否则，服务器必须启动一个传出的 TCP 连接。本地端点是与分配关联的中继传输地址。远程端点是 XOR-PEER-ADDRESS 属性指示的端点。如果连接尝试失败或超时，则服务器必须返回 447（连接超时或失败）错误。超时值必须至少为 30 秒。")]),t._v(" "),n("p",[t._v("如果连接成功，则称为对等方数据连接。服务器必须缓冲从客户端接收到的任何数据。服务器调整其广告的 TCP 接收窗口以反映空缓冲区的数量。")]),t._v(" "),n("p",[t._v("服务器必须在 Connect 成功响应中包含 CONNECTION-ID 属性。该属性的值必须唯一标识对等方数据连接。")]),t._v(" "),n("p",[t._v("如果在 30 秒内未收到与此对等方数据连接关联的 ConnectionBind 请求，则必须关闭对等方数据连接。")]),t._v(" "),n("h3",{attrs:{id:"在中继传输地址上接收到传入的-tcp-连接"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在中继传输地址上接收到传入的-tcp-连接"}},[t._v("#")]),t._v(" 在中继传输地址上接收到传入的 TCP 连接")]),t._v(" "),n("p",[t._v("在中继传输地址上接收到传入的 TCP 连接时，服务器将按以下方式处理请求：")]),t._v(" "),n("p",[t._v("服务器必须接受连接。如果不成功，则不会向客户端发送任何内容。")]),t._v(" "),n("p",[t._v("如果连接成功，则称为对等方数据连接。服务器必须缓冲从对等方接收到的任何数据。服务器调整其广告的 TCP 接收窗口以反映空缓冲区的数量。")]),t._v(" "),n("p",[t._v("如果此分配尚未为此对等方安装权限，则服务器必须在接受连接后立即关闭与对等方的连接。")]),t._v(" "),n("p",[t._v("否则，服务器通过控制连接向客户端发送 ConnectionAttempt 指示。该指示必须包含一个 XOR-PEER-ADDRESS 属性，其中包含对等方的传输地址，以及一个 CONNECTION-ID 属性，用于唯一标识对等方数据连接。")]),t._v(" "),n("p",[t._v("如果在 30 秒内未收到与此对等方数据连接关联的 ConnectionBind 请求，则必须关闭对等方数据连接。")]),t._v(" "),n("h3",{attrs:{id:"接收-connectionbind-请求"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#接收-connectionbind-请求"}},[t._v("#")]),t._v(" 接收 ConnectionBind 请求")]),t._v(" "),n("p",[t._v("当服务器收到 ConnectionBind 请求时，它将按以下方式处理请求。")]),t._v(" "),n("p",[t._v("如果客户端连接传输不是 TCP 或 TLS，则服务器必须使用 400（错误请求）错误拒绝请求。")]),t._v(" "),n("p",[t._v("如果请求不包含 CONNECTION-ID 属性，或者该属性不引用现有的挂起连接，则服务器必须使用 400（错误请求）错误拒绝请求。")]),t._v(" "),n("p",[t._v("否则，客户端连接现在称为客户端数据连接。在该连接上接收到的数据必须按原样发送到关联的对等方数据连接。")]),t._v(" "),n("p",[t._v("在关联的对等方数据连接上接收到的数据必须按原样发送到此客户端数据连接。这包括在成功处理关联的 Connect 或请求之后，但在接收到此 ConnectionBind 请求之前接收到的数据。")]),t._v(" "),n("h3",{attrs:{id:"数据连接维护-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据连接维护-2"}},[t._v("#")]),t._v(" 数据连接维护")]),t._v(" "),n("p",[t._v("如果与数据连接关联的分配过期，则必须关闭数据连接。")]),t._v(" "),n("p",[t._v("当客户端数据连接关闭时，服务器必须关闭相应的对等方数据连接。")]),t._v(" "),n("p",[t._v("当对等方数据连接关闭时，服务器必须关闭相应的客户端数据连接。")]),t._v(" "),n("h2",{attrs:{id:"iana-考虑事项"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#iana-考虑事项"}},[t._v("#")]),t._v(" IANA 考虑事项")]),t._v(" "),n("p",[t._v("本规范定义了几种新的 STUN 方法、STUN 属性和 STUN 错误代码。IANA 将这些新的协议元素添加到 NAT 会话遍历实用程序（STUN）参数注册表中。")]),t._v(" "),n("h3",{attrs:{id:"新的-stun-方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#新的-stun-方法"}},[t._v("#")]),t._v(" 新的 STUN 方法")]),t._v(" "),n("p",[t._v("本节列出了本规范中定义的新 STUN 方法的代码点。有关这些新方法的语义，请参见第 4 节和第 5 节。")]),t._v(" "),n("p",[t._v("0x000a：Connect 0x000b：ConnectionBind 0x000c：ConnectionAttempt")]),t._v(" "),n("h3",{attrs:{id:"新的-stun-属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#新的-stun-属性"}},[t._v("#")]),t._v(" 新的 STUN 属性")]),t._v(" "),n("p",[t._v("此 STUN 扩展定义了以下新属性：")]),t._v(" "),n("p",[t._v("0x002a：CONNECTION-ID")]),t._v(" "),n("h4",{attrs:{id:"connection-id"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#connection-id"}},[t._v("#")]),t._v(" CONNECTION-ID")]),t._v(" "),n("p",[t._v("CONNECTION-ID 属性唯一标识对等方数据连接。它是一个 32 位无符号整数值。")]),t._v(" "),n("h3",{attrs:{id:"新的-stun-错误代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#新的-stun-错误代码"}},[t._v("#")]),t._v(" 新的 STUN 错误代码")]),t._v(" "),n("p",[t._v("446 连接已存在 447 连接超时或失败")]),t._v(" "),n("h2",{attrs:{id:"安全考虑"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安全考虑"}},[t._v("#")]),t._v(" 安全考虑")]),t._v(" "),n("p",[t._v("在服务器和对等方之间建立 TCP 连接之后，在从客户端接收到 ConnectionBind 请求之前，服务器将缓冲从对等方接收到的所有数据。该协议规范允许服务器在缓冲区大小即将超过本地策略定义的限制时断开连接。该策略应确保不会超出内存资源。另请参见[RFC4732]第 2.1.3 节。")]),t._v(" "),n("p",[t._v("所有适用于 STUN [RFC5389]和 TURN [RFC5766]的安全注意事项也适用于本文档。")])])}),[],!1,null,null,null);v.default=_.exports}}]);