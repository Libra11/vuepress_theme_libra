(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{420:function(v,_,e){"use strict";e.r(_);var c=e(12),o=Object(c.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"预备知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#预备知识"}},[v._v("#")]),v._v(" 预备知识")]),v._v(" "),e("h2",{attrs:{id:"nat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nat"}},[v._v("#")]),v._v(" "),e("code",[v._v("NAT")])]),v._v(" "),e("p",[e("code",[v._v("NAT")]),v._v("（"),e("code",[v._v("Network Address Translation")]),v._v("）是一种网络协议，它通常用于在私有网络和公共网络之间进行通信。在私有网络中，每个设备都被分配了一个内部 "),e("code",[v._v("IP")]),v._v(" 地址，而在公共网络中，每个设备都被分配了一个唯一的公共 "),e("code",[v._v("IP")]),v._v(" 地址。当一个设备在私有网络中尝试与公共网络中的设备通信时，"),e("code",[v._v("NAT")]),v._v(" 会将该设备的内部 "),e("code",[v._v("IP")]),v._v(" 地址转换为公共 "),e("code",[v._v("IP")]),v._v(" 地址，以便使其能够在公共网络中进行通信。这种技术被广泛应用于家庭和办公网络中，以及在互联网服务提供商（"),e("code",[v._v("ISP")]),v._v("）网络中。")]),v._v(" "),e("p",[e("code",[v._v("NAT")]),v._v(" 转换的内部 "),e("code",[v._v("IP")]),v._v(" 原理是在 "),e("code",[v._v("NAT")]),v._v(" 设备内部维护一个转换表，记录内部 "),e("code",[v._v("IP")]),v._v(" 和端口号和外部 "),e("code",[v._v("IP")]),v._v(" 和端口号之间的对应关系。当内部主机向外部发送数据时，"),e("code",[v._v("NAT")]),v._v(" 设备会将源 "),e("code",[v._v("IP")]),v._v(" 和端口号替换成映射表中对应的外部 "),e("code",[v._v("IP")]),v._v(" 和端口号，从而达到将内部主机和外部主机通信的目的。当外部主机向内部主机发送数据时，"),e("code",[v._v("NAT")]),v._v(" 设备会根据目标 "),e("code",[v._v("IP")]),v._v(" 和端口号在映射表中查找对应的内部 "),e("code",[v._v("IP")]),v._v(" 和端口号，然后将数据转发给内部主机。")]),v._v(" "),e("p",[e("code",[v._v("NAT")]),v._v(" 设备会维护一个 "),e("code",[v._v("NAT")]),v._v(" 会话表，用于记录内部主机和外部主机之间的会话状态。当内部主机向外部主机发起连接时，"),e("code",[v._v("NAT")]),v._v(" 设备会在 "),e("code",[v._v("NAT")]),v._v(" 会话表中创建一个新的会话，并分配一个唯一的标识符。当外部主机向内部主机发送数据时，"),e("code",[v._v("NAT")]),v._v(" 设备会根据目标 "),e("code",[v._v("IP")]),v._v(" 和端口号匹配会话表中的会话，并将数据转发给对应的内部主机。在会话结束后，"),e("code",[v._v("NAT")]),v._v(" 设备会清除会话表中的记录。")]),v._v(" "),e("p",[v._v("大多数路由器具有 "),e("code",[v._v("NAT")]),v._v(" 功能")]),v._v(" "),e("h1",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 是一种用于解决 "),e("code",[v._v("NAT")]),v._v("（网络地址转换）的协议，它可以让网络终端设备（如计算机、手机等）知道它在 "),e("code",[v._v("NAT")]),v._v(" 后面的公网 "),e("code",[v._v("IP")]),v._v(" 地址和端口号。这个协议还可以帮助网络终端设备保持与公网的连接，防止被 "),e("code",[v._v("NAT")]),v._v(" 的“坏心情”断开。"),e("code",[v._v("STUN")]),v._v(" "),e("code",[v._v("协议是一个可扩展的协议，支持多种传输协议，有两种身份验证方式。STUN")]),v._v(" 还可以用于实现其他网络协议，比如 "),e("code",[v._v("ICE")]),v._v(" 协议和 "),e("code",[v._v("SIP Outbound")]),v._v(" 协议。"),e("code",[v._v("STUN")]),v._v(" 协议通过不同的“用法”来实现不同的功能，每种“用法”都会定义 "),e("code",[v._v("STUN")]),v._v(" 消息的内容和处理方式，可以通过扩展 "),e("code",[v._v("STUN")]),v._v(" 协议来实现新的“用法”。")]),v._v(" "),e("blockquote",[e("p",[e("code",[v._v("NAT")]),v._v(" 的“坏心情”指的是网络地址转换（"),e("code",[v._v("NAT")]),v._v("）技术给网络通信带来的一些问题和限制，它可能导致一些本来可以直接通信的设备在网络通信时无法直接建立连接，从而影响通信的质量和效率。这是因为 "),e("code",[v._v("NAT")]),v._v(" 技术通常会使得私有网络内的设备共享同一个公网 "),e("code",[v._v("IP")]),v._v(" 地址，因此在进行网络通信时，需要对 "),e("code",[v._v("IP")]),v._v(" 地址和端口进行转换，这可能会导致连接中断、延迟增加、数据包丢失等问题。此外，"),e("code",[v._v("NAT")]),v._v(" 技术通常会对一些传输协议（如 "),e("code",[v._v("UDP")]),v._v("）造成一些限制，也会给一些应用带来不便。为了解决 "),e("code",[v._v("NAT")]),v._v(" 带来的问题，出现了一些相关的技术，如 "),e("code",[v._v("STUN")]),v._v("、"),e("code",[v._v("TURN")]),v._v("、"),e("code",[v._v("ICE")]),v._v(" 等。")])]),v._v(" "),e("h1",{attrs:{id:"从-rfc3489-的演变"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从-rfc3489-的演变"}},[v._v("#")]),v._v(" 从 "),e("code",[v._v("rfc3489")]),v._v(" 的演变")]),v._v(" "),e("p",[e("code",[v._v("RFC 3489")]),v._v(" 是一份关于 "),e("code",[v._v("NAT")]),v._v(" 穿透的规范，其中定义了"),e("code",[v._v("classic STUN")]),v._v("，即一种解决 "),e("code",[v._v("NAT")]),v._v(" 穿透问题的方法。但是，实践证明，这种方法并不完全可靠。因为它不能保证获得的公网 "),e("code",[v._v("IP")]),v._v(" 地址和端口一定可用于通信，而且它的 "),e("code",[v._v("NAT")]),v._v(" 类型分类算法也有缺陷。此外，它还存在安全漏洞，攻击者可以提供错误的映射地址。因此，"),e("code",[v._v("RFC 5389")]),v._v(" 取代了 "),e("code",[v._v("RFC 3489")]),v._v("，重新定义了 "),e("code",[v._v("STUN")]),v._v("，将其作为完整 "),e("code",[v._v("NAT")]),v._v(" 穿透方案的一部分工具来使用。例如，"),e("code",[v._v("ICE")]),v._v(" 是一个基于 "),e("code",[v._v("Offer/Answer")]),v._v(" 方法论的完整的 "),e("code",[v._v("NAT")]),v._v(" 穿透方案，而 "),e("code",[v._v("SIP Outbound")]),v._v(" 是一个用于 "),e("code",[v._v("SIP")]),v._v(" 信令穿透的完整方案，这些方案都使用 "),e("code",[v._v("STUN")]),v._v("。尽管有可能单独使用 "),e("code",[v._v("STUN")]),v._v(" 来实现 "),e("code",[v._v("NAT")]),v._v(" 穿透，但这种做法并不推荐，因为它有安全漏洞，并且不够可靠。"),e("code",[v._v("RFC 5389")]),v._v(" 对 "),e("code",[v._v("classic STUN")]),v._v(" 协议进行了一些修改和扩展，如增加了 "),e("code",[v._v("TCP")]),v._v(" 协议的支持、改进了映射地址编码格式等。此外，"),e("code",[v._v("RFC 5389")]),v._v(" 将 "),e("code",[v._v("STUN")]),v._v(" 的含义从"),e("code",[v._v("Simple Traversal of UDP through NAT")]),v._v("更名为"),e("code",[v._v("Session Traversal Utilities for NAT")]),v._v("。")]),v._v(" "),e("h1",{attrs:{id:"操作概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作概述"}},[v._v("#")]),v._v(" 操作概述")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 协议是一种用于处理 "),e("code",[v._v("NAT")]),v._v(" 的工具，它提供了一种方式让终端设备确定其私有 "),e("code",[v._v("IP")]),v._v(" 地址和端口号在 "),e("code",[v._v("NAT")]),v._v(" 映射下所对应的公共 "),e("code",[v._v("IP")]),v._v(" 地址和端口号，"),e("strong",[v._v("并且保持 "),e("code",[v._v("NAT")]),v._v(" 绑定状态的存活性。")]),v._v(" 它通过客户端和服务器之间的请求/响应或指示交互来实现这些功能，客户端和服务器都需要实现 "),e("code",[v._v("STUN")]),v._v(" 协议。当客户端发送绑定请求给服务器时，这个请求可能要通过多个 "),e("code",[v._v("NAT")]),v._v(" 转发，每次转发都会改变源地址。在此过程中，服务器将原始的源地址存储在一个特殊的 "),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 属性中，并将这个属性值通过响应返回给客户端。这个属性值包含了客户端的公共 "),e("code",[v._v("IP")]),v._v(" 地址和端口号，客户端可以从中获得其相对于服务器的反射传输地址。除了绑定方法，"),e("code",[v._v("STUN")]),v._v(" 协议还提供了多种机制来进行 "),e("code",[v._v("DNS")]),v._v(" 发现、重定向、指纹验证、认证和消息完整性交换等操作，以便实现完整的 "),e("code",[v._v("NAT")]),v._v(" 遍历解决方案。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("\n                               /-----\\\n                             // STUN  \\\\\n                            |   Server  |\n                             \\\\       //\n                               \\-----/\n\n\n\n\n                          +--------------+             Public Internet\n          ................|     NAT 2    |.......................\n                          +--------------+\n\n\n\n                          +--------------+             Private NET 2\n          ................|     NAT 1    |.......................\n                          +--------------+\n\n\n\n\n                              /-----\\\n                            //  STUN \\\\\n                           |    Client |\n                            \\\\       //               Private NET 1\n                              \\-----/\n\n")])])]),e("p",[v._v("上图中，有两个实体（称为 "),e("code",[v._v("STUN")]),v._v(" 代理），它们实现了 "),e("code",[v._v("STUN")]),v._v(" 协议。图中较低的代理是客户端，连接到私有网络 1。此网络通过 "),e("code",[v._v("NAT 1")]),v._v(" 连接到私有网络 2。私有网络 2 通过 "),e("code",[v._v("NAT 2")]),v._v(" 连接到公共互联网。图中较高的代理是服务器，位于公共互联网上。")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 是一种"),e("code",[v._v("client-server")]),v._v("协议。它支持两种类型的事务("),e("code",[v._v("transactions")]),v._v(")。一种是请求/响应("),e("code",[v._v("request/response")]),v._v(")事务，在其中客户端向服务器发送请求，服务器返回响应。第二种是提示("),e("code",[v._v("indication")]),v._v(")事务，在其中任一代理（客户端或服务器）发送提示，这不会产生响应。这两种类型的事务都包括一个事务 "),e("code",[v._v("ID")]),v._v("，这是一个随机选择的 96 位数字。对于请求/响应事务，此事务 "),e("code",[v._v("ID")]),v._v(" 允许客户端将响应与生成它的请求关联起来；对于提示，事务 "),e("code",[v._v("ID")]),v._v(" 用作调试工具。")]),v._v(" "),e("p",[v._v("所有 "),e("code",[v._v("STUN")]),v._v(" 消息都以固定的头开始，其中包括方法("),e("code",[v._v("method")]),v._v(")、类("),e("code",[v._v("class")]),v._v(")和事务 "),e("code",[v._v("ID")]),v._v("。")]),v._v(" "),e("ul",[e("li",[v._v("方法表明了这是各种事务中的哪一个；本规范仅定义了一种方法，即绑定("),e("code",[v._v("Binding")]),v._v(")，但计划在其他文档中定义一些其他的方法。")]),v._v(" "),e("li",[v._v("类表明了这是请求、成功响应、错误响应还是提示。")]),v._v(" "),e("li",[v._v("在固定头之后是零个或多个属性，这些属性是 "),e("code",[v._v("Type-Length-Value")]),v._v(" 扩展，用于传递特定消息的其他信息。")])]),v._v(" "),e("p",[v._v("本文档定义了一种名为绑定的方法。绑定方法可以在请求/响应事务或提示事务中使用。")]),v._v(" "),e("ul",[e("li",[v._v("在请求/响应事务中使用时，绑定方法可以用于确定 "),e("code",[v._v("NAT")]),v._v(" 为 "),e("code",[v._v("STUN")]),v._v(" 客户端分配的特定, 也就是 "),e("code",[v._v("NAT")]),v._v(" 映射了哪个 "),e("code",[v._v("IP")]),v._v(" 地址和端口号。")]),v._v(" "),e("li",[v._v("在请求/响应或提示事务中使用时，绑定方法还可以用于保持这些绑定处于活动状态, 以确保这些映射不会过期。")])]),v._v(" "),e("p",[v._v("当 "),e("code",[v._v("Stun")]),v._v(" 客户端想要知道其公网 "),e("code",[v._v("IP")]),v._v(" 地址和端口号时，它会向 "),e("code",[v._v("Stun")]),v._v(" 服务器发送一个绑定请求，"),e("code",[v._v("Stun")]),v._v(" 服务器会将反射性传输地址("),e("code",[v._v("reflexive transport address")]),v._v(")（即该请求经过 "),e("code",[v._v("NAT")]),v._v(" 后对应的公网 "),e("code",[v._v("IP")]),v._v(" 地址和端口号）作为响应的 "),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 属性返回给 "),e("code",[v._v("Stun")]),v._v(" 客户端。")]),v._v(" "),e("p",[v._v("在绑定请求/响应事务中，"),e("code",[v._v("STUN")]),v._v(" 客户端向 "),e("code",[v._v("STUN")]),v._v(" 服务器发送绑定请求。当绑定请求到达 "),e("code",[v._v("STUN")]),v._v(" 服务器时，它可能已经通过 "),e("code",[v._v("STUN")]),v._v(" 客户端和 "),e("code",[v._v("STUN")]),v._v(" 服务器之间的一个或多个 "),e("code",[v._v("NAT")]),v._v("（在图 1 中有两个这样的 "),e("code",[v._v("NAT")]),v._v("）传递。当绑定请求消息通过 "),e("code",[v._v("NAT")]),v._v(" 时，"),e("code",[v._v("NAT")]),v._v(" 将修改数据包的源传输地址（即源 "),e("code",[v._v("IP")]),v._v(" 地址和源端口）。因此，服务器接收到的请求的源传输地址将是最靠近服务器的 "),e("code",[v._v("NAT")]),v._v(" 创建的公共 "),e("code",[v._v("IP")]),v._v(" 地址和端口。这称为反射性传输地址。"),e("code",[v._v("STUN")]),v._v(" 服务器将该源传输地址复制到 "),e("code",[v._v("STUN")]),v._v(" 绑定响应中的 "),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 属性中，并将绑定响应发送回 "),e("code",[v._v("STUN")]),v._v(" 客户端。当此数据包经过 "),e("code",[v._v("NAT")]),v._v(" 返回时，"),e("code",[v._v("NAT")]),v._v(" 将修改 "),e("code",[v._v("IP")]),v._v(" 头中的目标传输地址("),e("code",[v._v("NAT")]),v._v(" 需要将数据包的目标传输地址修改为 "),e("code",[v._v("STUN")]),v._v(" 客户端的私有 "),e("code",[v._v("IP")]),v._v(" 地址和端口号，以确保 "),e("code",[v._v("STUN")]),v._v(" 客户端能够正确接收到响应消息。)，但 "),e("code",[v._v("STUN")]),v._v(" 响应主体中的 "),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 属性中的传输地址将保持不变。通过这种方式，客户端可以了解其相对于 "),e("code",[v._v("STUN")]),v._v(" 服务器最外层 "),e("code",[v._v("NAT")]),v._v(" 分配的反射性传输地址。")]),v._v(" "),e("p",[v._v("在某些用法中，必须将 "),e("code",[v._v("STUN")]),v._v(" 与其他协议（例如["),e("code",[v._v("MMUSIC-ICE")]),v._v("]，["),e("code",[v._v("SIP-OUTBOUND")]),v._v("]）进行多路复用。在这些用法中，必须有一种方法来检查数据包并确定它是否为 "),e("code",[v._v("STUN")]),v._v(" 数据包。"),e("code",[v._v("STUN")]),v._v(" 在 "),e("code",[v._v("STUN")]),v._v(" 头中定义了三个带有固定值的字段，可用于此目的。如果这不足够，则 "),e("code",[v._v("STUN")]),v._v(" 数据包还可以包含指纹值，这可以进一步用于区分数据包。")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 定义了一组可选的机制("),e("code",[v._v("mechanisms")]),v._v(")，这些机制是可选的,包括 "),e("code",[v._v("DNS")]),v._v(" 发现、重定向到备用服务器的技术、用于多路复用的指纹属性以及两个身份验证和消息完整性交换。"),e("strong",[v._v("身份验证机制围绕使用用户名、密码和消息完整性值展开。")]),v._v(" 本规范定义了两种身份验证机制，即"),e("strong",[v._v("长期凭证机制和短期凭证机制。")]),v._v(" 每个用法都指定允许使用的机制。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("DNS 发现（DNS Discovery）是一个过程，通过查询 Domain Name System（DNS）来查找和获取网络服务或设备的相关信息。DNS 本身是互联网的一项基本服务，将人类可读的域名（如 example.com）转换为与之对应的 IP 地址（如 192.0.2.1），从而使计算机和其他设备能够找到并访问这些服务或资源。\n\nDNS 发现的一些常见应用包括：\n\n- 服务发现：通过 DNS 查询，客户端可以发现提供特定服务的服务器。例如，客户端可能需要找到提供电子邮件服务的服务器，或者寻找负责处理特定 API 请求的服务器。\n\n- 负载均衡：DNS 发现可以用于实现负载均衡，通过将不同的 IP 地址分配给相同的域名，从而使流量在多个服务器之间分散。当客户端查询该域名时，DNS 服务器可以根据负载均衡策略返回不同的 IP 地址。\n\n- 故障切换：当一个服务的主服务器出现故障时，DNS 发现可以将流量重新路由到备用服务器。这可以通过修改 DNS 记录实现，将域名映射到其他可用的 IP 地址。\n\n- 地理定位：DNS 发现还可以用于根据客户端的地理位置返回最佳的服务器地址。例如，如果一个全球性的网站在不同地区有多个数据中心，DNS 服务器可以根据客户端的位置返回最近的数据中心的 IP 地址，从而减少延迟并提高性能。\n")])])]),e("p",[v._v("在长期凭证机制中，客户端和服务器共享预配置的用户名和密码，并执行受 "),e("code",[v._v("HTTP")]),v._v(" [RFC2617]定义的摘要挑战/响应交换("),e("code",[v._v("digest challenge/ response exchange")]),v._v(")（在细节上有所不同）。在短期凭证机制中，客户端和服务器通过某种方法交换用户名和密码，然后执行 "),e("code",[v._v("STUN")]),v._v(" 交换(当客户端想要知道其公网 "),e("code",[v._v("IP")]),v._v(" 地址和端口号时，它会向 "),e("code",[v._v("STUN")]),v._v(" 服务器发送绑定请求，这是一种使用请求/响应事务的 "),e("code",[v._v("STUN")]),v._v(" 交换。)。例如，在 "),e("code",[v._v("ICE")]),v._v(" 用法["),e("code",[v._v("MMUSIC-ICE")]),v._v("]中，两个端点使用信令交换用户名和密码。这些用于完整性保护和身份验证请求和响应。不需要使用 "),e("code",[v._v("nonce")]),v._v("(一种随机数，用于防止重放攻击，但在短期凭证机制中不使用它)。")]),v._v(" "),e("blockquote",[e("p",[v._v("重放攻击是指攻击者窃取并重复使用已经传输的数据包，以模拟合法用户的身份来执行欺骗性操作。在 "),e("code",[v._v("STUN")]),v._v(" 协议中，重放攻击可能会导致身份验证失效，因此使用长期凭证机制时需要使用 "),e("code",[v._v("nonce")]),v._v(" 来防止重放攻击。"),e("code",[v._v("nonce")]),v._v(" 是服务器生成的随机数，客户端和服务器通过摘要挑战/响应交换使用 "),e("code",[v._v("nonce")]),v._v(" 来保护请求和响应的完整性和身份验证。")])]),v._v(" "),e("h1",{attrs:{id:"定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[v._v("#")]),v._v(" 定义")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 代理("),e("code",[v._v("STUN Agent")]),v._v(")：实现 "),e("code",[v._v("STUN")]),v._v(" 协议的实体。该实体可以是 "),e("code",[v._v("STUN")]),v._v(" 客户端或 "),e("code",[v._v("STUN")]),v._v(" 服务器。")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 客户端("),e("code",[v._v("STUN Client")]),v._v(")：发送 "),e("code",[v._v("STUN")]),v._v(" 请求并接收 "),e("code",[v._v("STUN")]),v._v(" 响应的实体。"),e("code",[v._v("STUN")]),v._v(" 客户端也可以发送指示。在本规范中，"),e("code",[v._v("STUN")]),v._v(" 客户端和客户端是同义词。")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 服务器("),e("code",[v._v("STUN Server")]),v._v(")：接收 "),e("code",[v._v("STUN")]),v._v(" 请求并发送 "),e("code",[v._v("STUN")]),v._v(" 响应的实体。"),e("code",[v._v("STUN")]),v._v(" 服务器也可以发送指示。在本规范中，"),e("code",[v._v("STUN")]),v._v(" 服务器和服务器是同义词。")]),v._v(" "),e("p",[v._v("传输地址("),e("code",[v._v("Transport Address")]),v._v(")："),e("code",[v._v("IP")]),v._v(" 地址和端口号的组合（例如 "),e("code",[v._v("UDP")]),v._v(" 或 "),e("code",[v._v("TCP")]),v._v(" 端口号）。")]),v._v(" "),e("p",[v._v("反射性传输地址("),e("code",[v._v("Reflexive Transport Address")]),v._v(")：客户端学习到的传输地址，用于标识该客户端在 "),e("code",[v._v("IP")]),v._v(" 网络上被另一个主机（通常是 "),e("code",[v._v("STUN")]),v._v(" 服务器）看到的方式。当客户端和其他主机之间有一个中间的 "),e("code",[v._v("NAT")]),v._v(" 时，反射性传输地址表示分配给客户端的映射地址，该映射地址位于 "),e("code",[v._v("NAT")]),v._v(" 的公共侧。反射性传输地址是从 "),e("code",[v._v("STUN")]),v._v(" 响应中的映射地址属性（"),e("code",[v._v("MAPPED-ADDRESS")]),v._v(" 或 "),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v("）中学习到的。")]),v._v(" "),e("p",[v._v("映射地址("),e("code",[v._v("Mapped Address")]),v._v(")：与反射地址的含义相同。仅出于历史原因和 "),e("code",[v._v("MAPPED-ADDRESS")]),v._v(" 和 "),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 属性的命名原因，保留了此术语。")]),v._v(" "),e("p",[v._v("长期凭证("),e("code",[v._v("Long-Term Credential")]),v._v(")：代表客户端和服务器之间的共享秘密的用户名和关联密码。当用户订阅某项服务时，通常会向客户端授予长期凭证，直至用户取消订阅该服务或明确更改凭证为止。")]),v._v(" "),e("p",[v._v("长期密码("),e("code",[v._v("Long-Term Password")]),v._v(")：长期凭证的密码。")]),v._v(" "),e("p",[v._v("短期凭证("),e("code",[v._v("Short-Term Credential")]),v._v(")：表示客户端和服务器之间共享的临时用户名和相关密码的共享密码。短期凭证是通过客户端和服务器之间的某种协议机制获得的，在 "),e("code",[v._v("STUN")]),v._v(" 交换之前。短期凭证具有显式的时间范围，可以基于特定的时间量（例如 5 分钟）或事件（例如 "),e("code",[v._v("SIP")]),v._v(" 对话的终止）等。短期凭证的具体范围由应用程序使用定义。")]),v._v(" "),e("p",[v._v("短期密码("),e("code",[v._v("Short-Term Password")]),v._v(")：短期凭证的密码组件。")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 指示("),e("code",[v._v("STUN Indication")]),v._v(")：不接收响应的 "),e("code",[v._v("STUN")]),v._v(" 消息。")]),v._v(" "),e("p",[v._v("属性("),e("code",[v._v("Attribute")]),v._v(")：可以添加到 "),e("code",[v._v("STUN")]),v._v(" 消息中的类型-长度-值（"),e("code",[v._v("TLV")]),v._v("）对象的 "),e("code",[v._v("STUN")]),v._v(" 术语。属性分为两种类型：理解所需和理解可选("),e("code",[v._v("comprehension-required and comprehension-optional")]),v._v(")。"),e("code",[v._v("STUN")]),v._v(" 代理可以安全地忽略它们不理解的可选属性，但如果消息包含未被理解的所需属性，则无法成功处理该消息。")]),v._v(" "),e("p",[e("code",[v._v("RTO")]),v._v("：重传超时，定义请求传输和第一次重传之间的初始时间段。")]),v._v(" "),e("h1",{attrs:{id:"stun-消息结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stun-消息结构"}},[v._v("#")]),v._v(" "),e("code",[v._v("stun")]),v._v(" 消息结构")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 消息使用面向网络的格式进行二进制编码（最高有效字节或八位字节优先，也常称为大端）。消息的传输顺序在 "),e("code",[v._v("RFC")]),v._v(" 791 ["),e("code",[v._v("RFC0791")]),v._v("]的附录 "),e("code",[v._v("B")]),v._v(" 中详细描述。除非另有说明，数字常量均为十进制（基数 10）。")]),v._v(" "),e("blockquote",[e("p",[v._v("大端（"),e("code",[v._v("Big-endian")]),v._v("）是一种数据的排序方式，其中数值的高位保存在内存低地址中，而数值的低位保存在内存高地址中。这种排序方式是网络字节序的标准排序方式，也被称为网络字节序的高位优先（"),e("code",[v._v("Most Significant Byte First，MSB First")]),v._v("）。与之相对的是小端（"),e("code",[v._v("Little-endian")]),v._v("）排序方式，其中数值的低位保存在内存低地址中，而数值的高位保存在内存高地址中。")])]),v._v(" "),e("p",[v._v("所有 "),e("code",[v._v("STUN")]),v._v(" 消息必须以 20 字节的头部开始，然后是零个或多个属性。"),e("code",[v._v("STUN")]),v._v(" 头包含 "),e("code",[v._v("STUN")]),v._v(" 消息类型、"),e("code",[v._v("Magic Cookie")]),v._v("、事务 "),e("code",[v._v("ID")]),v._v(" 和消息长度。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |0 0|     STUN Message Type     |         Message Length        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                         Magic Cookie                          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                                                               |\n      |                     Transaction ID (96 bits)                  |\n      |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n")])])]),e("p",[v._v("每个 "),e("code",[v._v("STUN")]),v._v(" 消息的最高有效 2 位必须为零。当 "),e("code",[v._v("STUN")]),v._v(" 与其他协议在同一个端口上复用时，可以使用此特性来区分 "),e("code",[v._v("STUN")]),v._v(" 数据包和其他协议的数据包。消息类型定义了 "),e("code",[v._v("STUN")]),v._v(" 消息的消息类（请求、成功响应、失败响应或指示）和 消息方法。虽然有四个消息类，但是 "),e("code",[v._v("STUN")]),v._v(" 中只有两种类型的事务：请求/响应事务（包括请求消息和响应消息）和指示事务（包括单个指示消息）。为了快速处理 "),e("code",[v._v("STUN")]),v._v(" 消息，响应类被分为错误响应和成功响应。消息类型字段进一步分解为以下结构：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("                        0                 1\n                        2  3  4 5 6 7 8 9 0 1 2 3 4 5\n\n                       +--+--+-+-+-+-+-+-+-+-+-+-+-+-+\n                       |M |M |M|M|M|C|M|M|M|C|M|M|M|M|\n                       |11|10|9|8|7|1|6|5|4|0|3|2|1|0|\n                       +--+--+-+-+-+-+-+-+-+-+-+-+-+-+\n                  0  0  0  0  0 0 0 1 0 0 0 0 0 0 0 1 = 0x0101(成功响应)\n                  0  0  0  0  0 0 0 0 0 0 0 0 0 0 0 1 = 0x0001(请求)\n                  0  0  0  0  0 0 0 0 0 0 0 1 0 0 0 1 = 0x0011(指示)\n                  0  0  0  0  0 0 0 1 0 0 0 1 0 0 0 1 = 0x0111(错误响应)\n")])])]),e("p",[v._v("这里显示了消息类型字段中的位，从最高有效位（"),e("code",[v._v("M11")]),v._v("）到最低有效位（"),e("code",[v._v("M0")]),v._v("）。"),e("code",[v._v("M11")]),v._v(" 到 "),e("code",[v._v("M0")]),v._v(" 表示方法的 12 位编码。C1 和 C0 表示类的 2 位编码。类为 "),e("code",[v._v("0b00")]),v._v(" 表示请求，类为 "),e("code",[v._v("0b01")]),v._v(" 表示指示，类为 "),e("code",[v._v("0b10")]),v._v(" 表示成功响应，类为 "),e("code",[v._v("0b11")]),v._v(" 表示错误响应。本规范定义了一个单一的方法 "),e("code",[v._v("Binding")]),v._v("。方法和类是正交的，因此对于每个方法，该方法的请求、成功响应、错误响应和指示都是可能的。定义新方法的扩展必须指出该方法允许哪些类。例如，"),e("code",[v._v("Binding")]),v._v(" 请求的类="),e("code",[v._v("0b00")]),v._v("（请求）和方法="),e("code",[v._v("0b000000000001")]),v._v("（Binding），编码为前 16 位为 "),e("code",[v._v("0x0001")]),v._v("。"),e("code",[v._v("Binding")]),v._v(" 响应的类="),e("code",[v._v("0b10")]),v._v("（成功响应）和方法="),e("code",[v._v("0b000000000001")]),v._v("，编码为前 16 位为 "),e("code",[v._v("0x0101")]),v._v("。注意：这种不幸的编码是由于["),e("code",[v._v("RFC3489")]),v._v("]中赋值没有考虑使用位字段对指示、成功和错误进行编码。")]),v._v(" "),e("blockquote",[e("p",[v._v("一共 16 位：最高有效位： 2 位，类： 2 位，方法： 12 位，2 + 2 + 12 = 16 位， 类别和方法的值在编码时被合并到一个 16 位的值中。")])]),v._v(" "),e("blockquote",[e("p",[v._v("消息头部一共 20 字节：消息类型 2 字节 + 消息长度 2 字节 + "),e("code",[v._v("Magic Cookie")]),v._v(" 4 字节 + 事务 "),e("code",[v._v("ID")]),v._v(" 12 字节 = 20 字节。")])]),v._v(" "),e("p",[e("code",[v._v("Magic Cookie")]),v._v(" 字段必须包含网络字节序中的固定值 "),e("code",[v._v("0x2112A442")]),v._v("。在 ["),e("code",[v._v("RFC3489")]),v._v("]中，此字段是事务 "),e("code",[v._v("ID")]),v._v(" 的一部分；将 "),e("code",[v._v("Magic Cookie")]),v._v(" 放置在此位置允许服务器检测客户端是否理解在此修订规范中添加的某些属性。此外，当 "),e("code",[v._v("STUN")]),v._v(" 与其他协议在同一端口上复用时，它有助于区分 "),e("code",[v._v("STUN")]),v._v(" 数据包和其他协议的数据包。事务 "),e("code",[v._v("ID")]),v._v(" 是一个 96 位的标识符，用于唯一标识 "),e("code",[v._v("STUN")]),v._v(" 事务。对于请求/响应事务，事务 "),e("code",[v._v("ID")]),v._v(" 由 "),e("code",[v._v("STUN")]),v._v(" 客户端为请求选择，服务器在响应中回显。对于指示，它是由发送指示的代理选择的。它主要用于将请求与响应相关联，但它还在帮助防止某些类型的攻击方面发挥了一定作用。服务器还将事务 "),e("code",[v._v("ID")]),v._v(" 用作在所有客户端之间唯一标识每个事务的关键。因此，事务 "),e("code",[v._v("ID")]),v._v(" 必须从区间 0~2^{96-1} 中均匀随机选择，并且应该是加密随机的。相同请求的重新发送重用相同的事务 "),e("code",[v._v("ID")]),v._v("，但是除非新的请求与先前的请求在位上完全相同并从相同的传输地址发送到相同的 "),e("code",[v._v("IP")]),v._v(" 地址，否则客户端必须为新的事务选择新的事务 "),e("code",[v._v("ID")]),v._v("。"),e("strong",[v._v("成功和错误响应必须携带与其对应的请求相同的事务 "),e("code",[v._v("ID")])]),v._v("。当一个代理在同一个端口上充当 "),e("code",[v._v("STUN")]),v._v(" 服务器和 "),e("code",[v._v("STUN")]),v._v(" 客户端时，代理发送的请求中的事务 "),e("code",[v._v("ID")]),v._v(" 与代理接收到的请求中的事务 "),e("code",[v._v("ID")]),v._v(" 没有关系。")]),v._v(" "),e("p",[v._v("消息长度必须包含消息的大小（以字节为单位），不包括 20 字节的 "),e("code",[v._v("STUN")]),v._v(" 头。由于所有 "),e("code",[v._v("STUN")]),v._v(" 属性都填充为 4 字节的倍数，因此此字段的最后 2 位始终为零。这提供了另一种区分 "),e("code",[v._v("STUN")]),v._v(" 数据包和其他协议数据包的方法。\n在 "),e("code",[v._v("STUN")]),v._v(" 头的固定部分之后是零个或多个属性。每个属性都是 "),e("code",[v._v("TLV")]),v._v("（类型-长度-值）编码的。编码的细节和属性本身的细节在第 15 节中给出。")]),v._v(" "),e("h1",{attrs:{id:"基本协议流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本协议流程"}},[v._v("#")]),v._v(" 基本协议流程")]),v._v(" "),e("p",[v._v("本节定义了 "),e("code",[v._v("STUN")]),v._v(" 协议的基本流程。它描述了如何构建消息，如何发送消息，以及在接收到消息时如何处理。同时，它还详细定义了 "),e("code",[v._v("Binding")]),v._v(" 方法的处理。本文档的其他部分描述了在某些情况下，某个用法可能选择使用的可选流程。其他文档可能通过添加新方法、新属性或新错误响应代码来定义 "),e("code",[v._v("STUN")]),v._v(" 的其他扩展。")]),v._v(" "),e("h2",{attrs:{id:"构建请求或指示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构建请求或指示"}},[v._v("#")]),v._v(" 构建请求或指示")]),v._v(" "),e("p",[v._v("当构建请求或指示消息时，代理必须遵循第 6 节中创建头部的规则。此外，消息类别必须为 "),e("code",[v._v("Request")]),v._v("（请求）或 "),e("code",[v._v("Indication")]),v._v("（指示），方法必须为 "),e("code",[v._v("Binding")]),v._v(" 或其他文档中定义的某种方法。")]),v._v(" "),e("p",[v._v("代理接着添加由方法或用法指定的任何属性。例如，某些用法可能要求代理使用身份验证方法（第 10 节）或 "),e("code",[v._v("FINGERPRINT")]),v._v(" 属性（第 8 节）。")]),v._v(" "),e("p",[v._v("如果代理正在发送请求，它应在请求中添加一个 "),e("code",[v._v("SOFTWARE")]),v._v(" 属性。代理可以根据方法在指示中包含 "),e("code",[v._v("SOFTWARE")]),v._v(" 属性。"),e("code",[v._v("STUN")]),v._v(" 的扩展应讨论在新指示中 "),e("code",[v._v("SOFTWARE")]),v._v(" 是否有用。")]),v._v(" "),e("p",[v._v("对于没有身份验证的 "),e("code",[v._v("Binding")]),v._v(" 方法，除非用法另有规定，否则不需要任何属性。")]),v._v(" "),e("p",[v._v("所有通过 "),e("code",[v._v("UDP")]),v._v(" 发送的 "),e("code",[v._v("STUN")]),v._v(" 消息的大小应该小于路径 "),e("code",[v._v("MTU")]),v._v("（如果已知）。如果路径 "),e("code",[v._v("MTU")]),v._v(" 未知，"),e("code",[v._v("IPv4")]),v._v(" 的消息应小于 576 字节和第一跳 "),e("code",[v._v("MTU")]),v._v(" ["),e("code",[v._v("RFC1122")]),v._v("]，"),e("code",[v._v("IPv6")]),v._v(" 的消息应小于 1280 字节 ["),e("code",[v._v("RFC2460")]),v._v("]。这个值对应于 "),e("code",[v._v("IP")]),v._v(" 数据包的总大小。因此，对于 "),e("code",[v._v("IPv4")]),v._v("，实际的 "),e("code",[v._v("STUN")]),v._v(" 消息需要小于 548 字节（576 减去 20 字节 "),e("code",[v._v("IP")]),v._v(" 头部，减去 8 字节 "),e("code",[v._v("UDP")]),v._v(" 头部，假设没有使用 "),e("code",[v._v("IP")]),v._v(" 选项）。"),e("code",[v._v("STUN")]),v._v(" 无法处理请求小于 "),e("code",[v._v("MTU")]),v._v(" 但响应大于 "),e("code",[v._v("MTU")]),v._v(" 的情况。预计这种限制不会对 "),e("code",[v._v("STUN")]),v._v(" 造成问题。"),e("code",[v._v("MTU")]),v._v(" 限制是一个建议（"),e("code",[v._v("SHOULD")]),v._v("），而不是一个必须（"),e("code",[v._v("MUST")]),v._v("），以解决 "),e("code",[v._v("STUN")]),v._v(" 本身被用于探测 "),e("code",[v._v("MTU")]),v._v(" 特性 ["),e("code",[v._v("BEHAVE-NAT")]),v._v("] 的情况。在此类应用以外，必须遵循 "),e("code",[v._v("MTU")]),v._v(" 约束。")]),v._v(" "),e("blockquote",[e("p",[e("code",[v._v("MTU")]),v._v("（"),e("code",[v._v("Maximum Transmission Unit")]),v._v("，最大传输单元）是指网络中单个数据包的最大尺寸，包括数据和协议头部信息。不同类型的网络和通信链路具有不同的 "),e("code",[v._v("MTU")]),v._v(" 大小。"),e("code",[v._v("MTU")]),v._v(" 是网络层（如 "),e("code",[v._v("IP")]),v._v(" 层）的概念，它限制了网络层所能处理的最大数据包的大小。在 "),e("code",[v._v("IP")]),v._v(" 层，如果一个数据包的大小超过了 "),e("code",[v._v("MTU")]),v._v("，那么该数据包将被分片（"),e("code",[v._v("fragmentation")]),v._v("）或丢弃。")])]),v._v(" "),e("blockquote",[e("p",[v._v("在 "),e("code",[v._v("TCP/IP")]),v._v(" 协议栈中，"),e("code",[v._v("IPv4")]),v._v(" 和 "),e("code",[v._v("IPv6")]),v._v(" 的默认 "),e("code",[v._v("MTU")]),v._v(" 大小分别为 576 字节和 1280 字节。当然，在实际应用中，链路层的 "),e("code",[v._v("MTU")]),v._v("（如以太网的 "),e("code",[v._v("MTU")]),v._v("）通常会更大。以太网的标准 "),e("code",[v._v("MTU")]),v._v(" 为 1500 字节。")])]),v._v(" "),e("h2",{attrs:{id:"发送请求或指示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#发送请求或指示"}},[v._v("#")]),v._v(" 发送请求或指示")]),v._v(" "),e("p",[v._v("代理接下来发送请求或指示。本文档规定了如何通过 "),e("code",[v._v("UDP")]),v._v("、"),e("code",[v._v("TCP")]),v._v(" 或 "),e("code",[v._v("TLS-over-TCP")]),v._v(" 发送 "),e("code",[v._v("STUN")]),v._v(" 消息；将来可能会添加其他传输协议。"),e("code",[v._v("STUN")]),v._v(" 使用必须指定使用哪种传输协议，以及代理如何确定接收者的 "),e("code",[v._v("IP")]),v._v(" 地址和端口。第 9 节描述了一种基于 "),e("code",[v._v("DNS")]),v._v(" 的确定服务器 "),e("code",[v._v("IP")]),v._v(" 地址和端口的方法，使用者可以选择使用。"),e("code",[v._v("STUN")]),v._v(" 可以与任播地址（"),e("code",[v._v("anycast addresses")]),v._v("）一起使用，但仅限于使用 "),e("code",[v._v("UDP")]),v._v(" 的情况，且在不使用认证的使用场景中。\n在任何时候，客户端可以与同一个 "),e("code",[v._v("STUN")]),v._v(" 服务器有多个未完成的 "),e("code",[v._v("STUN")]),v._v(" 请求（即有不同事务 "),e("code",[v._v("ID")]),v._v(" 的多个进行中事务）。如果没有其他限制新事务的速率（如 "),e("code",[v._v("ICE")]),v._v(" 用于连接检查或 "),e("code",[v._v("STUN")]),v._v(" 运行在 "),e("code",[v._v("TCP")]),v._v(" 上时所指定的限制），客户端应该将新事务之间的间隔设置为 "),e("code",[v._v("RTO")]),v._v("，并且应该将同一个服务器的未完成事务限制在十个以内。")]),v._v(" "),e("h3",{attrs:{id:"通过-udp-发送"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通过-udp-发送"}},[v._v("#")]),v._v(" 通过 "),e("code",[v._v("UDP")]),v._v(" 发送")]),v._v(" "),e("p",[v._v("在通过 "),e("code",[v._v("UDP")]),v._v(" 运行 "),e("code",[v._v("STUN")]),v._v(" 时，网络可能会丢弃 "),e("code",[v._v("STUN")]),v._v(" 消息。通过客户端应用程序自身重新传输请求消息来实现 "),e("code",[v._v("STUN")]),v._v(" 请求/响应事务的可靠性。"),e("strong",[e("code",[v._v("STUN")]),v._v(" 指示不会被重传；因此，通过 "),e("code",[v._v("UDP")]),v._v(" 的指示事务不是可靠的。")])]),v._v(" "),e("p",[v._v("客户端应该以 "),e("code",[v._v("RTO")]),v._v("（“重传超时”）间隔开始重传 "),e("code",[v._v("STUN")]),v._v(" 请求消息，并在每次重传后加倍。"),e("code",[v._v("RTO")]),v._v(" 是往返时间（"),e("code",[v._v("RTT")]),v._v("）的估计，并按照["),e("code",[v._v("RFC2988")]),v._v("] 中描述的方式计算，但有两个例外。首先，"),e("code",[v._v("RTO")]),v._v(" 的初始值应该是可配置的（而不是 "),e("code",[v._v("RFC 2988")]),v._v(" 推荐的 3 秒），并且应该大于 500 毫秒。对于这个“应该”的例外情况是，当使用其他机制来推导拥塞阈值（如 "),e("code",[v._v("ICE")]),v._v(" 为固定速率流定义的阈值），或者当 "),e("code",[v._v("STUN")]),v._v(" 用于具有已知网络容量的非互联网环境时。在固定线路接入链路中，建议使用 500 毫秒的值。其次，"),e("code",[v._v("RTO")]),v._v(" 的值不应四舍五入到最接近的秒。相反，应该保持 1 毫秒的精度。与 "),e("code",[v._v("TCP")]),v._v(" 一样，建议使用 "),e("code",[v._v("Karn")]),v._v(" 算法 ["),e("code",[v._v("KARN87")]),v._v("]。将其应用于 "),e("code",[v._v("STUN")]),v._v(" 时，意味着不应从导致请求重传的 "),e("code",[v._v("STUN")]),v._v(" 事务中计算 "),e("code",[v._v("RTT")]),v._v(" 估计。")]),v._v(" "),e("p",[v._v("在事务完成后，客户端应该缓存 "),e("code",[v._v("RTO")]),v._v(" 的值，并将其用作下一次事务到同一服务器的 "),e("code",[v._v("RTO")]),v._v(" 的初始值（基于 "),e("code",[v._v("IP")]),v._v(" 地址的相等）。这个值在 10 分钟后应被认为是过时的并被丢弃。\n重传将持续进行，直到收到响应，或者直到发送了 "),e("code",[v._v("Rc")]),v._v(" 个请求。"),e("code",[v._v("Rc")]),v._v(" 应该是可配置的，默认值应为 7。如果在发送最后一个请求后，一个等于 "),e("code",[v._v("Rm")]),v._v(" 乘以 "),e("code",[v._v("RTO")]),v._v(" 的持续时间已经过去，但仍未收到响应（如果只有这个最后一个请求实际上成功，那么有足够的时间获得响应），客户端应该认为该事务失败。"),e("code",[v._v("Rm")]),v._v(" 应该是可配置的，默认值应为 16。如果在一个硬 "),e("code",[v._v("ICMP")]),v._v(" 错误 ["),e("code",[v._v("RFC1122")]),v._v("] 的情况下，"),e("code",[v._v("UDP")]),v._v(" 上的 "),e("code",[v._v("STUN")]),v._v(" 事务也被认为是失败的。例如，假设 "),e("code",[v._v("RTO")]),v._v(" 为 500 毫秒，请求将在 0 毫秒、500 毫秒、1500 毫秒、3500 毫秒、7500 毫秒、15500 毫秒和 31500 毫秒时发送。如果客户端在 39500 毫秒后还没有收到响应，客户端将认为事务已超时。")]),v._v(" "),e("blockquote",[e("p",[v._v("rm = 16, rto = 500ms, rc = 7: 31500 ms + rm _ rto = 31500 ms + 16 _ 500 ms = 39500 ms")])]),v._v(" "),e("h3",{attrs:{id:"在-tcp-或-tls-over-tcp-上发送"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在-tcp-或-tls-over-tcp-上发送"}},[v._v("#")]),v._v(" 在 "),e("code",[v._v("TCP")]),v._v(" 或 "),e("code",[v._v("TLS-over-TCP")]),v._v(" 上发送")]),v._v(" "),e("p",[v._v("对于 "),e("code",[v._v("TCP")]),v._v(" 和 "),e("code",[v._v("TLS-over-TCP")]),v._v("，客户端向服务器打开 "),e("code",[v._v("TCP")]),v._v(" 连接。在 "),e("code",[v._v("STUN")]),v._v(" 的某些使用场景中，"),e("code",[v._v("STUN")]),v._v(" 是通过 "),e("code",[v._v("TCP")]),v._v(" 连接单独发送的。在这种情况下，它可以在不需要任何额外帧同步或多路复用的情况下发送。在其他使用场景或其他扩展中，"),e("code",[v._v("STUN")]),v._v(" 可能与 "),e("code",[v._v("TCP")]),v._v(" "),e("code",[v._v("连接上的其他数据进行多路复用。在这种情况下，STUN")]),v._v(" 必须在某种帧同步协议的基础上运行，由使用场景或扩展指定，以便代理可以提取完整的 "),e("code",[v._v("STUN")]),v._v(" 消息和完整的应用层消息。运行在众所周知的端口上的 "),e("code",[v._v("STUN")]),v._v(" 服务，或者通过第 9 节中的 "),e("code",[v._v("DNS")]),v._v(" 过程发现的端口，仅用于 "),e("code",[v._v("STUN")]),v._v(" 本身，而不是与其他数据一起多路复用的 "),e("code",[v._v("STUN")]),v._v("。因此，在连接到这些服务器时不使用帧同步协议。当使用额外的帧同步时，使用场景将指定客户端如何应用它以及连接到哪个端口。例如，在 "),e("code",[v._v("ICE")]),v._v(" 连接检查的情况下，此信息是通过客户端和服务器之间的带外协商获得的。")]),v._v(" "),e("p",[v._v("当 "),e("code",[v._v("STUN")]),v._v(" 自身在 "),e("code",[v._v("TLS-over-TCP")]),v._v(" 上运行时，至少必须实现 "),e("code",[v._v("TLS_RSA_WITH_AES_128_CBC_SHA")]),v._v(" 密码套件。实现还可以支持任何其他密码套件。当客户端收到 "),e("code",[v._v("TLS")]),v._v(" 证书消息时，应验证证书并检查证书中标识的站点。如果证书无效或被撤销，或者没有标识合适的方，客户端必须不发送 "),e("code",[v._v("STUN")]),v._v(" 消息或以其他方式继续 "),e("code",[v._v("STUN")]),v._v(" 事务。客户端必须验证服务器的身份。为此，它遵循 "),e("code",[v._v("RFC 2818")]),v._v(" 第 3.1 节中定义的识别过程["),e("code",[v._v("RFC2818")]),v._v("]。这些过程假设客户端正在解引用 "),e("code",[v._v("URI")]),v._v("。为了与本规范一起使用，客户端将第 8.1 节中使用的域名或 "),e("code",[v._v("IP")]),v._v(" 地址视为已解引用的 "),e("code",[v._v("URI")]),v._v(" 的主机部分。或者，客户端可以配置为信任一组域名或 "),e("code",[v._v("IP")]),v._v(" 地址；如果收到一个标识这些域名或 "),e("code",[v._v("IP")]),v._v(" 地址之一的证书，客户端就认为服务器的身份已经过验证。")]),v._v(" "),e("p",[v._v("当 "),e("code",[v._v("STUN")]),v._v(" 与其他协议一起在 "),e("code",[v._v("TLS-over-TCP")]),v._v(" 连接上多路复用时，强制性密码套件和 "),e("code",[v._v("TLS")]),v._v(" 处理过程将按照这些协议定义的方式进行操作。"),e("code",[v._v("STUN")]),v._v(" 在 "),e("code",[v._v("TCP")]),v._v(" 和 "),e("code",[v._v("TLS-over-TCP")]),v._v(" 上的可靠性是通过 "),e("code",[v._v("TCP")]),v._v(" 本身处理的，"),e("code",[v._v("STUN")]),v._v(" 协议级别没有重传。然而，对于请求/响应事务，如果客户端在发送 "),e("code",[v._v("SYN")]),v._v(" 建立连接后的 "),e("code",[v._v("Ti")]),v._v(" 秒内没有收到响应，它将认为事务已超时。"),e("code",[v._v("Ti")]),v._v(" 应该是可配置的，且默认值应为 39.5 秒。该值被选择为默认初始 "),e("code",[v._v("RTO")]),v._v(" 的 "),e("code",[v._v("TCP")]),v._v(" 和 "),e("code",[v._v("UDP")]),v._v(" 超时相等。")]),v._v(" "),e("p",[v._v("此外，如果客户端无法建立 "),e("code",[v._v("TCP")]),v._v(" 连接，或者在收到响应之前 "),e("code",[v._v("TCP")]),v._v(" 连接被重置或失败，则任何进行中的请求/响应事务都被认为是失败的。客户端可以在单个 "),e("code",[v._v("TCP")]),v._v("（或 "),e("code",[v._v("TLS-over-TCP")]),v._v("）连接上发送多个事务，也可以在收到前一个响应之前发送另一个请求。客户端应保持连接打开，直到满足以下条件：")]),v._v(" "),e("ul",[e("li",[v._v("没有进一步的 "),e("code",[v._v("STUN")]),v._v(" 请求或指示要通过该连接发送，")]),v._v(" "),e("li",[v._v("不再计划使用通过该连接发送的 "),e("code",[v._v("STUN")]),v._v(" 请求了解的任何资源（如映射地址（"),e("code",[v._v("MAPPED-ADDRESS")]),v._v(" 或 "),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v("）或中继地址["),e("code",[v._v("BEHAVE-TURN")]),v._v("]），")]),v._v(" "),e("li",[v._v("如果在该端口上多路复用其他应用协议，则完成使用其他应用程序，")]),v._v(" "),e("li",[v._v("如果使用已学习的端口与远程对等方通信，则已与远程对等方建立通信，这是某些 "),e("code",[v._v("TCP NAT")]),v._v(" 遍历技术所需的（例如，["),e("code",[v._v("MMUSIC-ICE-TCP")]),v._v("]）。")])]),v._v(" "),e("p",[v._v("在服务器端，服务器应保持连接打开，让客户端关闭它，除非服务器确定连接已超时（例如，由于客户端断开网络连接）。只要连接保持打开，客户端学到的绑定在 "),e("code",[v._v("NAT")]),v._v(" 中将保持有效。只有客户端知道它需要绑定多长时间。服务器不应在收到连接请求后关闭连接。服务器不能向客户端打开一个连接以发送响应。服务器在过载情况下应遵循有关连接管理的最佳实践。")]),v._v(" "),e("blockquote",[e("p",[v._v("在"),e("code",[v._v("TCP")]),v._v("或"),e("code",[v._v("TLS-over-TCP")]),v._v("上发送"),e("code",[v._v("STUN")]),v._v("时，客户端会向服务器打开"),e("code",[v._v("TCP")]),v._v("连接。"),e("code",[v._v("STUN")]),v._v("可以作为唯一协议通过"),e("code",[v._v("TCP")]),v._v("发送，也可以与其他数据一起通过"),e("code",[v._v("TCP")]),v._v("连接进行多路复用。"),e("code",[v._v("STUN")]),v._v("在"),e("code",[v._v("TCP")]),v._v("和"),e("code",[v._v("TLS-over-TCP")]),v._v("上的可靠性由"),e("code",[v._v("TCP")]),v._v("本身处理。客户端可以在单个"),e("code",[v._v("TCP")]),v._v("（或"),e("code",[v._v("TLS-over-TCP")]),v._v("）连接上发送多个事务。服务器应保持连接打开，并让客户端关闭它。")])]),v._v(" "),e("h2",{attrs:{id:"接收-stun-消息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接收-stun-消息"}},[v._v("#")]),v._v(" 接收 STUN 消息")]),v._v(" "),e("p",[v._v("本节规定了 "),e("code",[v._v("STUN")]),v._v(" 消息的处理。这里规定的处理适用于本规范中定义的 "),e("code",[v._v("STUN")]),v._v(" 消息；第 12 节定义了向后兼容的附加规则。这些附加程序是可选的，各种用途可以选择使用它们。首先，应用一组独立于类别的处理操作。接下来是特定于类别的处理，如下面的子节所述。")]),v._v(" "),e("p",[v._v("当 "),e("code",[v._v("STUN")]),v._v(" 代理接收到 "),e("code",[v._v("STUN")]),v._v(" 消息时，首先检查消息是否遵循第 6 节的规则。它检查前两位是否为 0，"),e("code",[v._v("magic cookie")]),v._v(" 字段是否具有正确的值，消息长度是否合理，方法值是否为支持的方法。它检查消息类别是否允许特定方法。如果消息类别是“成功响应”或“错误响应”，代理检查事务 "),e("code",[v._v("ID")]),v._v(" 是否与仍在进行的事务匹配。如果正在使用 "),e("code",[v._v("FINGERPRINT")]),v._v(" 扩展，代理检查 "),e("code",[v._v("FINGERPRINT")]),v._v(" 属性是否存在且包含正确的值。"),e("strong",[v._v("如果检测到任何错误，消息将被静默丢弃。")]),v._v(" 在 "),e("code",[v._v("STUN")]),v._v(" 与其他协议多路复用的情况下，错误可能表明这并非真正的 "),e("code",[v._v("STUN")]),v._v(" 消息；在这种情况下，代理应尝试将消息解析为其他协议。")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 代理然后执行用途指定的认证机制所需的任何检查（参见第 10 节）。")]),v._v(" "),e("p",[v._v("一旦完成认证检查，"),e("code",[v._v("STUN")]),v._v(" 代理检查消息中的未知属性和已知但意外的属性。未知的可理解可选属性必须被代理忽略。已知但意外的属性应被代理忽略。未知的可理解必需属性会导致依赖于消息类别的处理，如下所述。此时，进一步处理取决于请求的消息类别。")]),v._v(" "),e("h3",{attrs:{id:"处理请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#处理请求"}},[v._v("#")]),v._v(" 处理请求")]),v._v(" "),e("p",[v._v("如果请求包含一个或多个未知的必需理解属性，服务器将回复一个带有错误代码 420（未知属性）的错误响应，并在响应中包含一个 "),e("code",[v._v("UNKNOWN-ATTRIBUTES")]),v._v(" 属性，列出未知的必需理解属性。")]),v._v(" "),e("p",[v._v("然后，服务器进行方法或特定用途要求的任何其他检查。如果所有检查都成功，服务器会按照下面的描述制定成功响应。")]),v._v(" "),e("p",[v._v("在 "),e("code",[v._v("UDP")]),v._v(" 上运行时，"),e("strong",[v._v("服务器接收到的请求可能是事务的第一个请求，也可能是重传。")]),v._v(" 服务器必须对重传进行响应，以保留以下属性：")]),v._v(" "),e("ul",[e("li",[v._v("如果客户端接收到重传的响应而不是发送给原始请求的响应，客户端和服务器上的整体状态与只接收到原始重传响应的情况相同，或者两个响应都接收到的情况下（此时客户端将使用第一个）。")])]),v._v(" "),e("p",[v._v("满足此要求的最简单方法是服务器记住在过去 40 秒内通过 "),e("code",[v._v("UDP")]),v._v(" 接收到的所有事务 "),e("code",[v._v("ID")]),v._v(" 及其相应的响应。然而，这需要服务器保持状态，并且对于未经认证的请求是不合适的。另一种方法是重新处理请求并重新计算响应。后一种技术必须仅应用于幂等请求（当相同的请求可以安全地重复而不影响系统的整体状态时，认为请求是幂等的），并且对于相同的请求产生相同的成功响应。"),e("code",[v._v("Binding")]),v._v(" 方法被认为是幂等的。请注意，某些罕见的网络事件可能导致反射传输地址值发生变化，从而导致不同成功响应中的映射地址不同。"),e("code",[v._v("STUN")]),v._v(" 的扩展必须讨论不存储事务状态的服务器上请求重传的影响。")]),v._v(" "),e("h4",{attrs:{id:"生成成功或错误响应"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生成成功或错误响应"}},[v._v("#")]),v._v(" 生成成功或错误响应")]),v._v(" "),e("p",[v._v('当服务器生成响应（成功或错误）时，需要遵循第 6 节的规则。响应的方法与请求相同，消息类别是"'),e("code",[v._v("Success Response")]),v._v('"（成功响应）或"'),e("code",[v._v("Error Response")]),v._v('"（错误响应）。')]),v._v(" "),e("p",[v._v("对于错误响应，服务器必须添加一个 "),e("code",[v._v("ERROR-CODE")]),v._v(" 属性，其中包含上述处理中指定的错误代码。原因短语不固定，但应该是适合错误代码的内容。对于某些错误，会在消息中添加额外的属性。这些属性在描述错误代码时详细说明。例如，对于错误代码 420（"),e("code",[v._v("Unknown Attribute")]),v._v("，未知属性），服务器必须包含一个 "),e("code",[v._v("UNKNOWN-ATTRIBUTES")]),v._v(" 属性。某些身份验证错误也会导致添加属性（参见第 10 节）。扩展可以定义其他错误和/或在错误情况下添加额外属性。")]),v._v(" "),e("p",[v._v("如果服务器使用身份验证机制对请求进行了身份验证，则服务器应在响应中添加适当的身份验证属性（参见第 10 节）。")]),v._v(" "),e("p",[v._v("服务器还会根据特定方法或用途添加任何所需的属性。此外，服务器应在消息中添加一个 "),e("code",[v._v("SOFTWARE")]),v._v(" 属性。")]),v._v(" "),e("p",[v._v("对于 "),e("code",[v._v("Binding")]),v._v(" 方法，除非用途另有规定，否则不需要额外的检查。在生成成功响应时，服务器会在响应中添加一个 "),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 属性，其中属性的内容是请求消息的源传输地址。对于 "),e("code",[v._v("UDP")]),v._v("，这是请求消息的源 "),e("code",[v._v("IP")]),v._v(" 地址和源 "),e("code",[v._v("UDP")]),v._v(" 端口。对于 "),e("code",[v._v("TCP")]),v._v(" 和 "),e("code",[v._v("TLS-over-TCP")]),v._v("，这是服务器看到的 "),e("code",[v._v("TCP")]),v._v(" 连接的源 "),e("code",[v._v("IP")]),v._v(" 地址和源 "),e("code",[v._v("TCP")]),v._v(" 端口。")]),v._v(" "),e("h4",{attrs:{id:"发送成功或错误响应"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#发送成功或错误响应"}},[v._v("#")]),v._v(" 发送成功或错误响应")]),v._v(" "),e("p",[v._v("响应（成功或错误）将通过与接收请求相同的传输方式发送。如果请求是通过 "),e("code",[v._v("UDP")]),v._v(" 接收的，响应的目标 "),e("code",[v._v("IP")]),v._v(" 地址和端口与接收到的请求消息的源 "),e("code",[v._v("IP")]),v._v(" 地址和端口相同，响应的源 "),e("code",[v._v("IP")]),v._v(" 地址和端口与接收到的请求消息的目标 "),e("code",[v._v("IP")]),v._v(" 地址和端口相同。如果请求是通过 "),e("code",[v._v("TCP")]),v._v(" 或 "),e("code",[v._v("TLS-over-TCP")]),v._v(" 接收的，则响应将通过与接收请求相同的 "),e("code",[v._v("TCP")]),v._v(" 连接发送回去。")]),v._v(" "),e("h3",{attrs:{id:"处理指示消息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#处理指示消息"}},[v._v("#")]),v._v(" 处理指示消息")]),v._v(" "),e("p",[e("strong",[v._v("如果指示消息中包含未知的必需理解属性，该指示将被丢弃，处理终止。")])]),v._v(" "),e("p",[v._v("然后，代理执行该方法或特定用途所需的任何其他检查。如果所有检查都成功，则代理接着处理指示消息。对于指示消息，不会生成响应。")]),v._v(" "),e("p",[v._v("对于 "),e("code",[v._v("Binding")]),v._v(" 方法，除非用途另有规定，否则不需要进行其他检查或处理。代理仅接收消息即刷新了中间 "),e("code",[v._v("NAT")]),v._v(" 中的“绑定”。")]),v._v(" "),e("p",[v._v("由于指示消息在 "),e("code",[v._v("UDP")]),v._v(" 上不会被重传（与请求不同），因此无需在发送代理处处理指示消息的重传。")]),v._v(" "),e("h3",{attrs:{id:"处理成功响应"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#处理成功响应"}},[v._v("#")]),v._v(" 处理成功响应")]),v._v(" "),e("p",[v._v("如果成功响应中包含未知的必需理解属性，该响应将被丢弃，且该事务被视为失败。\n然后，客户端执行该方法或特定用途所需的任何其他检查。如果所有检查都成功，则客户端接着处理成功响应。")]),v._v(" "),e("p",[v._v("对于 "),e("code",[v._v("Binding")]),v._v(" 方法，客户端检查响应中是否存在 "),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 属性。客户端检查指定的地址族。如果地址族不受支持，则应忽略该属性。如果是意外的但受支持的地址族（例如，"),e("code",[v._v("Binding")]),v._v(" 事务是通过 "),e("code",[v._v("IPv4")]),v._v(" 发送的，但指定的地址族是 "),e("code",[v._v("IPv6")]),v._v("），则客户端可以选择接受并使用该值。")]),v._v(" "),e("h3",{attrs:{id:"处理错误响应"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#处理错误响应"}},[v._v("#")]),v._v(" 处理错误响应")]),v._v(" "),e("p",[v._v("如果错误响应中包含未知的必需理解属性，或者错误响应中不包含 "),e("code",[v._v("ERROR-CODE")]),v._v(" 属性，那么事务只需被视为失败。\n接着，客户端执行认证机制所指定的任何处理（参见第 10 节）。这可能导致新的事务尝试。")]),v._v(" "),e("p",[v._v("此时的处理取决于错误代码、方法和用途；以下是默认规则：")]),v._v(" "),e("ul",[e("li",[v._v("如果错误代码为 300 至 399，除非使用 "),e("code",[v._v("ALTERNATE-SERVER")]),v._v(" 扩展，客户端应将事务视为失败。请参阅第 11 节。")]),v._v(" "),e("li",[v._v("如果错误代码为 400 至 499，客户端宣布事务失败；对于 420（未知属性）错误代码，响应应包含一个 "),e("code",[v._v("UNKNOWN-ATTRIBUTES")]),v._v(" 属性，提供额外信息。")]),v._v(" "),e("li",[v._v("如果错误代码为 500 至 599，客户端可以选择重发请求；选择这样做的客户端必须限制他们这样做的次数。")])]),v._v(" "),e("p",[v._v("任何其他错误代码会导致客户端将事务视为失败。")]),v._v(" "),e("h1",{attrs:{id:"fingerprint-机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fingerprint-机制"}},[v._v("#")]),v._v(" "),e("code",[v._v("FINGERPRINT")]),v._v(" 机制")]),v._v(" "),e("p",[v._v("本节描述了一个可选的 "),e("code",[v._v("STUN")]),v._v(" 机制，有助于在将两者复用到同一传输地址时，区分 "),e("code",[v._v("STUN")]),v._v(" 消息和其他协议的数据包。此机制是可选的，"),e("strong",[e("code",[v._v("STUN")]),v._v(" 用法必须描述是否以及何时使用它。")]),v._v(" "),e("code",[v._v("FINGERPRINT")]),v._v(" 机制与 "),e("code",[v._v("RFC 3489")]),v._v(" 不向后兼容，不能在需要这种兼容性的环境中使用。")]),v._v(" "),e("p",[v._v("在某些用途中，"),e("code",[v._v("STUN")]),v._v(" 消息与其他协议（如实时传输协议（"),e("code",[v._v("RTP")]),v._v("））复用在同一传输地址上。为了应用第 7 节描述的处理过程，首先需要将 "),e("code",[v._v("STUN")]),v._v(" 消息与应用程序数据包分开。第 6 节描述了 "),e("code",[v._v("STUN")]),v._v(" 标头中可用于此目的的三个固定字段。然而，在某些情况下，这三个固定字段可能不足以应对。")]),v._v(" "),e("p",[v._v("当使用 "),e("code",[v._v("FINGERPRINT")]),v._v(" 扩展时，代理会在发送给另一个代理的消息中包含 "),e("code",[v._v("FINGERPRINT")]),v._v(" 属性。第 15.5 节描述了此属性的位置和值。当代理收到其认为是 "),e("code",[v._v("STUN")]),v._v(" 消息的内容时，除了进行其他基本检查之外，代理还会检查消息是否包含 "),e("code",[v._v("FINGERPRINT")]),v._v(" 属性，以及属性是否包含正确的值。第 7.3 节描述了在 "),e("code",[v._v("STUN")]),v._v(" 消息的整体处理过程中何时执行 "),e("code",[v._v("FINGERPRINT")]),v._v(" 检查。这个额外的检查有助于代理检测到可能看似 "),e("code",[v._v("STUN")]),v._v(" 消息的其他协议的消息。")]),v._v(" "),e("h1",{attrs:{id:"dns-服务器发现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dns-服务器发现"}},[v._v("#")]),v._v(" "),e("code",[v._v("DNS")]),v._v(" 服务器发现")]),v._v(" "),e("p",[v._v("本节描述了一个可选的 "),e("code",[v._v("STUN")]),v._v(" 程序，允许客户端使用 "),e("code",[v._v("DNS")]),v._v(" 确定服务器的 "),e("code",[v._v("IP")]),v._v(" 地址和端口。"),e("code",[v._v("STUN")]),v._v(" 用法必须描述是否以及何时使用此扩展。要使用此程序，客户端必须知道服务器的域名和服务名；用法还必须描述客户端如何获取这些信息。不建议将服务器的域名硬编码到软件中，以防域名丢失或因法律或其他原因需要更改。")]),v._v(" "),e("p",[v._v("当客户端希望在公共互联网中找到一个接受绑定请求/响应事务的 "),e("code",[v._v("STUN")]),v._v(" 服务器时，"),e("code",[v._v("SRV")]),v._v(' 服务名为 "'),e("code",[v._v("stun")]),v._v('"。当它希望找到一个在 '),e("code",[v._v("TLS")]),v._v(" 会话上接受绑定请求/响应事务的 "),e("code",[v._v("STUN")]),v._v(" 服务器时，"),e("code",[v._v("SRV")]),v._v(' 服务名为 "'),e("code",[v._v("stuns")]),v._v('"。'),e("code",[v._v("STUN")]),v._v(" 用法可以定义其他 "),e("code",[v._v("DNS SRV")]),v._v(" 服务名称。")]),v._v(" "),e("p",[v._v("使用 ["),e("code",[v._v("RFC2782")]),v._v("] 中规定的 "),e("code",[v._v("SRV")]),v._v(" 程序将域名解析为传输地址。"),e("code",[v._v("DNS SRV")]),v._v(" 服务名是作为此过程输入的服务名。"),e("code",[v._v("SRV")]),v._v(" 查找中的协议是客户端将在其上运行 "),e("code",[v._v("STUN")]),v._v(' 的传输协议："'),e("code",[v._v("udp")]),v._v('" 代表 '),e("code",[v._v("UDP")]),v._v('，"'),e("code",[v._v("tcp")]),v._v('" 代表 '),e("code",[v._v("TCP")]),v._v('。请注意，目前仅在 "'),e("code",[v._v("stuns")]),v._v('" 中定义了 "'),e("code",[v._v("tcp")]),v._v('"。')]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("假设您有一个 WebRTC 服务，需要在其内部使用 STUN 服务器来帮助客户端实现 NAT 穿透。\n您的 WebRTC 服务的域名为 example.com，您希望客户端能够通过 DNS 查找到提供 STUN\n服务的服务器。\n\n首先，您需要在 DNS 配置中创建一个 SRV 记录，例如：\n\n_stun._udp.example.com. 3600 IN SRV 10 5 3478 stunserver.example.com.\n\n这个 SRV 记录的组成部分解释如下：\n\n- _stun：这是您要查找的服务名（STUN）。\n- _udp：这是您要使用的传输协议（UDP）。\n- example.com：这是您的域名。\n- 3600：这是 SRV 记录的生存时间（TTL），单位为秒。\n- IN：这是 DNS 记录的类别（Internet）。\n- SRV：这是 DNS 记录的类型（Service）。\n- 10：这是服务器的优先级。较低的数字表示更高的优先级。\n- 5：这是服务器的权重。在相同优先级的服务器中，权重较高的服务器更可能被选中。\n- 3478：这是 STUN 服务器的端口。\n- stunserver.example.com：这是提供 STUN 服务的服务器的主机名。\n\n客户端在寻找提供 STUN 服务的服务器时，会使用 DNS 查找 SRV 记录。\n客户端将找到 SRV 记录，了解到它应该连接到主机名为 stunserver.example.com，\n端口为 3478 的服务器。这样，客户端就可以成功地连接到提供 STUN 服务的服务器，\n进行 NAT 穿透以实现 P2P 通信。\n")])])]),e("p",[v._v("遵循 "),e("code",[v._v("RFC 2782")]),v._v(" 的规程以确定要联系的服务器。"),e("code",[v._v("RFC 2782")]),v._v(" 详述了一组 "),e("code",[v._v("SRV")]),v._v(" 记录如何排序和尝试的细节。然而，"),e("code",[v._v("RFC 2782")]),v._v(' 只是指出客户端应该 "尝试连接到（协议，地址，服务）"，而没有给出在失败情况下发生什么的详细信息。在遵循这些程序时，如果 '),e("code",[v._v("STUN")]),v._v(" 事务在未收到响应的情况下超时，客户端应该将请求重试到 "),e("code",[v._v("RFC 2782")]),v._v(" 定义的顺序中的下一个服务器。这种重试只适用于请求/响应传输，因为指示事务不会生成响应或超时。")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 请求的默认端口是 3478，适用于 "),e("code",[v._v("TCP")]),v._v(" 和 "),e("code",[v._v("UDP")]),v._v("。"),e("code",[v._v("STUN")]),v._v(" 服务器的管理员应该在他们的 "),e("code",[v._v("SRV")]),v._v(" 记录中为 "),e("code",[v._v("UDP")]),v._v(" 和 "),e("code",[v._v("TCP")]),v._v(" 使用这个端口。在所有情况下，"),e("code",[v._v("DNS")]),v._v(" 中的端口必须反映服务器正在监听的端口。"),e("code",[v._v("STUN over TLS")]),v._v(" 的默认端口是 5349。如果服务器软件支持确定初始消息是 "),e("code",[v._v("TLS")]),v._v(" 消息还是 "),e("code",[v._v("STUN")]),v._v(" 消息，服务器可以在与 "),e("code",[v._v("STUN over TCP")]),v._v(" 相同的端口上运行 "),e("code",[v._v("STUN over TLS")]),v._v("。")]),v._v(" "),e("p",[v._v("如果没有找到 "),e("code",[v._v("SRV")]),v._v(" 记录，客户端对域名执行 "),e("code",[v._v("A")]),v._v(" 或 "),e("code",[v._v("AAAA")]),v._v(" 记录查找。结果将是一组 "),e("code",[v._v("IP")]),v._v(" 地址，每个地址都可以使用 "),e("code",[v._v("UDP")]),v._v(" 或 "),e("code",[v._v("TCP")]),v._v(" 在默认端口上联系，与 "),e("code",[v._v("STUN")]),v._v(" 用法无关。对于需要 "),e("code",[v._v("TLS")]),v._v(" 的用法，客户端使用默认的 "),e("code",[v._v("STUN over TLS")]),v._v(" 端口连接到其中一个 "),e("code",[v._v("IP")]),v._v(" 地址。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("A（Address）记录和AAAA（IPv6 Address）记录是DNS（Domain Name System，域名系统）中的两种\n记录类型。它们分别用于将域名映射到IPv4地址和IPv6地址。\n\nA记录：A记录是将域名映射到IPv4地址的记录。当客户端向DNS服务器查询域名对应的IPv4地址时，\nDNS服务器会返回与该域名关联的A记录。例如，当您访问一个网站时，\n浏览器首先会查询网站域名对应的IPv4地址，然后使用该地址建立连接。\n\nAAAA记录：AAAA记录与A记录类似，但它是将域名映射到IPv6地址的记录。随着互联网的发展，\nIPv4地址逐渐耗尽，IPv6地址应运而生。AAAA记录允许客户端查询和连接到使用IPv6地址的服务器。\n")])])]),e("h1",{attrs:{id:"身份验证和消息完整性机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#身份验证和消息完整性机制"}},[v._v("#")]),v._v(" 身份验证和消息完整性机制")]),v._v(" "),e("p",[v._v("本节定义了两种 "),e("code",[v._v("STUN")]),v._v(" 客户端和服务器可用于提供身份验证和消息完整性的机制，这两种机制分别称为短期凭证机制（"),e("code",[v._v("short-term credential mechanism")]),v._v("）和长期凭证机制（"),e("code",[v._v("long-term credential mechanism")]),v._v("）。这两种机制是可选的，每种用法都必须指定是否以及何时使用这些机制。因此，基于对应用法的了解，客户端和服务器都会知道要遵循哪种机制（如果有的话）。例如，支持 "),e("code",[v._v("ICE")]),v._v(" 的公共互联网上的 "),e("code",[v._v("STUN")]),v._v(" 服务器将没有身份验证，而支持连接检查的代理中的 "),e("code",[v._v("STUN")]),v._v(" 服务器功能将使用短期凭证。第 3 节给出了这两种机制的概述。")]),v._v(" "),e("p",[v._v("每种机制都规定了使用该机制所需的额外处理，扩展了第 7 节中指定的处理。额外的处理发生在三个不同的地方：在形成消息时，收到消息后立即执行基本检查时，以及在执行错误响应的详细处理时。(这两种机制在创建消息、接收消息后的基本检查和处理错误响应时都需要进行额外的处理。)")]),v._v(" "),e("h2",{attrs:{id:"短期凭证机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#短期凭证机制"}},[v._v("#")]),v._v(" 短期凭证机制")]),v._v(" "),e("p",[v._v("短期凭证机制假定在 "),e("code",[v._v("STUN")]),v._v(" 事务之前，客户端和服务器已经使用了某种其他协议来交换一个以用户名和密码形式的凭证。这个凭证是有时间限制的。时间限制由使用场景定义。例如，在 "),e("code",[v._v("ICE")]),v._v(" 使用场景["),e("code",[v._v("MMUSIC-ICE")]),v._v("]中，两个端点使用带外信令协商用户名和密码，这个用户名和密码在媒体会话期间有效。")]),v._v(" "),e("p",[v._v("这个凭证用于在每个请求和许多响应中形成消息完整性检查。没有像长期机制中的挑战和响应；因此，通过凭证的时间限制性防止了重放。")]),v._v(" "),e("h3",{attrs:{id:"生成请求或指示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生成请求或指示"}},[v._v("#")]),v._v(" 生成请求或指示")]),v._v(" "),e("p",[v._v("对于请求或指示消息，代理必须在消息中包含 "),e("code",[v._v("USERNAME")]),v._v("（用户名）和 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v("（消息完整性）属性。计算 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性的 "),e("code",[v._v("HMAC")]),v._v("（散列消息认证码）的方式如第 15.4 节所述。请注意，密码永远不会包含在请求或指示中。")]),v._v(" "),e("h3",{attrs:{id:"接收请求或指示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接收请求或指示"}},[v._v("#")]),v._v(" 接收请求或指示")]),v._v(" "),e("p",[v._v("在代理完成对消息的基本处理后，按以下顺序执行以下检查：")]),v._v(" "),e("ul",[e("li",[v._v("如果消息既不包含 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v("（消息完整性）属性，也不包含 "),e("code",[v._v("USERNAME")]),v._v("（用户名）属性：\n"),e("ul",[e("li",[v._v("如果消息是请求，服务器必须使用错误代码 400（错误的请求）拒绝该请求。")]),v._v(" "),e("li",[v._v("如果消息是指示，代理必须静默丢弃该指示。")])])]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("USERNAME")]),v._v(" 不包含服务器当前有效的用户名值：\n"),e("ul",[e("li",[v._v("如果消息是请求，服务器必须使用错误代码 401（未授权）拒绝该请求。")]),v._v(" "),e("li",[v._v("如果消息是指示，代理必须静默丢弃该指示。")])])]),v._v(" "),e("li",[v._v("使用与用户名关联的密码，根据第 15.4 节的描述计算消息完整性值。如果得到的值与 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性的内容不匹配：\n"),e("ul",[e("li",[v._v("如果消息是请求，服务器必须使用错误代码 401（未授权）拒绝该请求。")]),v._v(" "),e("li",[v._v("如果消息是指示，代理必须静默丢弃该指示。")])])])]),v._v(" "),e("p",[v._v("如果这些检查通过，代理继续处理请求或指示。服务器生成的任何响应都必须包含使用密码计算的 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性，以验证请求。响应中不能包含 "),e("code",[v._v("USERNAME")]),v._v(" 属性。")]),v._v(" "),e("p",[v._v("如果任何检查失败，服务器在错误响应中不能包含 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 或 "),e("code",[v._v("USERNAME")]),v._v(" 属性。这是因为，在这些失败情况下，服务器无法确定计算 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 所需的共享秘密。")]),v._v(" "),e("h3",{attrs:{id:"接收响应"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接收响应"}},[v._v("#")]),v._v(" 接收响应")]),v._v(" "),e("p",[v._v("客户端在响应中查找 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v("（消息完整性）属性。如果存在，客户端使用与请求相同的密码计算响应的消息完整性，如第 15.4 节所定义。如果得到的值与 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性的内容匹配，响应被视为经过认证。如果值不匹配，或者 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性不存在，则必须丢弃响应，就像从未收到过一样。这意味着如果适用，重传将继续。")]),v._v(" "),e("h2",{attrs:{id:"长期凭证机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#长期凭证机制"}},[v._v("#")]),v._v(" 长期凭证机制")]),v._v(" "),e("p",[v._v("长期凭证机制依赖于客户端和服务器共享的长期凭证，以用户名和密码的形式提供。凭证被认为是长期的，因为它被假定为用户配置的，直到用户不再是系统的订阅者或发生更改为止。这基本上是传统的“登录”用户名和密码，赋予用户使用。")]),v._v(" "),e("p",[v._v("由于这些用户名和密码预期在很长一段时间内有效，因此提供摘要挑战的形式来防止重放。在这种机制中，客户端最初发送请求，不提供任何凭证或完整性检查。服务器拒绝此请求，为用户提供一个领域（用于指导用户或代理选择用户名和密码）和一个随机数。随机数提供重放保护。它是由服务器选择的一个 "),e("code",[v._v("cookie")]),v._v("，并以某种方式编码，以表示有效期或有效的客户端身份。客户端重试请求，这次包括其用户名和领域，并回显服务器提供的随机数。客户端还包括一个消息完整性，它提供了整个请求（包括随机数）的 "),e("code",[v._v("HMAC")]),v._v("。服务器验证随机数并检查消息完整性。如果匹配，则请求经过身份验证。如果随机数不再有效，它将被视为“陈旧”，服务器拒绝请求，提供新的随机数。在后续请求相同服务器时，客户端重复使用先前使用的随机数、用户名、领域和密码。这样，后续请求不会被拒绝，直到服务器使随机数无效，在这种情况下，拒绝会为客户端提供新的随机数。")]),v._v(" "),e("p",[e("strong",[v._v("请注意，由于指示不能被质疑，长期凭证机制无法保护指示。使用指示的用法必须使用短期凭证，或者省略对它们的认证和消息完整性。")])]),v._v(" "),e("p",[v._v("由于长期凭证机制容易受到离线字典攻击，部署应使用难以猜测的密码。在凭证不是由用户输入，而是在设备配置期间放置在客户端设备上的情况下，密码应具有至少 128 位的随机性。在用户输入凭证的情况下，应遵循关于密码结构的最佳实践。")]),v._v(" "),e("h3",{attrs:{id:"构建请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构建请求"}},[v._v("#")]),v._v(" 构建请求")]),v._v(" "),e("p",[v._v("在构建请求时有两种情况。第一种情况是客户端向服务器（通过其 "),e("code",[v._v("IP")]),v._v(" 地址和端口识别）发送的第一个请求。第二种情况是，在成功完成先前的请求/响应事务后，客户端提交后续请求。由于 401 或 438 错误响应而形成请求在第 10.2.3 节中介绍，不被视为“后续请求”，因此不使用第 10.2.1.2 节描述的规则。")]),v._v(" "),e("h4",{attrs:{id:"首次请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#首次请求"}},[v._v("#")]),v._v(" 首次请求")]),v._v(" "),e("p",[v._v("如果客户端尚未与服务器（通过主机名识别，如果使用第 9 节的 "),e("code",[v._v("DNS")]),v._v(" 过程，则使用 "),e("code",[v._v("IP")]),v._v(" 地址）完成成功的请求/响应事务，它应省略 "),e("code",[v._v("USERNAME")]),v._v("（用户名）、"),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v("（消息完整性）、"),e("code",[v._v("REALM")]),v._v("（域）和 "),e("code",[v._v("NONCE")]),v._v("（随机数）属性。换句话说，第一个请求发送的方式就像没有应用任何身份验证或消息完整性一样。")]),v._v(" "),e("h4",{attrs:{id:"后续请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#后续请求"}},[v._v("#")]),v._v(" 后续请求")]),v._v(" "),e("p",[v._v("一旦请求/响应事务成功完成，客户端将获得服务器提供的域（"),e("code",[v._v("realm")]),v._v("）和随机数（"),e("code",[v._v("nonce")]),v._v("），并选择用于身份验证的用户名（"),e("code",[v._v("username")]),v._v("）和密码（"),e("code",[v._v("password")]),v._v("）。"),e("strong",[v._v("客户端应缓存用户名、密码、域和随机数以进行后续与服务器的通信。")]),v._v(" 当客户端发送后续请求时，它应使用这些缓存值包含 "),e("code",[v._v("USERNAME")]),v._v("（用户名）、"),e("code",[v._v("REALM")]),v._v("（域）和 "),e("code",[v._v("NONCE")]),v._v("（随机数）属性。它应包含一个 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v("（消息完整性）属性，使用缓存的密码按照第 15.4 节描述的方式计算。")]),v._v(" "),e("h3",{attrs:{id:"接收请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接收请求"}},[v._v("#")]),v._v(" 接收请求")]),v._v(" "),e("p",[v._v("在服务器完成对请求的基本处理后，按照以下顺序执行以下检查：")]),v._v(" "),e("ul",[e("li",[v._v("如果消息中不包含 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性，则服务器必须生成一个错误代码为 401（"),e("code",[v._v("Unauthorized")]),v._v("）的错误响应。此响应必须包含 "),e("code",[v._v("REALM")]),v._v(" 值。建议 "),e("code",[v._v("REALM")]),v._v(" 值为 "),e("code",[v._v("STUN")]),v._v(" 服务器提供商的域名。响应必须包含服务器选择的 "),e("code",[v._v("NONCE")]),v._v("。响应不应包含 "),e("code",[v._v("USERNAME")]),v._v(" 或 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性。")]),v._v(" "),e("li",[v._v("如果消息中包含 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性，但缺少 "),e("code",[v._v("USERNAME")]),v._v("、"),e("code",[v._v("REALM")]),v._v(" 或 "),e("code",[v._v("NONCE")]),v._v(" 属性，服务器必须生成一个错误代码为 400（"),e("code",[v._v("Bad Request")]),v._v("）的错误响应。此响应不应包含 "),e("code",[v._v("USERNAME")]),v._v("、"),e("code",[v._v("NONCE")]),v._v("、"),e("code",[v._v("REALM")]),v._v(" 或 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性。")]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("NONCE")]),v._v(" 不再有效，服务器必须生成一个错误代码为 438（"),e("code",[v._v("Stale Nonce")]),v._v("）的错误响应。此响应必须包含 "),e("code",[v._v("NONCE")]),v._v(" 和 "),e("code",[v._v("REALM")]),v._v(" 属性，且不应包含 "),e("code",[v._v("USERNAME")]),v._v(" 或 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性。服务器可以使随机数失效以提供额外的安全性。请参阅[RFC2617]第 4.3 节的指南。")]),v._v(" "),e("li",[v._v("如果 "),e("code",[v._v("USERNAME")]),v._v(" 属性中的用户名无效，服务器必须生成一个错误代码为 401（"),e("code",[v._v("Unauthorized")]),v._v("）的错误响应。此响应必须包含 "),e("code",[v._v("REALM")]),v._v(" 值。建议 "),e("code",[v._v("REALM")]),v._v(" 值为 "),e("code",[v._v("STUN")]),v._v(" 服务器提供商的域名。响应必须包含服务器选择的 "),e("code",[v._v("NONCE")]),v._v("。响应不应包含 "),e("code",[v._v("USERNAME")]),v._v(" 或 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性。")]),v._v(" "),e("li",[v._v("使用 "),e("code",[v._v("USERNAME")]),v._v(" 属性中的用户名关联的密码，按照第 15.4 节描述的方式计算消息完整性的值。如果得到的值与 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性的内容不匹配，服务器必须使用错误响应拒绝请求。此响应必须使用错误代码 401（"),e("code",[v._v("Unauthorized")]),v._v("）。必须包含 "),e("code",[v._v("REALM")]),v._v(" 和 "),e("code",[v._v("NONCE")]),v._v(" 属性，且不应包含 "),e("code",[v._v("USERNAME")]),v._v(" 或 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性。")])]),v._v(" "),e("p",[v._v("如果这些检查通过，服务器继续处理请求。服务器生成的任何响应（除了上述情况）必须包含 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性，使用用于验证请求的用户名和密码进行计算。"),e("code",[v._v("REALM")]),v._v("、"),e("code",[v._v("NONCE")]),v._v(" 和 "),e("code",[v._v("USERNAME")]),v._v(" 属性不应包含。")]),v._v(" "),e("h3",{attrs:{id:"接收响应-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接收响应-2"}},[v._v("#")]),v._v(" 接收响应")]),v._v(" "),e("p",[v._v("如果响应是一个错误代码为 401（"),e("code",[v._v("Unauthorized")]),v._v("）的错误响应，客户端应该使用新事务重试请求。此请求必须包含一个 "),e("code",[v._v("USERNAME")]),v._v("，由客户端根据错误响应中的 "),e("code",[v._v("REALM")]),v._v(" 确定适当的用户名。请求必须包含从错误响应中复制的 "),e("code",[v._v("REALM")]),v._v("。请求必须包含从错误响应中复制的 "),e("code",[v._v("NONCE")]),v._v("。请求必须包含 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性，使用 "),e("code",[v._v("USERNAME")]),v._v(" 属性中的用户名关联的密码计算。如果客户端在上一次尝试中未更改 "),e("code",[v._v("USERNAME")]),v._v(" 或 "),e("code",[v._v("REALM")]),v._v(" 或其关联的密码，客户端不得执行此重试。")]),v._v(" "),e("p",[v._v("如果响应是一个错误代码为 438（"),e("code",[v._v("Stale Nonce")]),v._v("）的错误响应，客户端必须使用 438（"),e("code",[v._v("Stale Nonce")]),v._v("）响应中提供的新 "),e("code",[v._v("NONCE")]),v._v(" 重试请求。这次重试还必须包括 "),e("code",[v._v("USERNAME")]),v._v("、"),e("code",[v._v("REALM")]),v._v(" 和 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v("。")]),v._v(" "),e("p",[v._v("客户端在响应中（成功或失败）查找 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性。如果存在，客户端使用与请求相同的密码计算响应上的消息完整性，如第 15.4 节定义。如果得到的值与 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性的内容匹配，则认为响应已通过验证。如果值不匹配，或者 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 缺失，响应必须被丢弃，就像从未收到过一样。这意味着如果适用，重传将继续。")]),v._v(" "),e("h1",{attrs:{id:"alternate-server-机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#alternate-server-机制"}},[v._v("#")]),v._v(" "),e("code",[v._v("ALTERNATE-SERVER")]),v._v(" 机制")]),v._v(" "),e("p",[v._v("本节描述了 "),e("code",[v._v("STUN")]),v._v(" 中的一种机制，允许服务器将客户端重定向到另一个服务器。此扩展是可选的，使用方法必须定义何时以及是否使用此扩展。")]),v._v(" "),e("p",[v._v("使用此扩展的服务器通过回复错误代码为 300（"),e("code",[v._v("Try Alternate")]),v._v("）的错误响应消息将客户端重定向到另一个服务器。服务器必须在错误响应中包含 "),e("code",[v._v("ALTERNATE-SERVER")]),v._v(" 属性。错误响应消息可以进行认证；然而，对于 "),e("code",[v._v("ALTERNATE-SERVER")]),v._v(" 的使用场景，响应认证可能不可能或不实际。")]),v._v(" "),e("p",[v._v("使用此扩展的客户端会以如下方式处理 300（"),e("code",[v._v("Try Alternate")]),v._v("）错误代码。客户端在错误响应中寻找 "),e("code",[v._v("ALTERNATE-SERVER")]),v._v(" 属性。如果找到了，则客户端认为当前事务失败，并使用属性中指定的服务器和与之前请求相同的传输协议重新尝试请求。如果经过身份验证的请求，必须使用客户端在重定向服务器的请求中使用的相同凭据。"),e("strong",[v._v("如果客户端在过去五分钟内已经被重定向到尝试过此请求的服务器上，它必须忽略重定向并认为事务失败。这可以防止在重定向循环的情况下服务器之间的无限循环。")])]),v._v(" "),e("h2",{attrs:{id:"与-rfc3489-的向后兼容性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#与-rfc3489-的向后兼容性"}},[v._v("#")]),v._v(" 与 "),e("code",[v._v("RFC3489")]),v._v(" 的向后兼容性")]),v._v(" "),e("p",[v._v("本节定义了允许与 ["),e("code",[v._v("RFC3489")]),v._v("] 中定义的原始协议向后兼容的程序。此机制是可选的，仅用于新客户端可以连接到旧服务器或反之亦然的情况。使用方法必须定义何时以及是否使用此程序。")]),v._v(" "),e("p",[v._v("第 19 节列出了本规范与 ["),e("code",[v._v("RFC3489")]),v._v('] 之间的所有更改。然而，并非所有这些差异都很重要，因为 "经典 '),e("code",[v._v("STUN")]),v._v('" 只在少数特定场景中使用。对于这个扩展，重要的更改如下：')]),v._v(" "),e("p",[v._v("在 "),e("code",[v._v("RFC3489")]),v._v(" 中：")]),v._v(" "),e("ul",[e("li",[v._v("只支持 "),e("code",[v._v("UDP")]),v._v(" 作为传输协议。")]),v._v(" "),e("li",[v._v("现在作为 "),e("code",[v._v("Magic cookie")]),v._v(" 字段的字段曾是事务 "),e("code",[v._v("ID")]),v._v(" 字段的一部分，事务 "),e("code",[v._v("ID")]),v._v(" 长度为 128 位。")]),v._v(" "),e("li",[e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 属性不存在，"),e("code",[v._v("Binding")]),v._v(" 方法改用 "),e("code",[v._v("MAPPED-ADDRESS")]),v._v(" 属性。")]),v._v(" "),e("li",[v._v("有三个理解所需属性，"),e("code",[v._v("RESPONSE-ADDRESS")]),v._v("、"),e("code",[v._v("CHANGE-REQUEST")]),v._v(" 和 "),e("code",[v._v("CHANGED-ADDRESS")]),v._v("，已从本规范中删除。")])]),v._v(" "),e("p",[e("code",[v._v("CHANGE-REQUEST")]),v._v(" 和 "),e("code",[v._v("CHANGED-ADDRESS")]),v._v(" 现在是 "),e("code",[v._v("NAT")]),v._v(" 行为发现使用方法 ["),e("code",[v._v("BEHAVE-NAT")]),v._v("] 的一部分，另一个已被弃用。")]),v._v(" "),e("h2",{attrs:{id:"客户端处理的更改"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#客户端处理的更改"}},[v._v("#")]),v._v(" 客户端处理的更改")]),v._v(" "),e("p",[v._v("希望与 ["),e("code",[v._v("RFC3489")]),v._v("] 服务器互操作的客户端应发送一个使用 "),e("code",[v._v("Binding")]),v._v(" 方法、不包含任何属性且使用 "),e("code",[v._v("UDP")]),v._v(" 作为传输协议的请求消息到服务器。如果成功，从服务器收到的成功响应将包含一个 "),e("code",[v._v("MAPPED-ADDRESS")]),v._v(" 属性，而不是 "),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 属性。试图与旧服务器互操作的客户端必须准备好接收其中之一。此外，客户端必须忽略响应中可能出现的任何保留的理解所需属性。在第 18.2 节的保留属性中，0x0002、0x0004、0x0005 和 0x000B 可能出现在遵循 "),e("code",[v._v("RFC3489")]),v._v(" 的服务器的 "),e("code",[v._v("Binding")]),v._v(" 响应中。除了这个变化外，响应的处理与上述过程相同。")]),v._v(" "),e("h2",{attrs:{id:"服务器处理的更改"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务器处理的更改"}},[v._v("#")]),v._v(" 服务器处理的更改")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 服务器可以通过检查 "),e("code",[v._v("Magic cookie")]),v._v(" 字段中正确值的缺失来检测发送的 "),e("code",[v._v("Binding")]),v._v(" 请求消息是否来自 ["),e("code",[v._v("RFC3489")]),v._v("] 客户端。当服务器检测到一个 "),e("code",[v._v("RFC3489")]),v._v(" 客户端时，它应该将 "),e("code",[v._v("Binding")]),v._v(" 请求中魔法 "),e("code",[v._v("cookie")]),v._v(" 字段的值复制到 "),e("code",[v._v("Binding")]),v._v(" 响应消息中的 "),e("code",[v._v("Magic cookie")]),v._v(" 字段，并插入一个 "),e("code",[v._v("MAPPED-ADDRESS")]),v._v(" 属性，而不是 "),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 属性。")]),v._v(" "),e("p",[v._v("在极少数情况下，客户端可能包含 "),e("code",[v._v("RESPONSE-ADDRESS")]),v._v(" 或 "),e("code",[v._v("CHANGE-REQUEST")]),v._v(" 属性。在这些情况下，服务器会将这些属性视为未知的理解所需属性，并回复错误响应。由于使用这些属性的机制已不再支持，这种行为是可以接受的。")]),v._v(" "),e("p",[e("code",[v._v("RFC3489")]),v._v(" 版本的 "),e("code",[v._v("STUN")]),v._v(" 缺少既有 "),e("code",[v._v("Magic cookie")]),v._v(" 又有 "),e("code",[v._v("FINGERPRINT")]),v._v(" 属性，这两者都可以在与其他协议复用时以非常高的概率正确识别 "),e("code",[v._v("STUN")]),v._v(" 消息。因此，在 "),e("code",[v._v("STUN")]),v._v(" 将与其他协议复用的情况下，不应使用向后兼容 "),e("code",[v._v("RFC3489")]),v._v(" 的 "),e("code",[v._v("STUN")]),v._v(" 实现。但是，这不应该是问题，因为这种复用在 "),e("code",[v._v("RFC3489")]),v._v(" 中不可用。")]),v._v(" "),e("h1",{attrs:{id:"基本服务器行为"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本服务器行为"}},[v._v("#")]),v._v(" 基本服务器行为")]),v._v(" "),e("p",[v._v("本节定义了一个基本的、独立的 "),e("code",[v._v("STUN")]),v._v(" 服务器的行为。基本 "),e("code",[v._v("STUN")]),v._v(" 服务器通过接收并回复 "),e("code",[v._v("STUN Binding")]),v._v(" 请求，为客户端提供服务器反射传输地址。")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 服务器必须支持 "),e("code",[v._v("Binding")]),v._v(" 方法。它不应使用短期或长期凭据机制。这是因为验证请求所需的工作量比简单处理请求所需的工作量要大。同样的原因，它不应使用 "),e("code",[v._v("ALTERNATE-SERVER")]),v._v(" 机制。它必须支持 "),e("code",[v._v("UDP")]),v._v(" 和 "),e("code",[v._v("TCP")]),v._v("。它可以支持基于 "),e("code",[v._v("TCP/TLS")]),v._v(" 的 "),e("code",[v._v("STUN")]),v._v("；然而，在这种基本操作模式下，"),e("code",[v._v("TLS")]),v._v(" 提供的安全性收益最小。它可以使用 "),e("code",[v._v("FINGERPRINT")]),v._v(" 机制，但不能要求使用。由于独立服务器只运行 "),e("code",[v._v("STUN")]),v._v("，"),e("code",[v._v("FINGERPRINT")]),v._v(" 不提供任何好处。要求使用它会破坏与 "),e("code",[v._v("RFC 3489")]),v._v(" 的兼容性，而这种兼容性在独立服务器中是可取的。独立 "),e("code",[v._v("STUN")]),v._v(" 服务器应支持与 ["),e("code",[v._v("RFC3489")]),v._v("] 客户端的向后兼容性，如第 12 节所述。")]),v._v(" "),e("p",[v._v("建议 "),e("code",[v._v("STUN")]),v._v(" 服务器管理员按照第 9 节的描述为这些服务器提供 "),e("code",[v._v("DNS")]),v._v(" 条目。")]),v._v(" "),e("p",[v._v("基本 "),e("code",[v._v("STUN")]),v._v(" 服务器本身并不是 "),e("code",[v._v("NAT")]),v._v(" 穿越的解决方案。然而，通过 "),e("code",[v._v("STUN")]),v._v(" 使用方法，它可以作为解决方案的一部分。这将在第 14 节进一步讨论。")]),v._v(" "),e("h1",{attrs:{id:"stun-使用方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stun-使用方法"}},[v._v("#")]),v._v(" "),e("code",[v._v("STUN")]),v._v(" 使用方法")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 本身并不是解决 "),e("code",[v._v("NAT")]),v._v(" 穿越问题的方案。相反，"),e("code",[v._v("STUN")]),v._v(' 定义了一个可以在更大解决方案中使用的工具。术语 "'),e("code",[v._v("STUN")]),v._v(' 使用方法" 是指将 '),e("code",[v._v("STUN")]),v._v(" 作为组件的任何解决方案。")]),v._v(" "),e("p",[v._v("在撰写本文时，已定义了三种 "),e("code",[v._v("STUN")]),v._v(" 使用方法：交互式连接建立 ("),e("code",[v._v("ICE")]),v._v(") ["),e("code",[v._v("MMUSIC-ICE")]),v._v("]，"),e("code",[v._v("SIP")]),v._v(" 的客户端发起连接 ["),e("code",[v._v("SIP-OUTBOUND")]),v._v("] 和 "),e("code",[v._v("NAT")]),v._v(" 行为发现 ["),e("code",[v._v("BEHAVE-NAT")]),v._v("]。未来可能会定义其他 "),e("code",[v._v("STUN")]),v._v(" 使用方法。")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 使用方法定义了 "),e("code",[v._v("STUN")]),v._v(" 如何实际使用 —— 何时发送请求，如何处理响应以及使用本文档中定义的哪些可选过程（或 "),e("code",[v._v("STUN")]),v._v(" 扩展中的过程）。使用方法还会定义：")]),v._v(" "),e("ul",[e("li",[v._v("使用哪些 "),e("code",[v._v("STUN")]),v._v(" 方法。")]),v._v(" "),e("li",[v._v("使用哪些认证和消息完整性机制。")]),v._v(" "),e("li",[v._v("根据 ["),e("code",[v._v("RFC4107")]),v._v("] 讨论，关于完整性机制的手动与自动密钥派生的考虑。")]),v._v(" "),e("li",[v._v("使用哪些机制来区分 "),e("code",[v._v("STUN")]),v._v(" 消息和其他消息。当 "),e("code",[v._v("STUN")]),v._v(" 在 "),e("code",[v._v("TCP")]),v._v(" 上运行时，可能需要一个帧机制。")]),v._v(" "),e("li",[e("code",[v._v("STUN")]),v._v(" 客户端如何确定 "),e("code",[v._v("STUN")]),v._v(" 服务器的 "),e("code",[v._v("IP")]),v._v(" 地址和端口。")]),v._v(" "),e("li",[v._v("是否需要向后兼容 "),e("code",[v._v("RFC3489")]),v._v("。")]),v._v(" "),e("li",[v._v("本文档中定义的哪些可选属性（如 "),e("code",[v._v("FINGERPRINT")]),v._v(" 和 "),e("code",[v._v("ALTERNATE-SERVER")]),v._v("）或其他扩展中的属性是必需的。")])]),v._v(" "),e("p",[v._v("此外，任何 "),e("code",[v._v("STUN")]),v._v(" 使用方法都必须考虑在该使用方法中使用 "),e("code",[v._v("STUN")]),v._v(" 的安全性问题。已知许多针对 "),e("code",[v._v("STUN")]),v._v(" 的攻击（参见本文档中的安全性考虑部分），任何使用方法都必须考虑如何阻止或减轻这些攻击。")]),v._v(" "),e("p",[v._v("最后，使用方法必须考虑其 "),e("code",[v._v("STUN")]),v._v(" 使用是否是 "),e("code",[v._v("NAT")]),v._v(" 穿越的单方面自主地址修复方法的一个示例，如果是，则需要解决 ["),e("code",[v._v("RFC3424")]),v._v("] 中提出的问题。")]),v._v(" "),e("h1",{attrs:{id:"stun-属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stun-属性"}},[v._v("#")]),v._v(" "),e("code",[v._v("STUN")]),v._v(" 属性")]),v._v(" "),e("p",[v._v("在 "),e("code",[v._v("STUN")]),v._v(" 报头之后是零个或多个属性。每个属性必须使用 "),e("code",[v._v("TLV")]),v._v(" 编码，包括一个 16 位类型，16 位长度,和值。每个 "),e("code",[v._v("STUN")]),v._v(" 属性必须以 32 位边界结束。如前所述，属性中的所有字段都是以最高有效位优先传输。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |         Type                  |            Length             |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                         Value (variable)                ....\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n")])])]),e("p",[v._v("长度字段中的值必须包含属性值部分的长度，以字节为单位。由于 "),e("code",[v._v("STUN")]),v._v(" 在 32 位边界上对齐属性，因此内容不是 4 字节的倍数的属性会用 1、2 或 3 个字节的填充进行填充，使其值包含 4 字节的倍数。填充位被忽略，可以是任意值。")]),v._v(" "),e("p",[e("strong",[v._v("任何属性类型可以在 "),e("code",[v._v("STUN")]),v._v(" 消息中出现多次。除非另有说明，出现的顺序很重要：接收器只需处理第一次出现的属性，重复的属性可以被接收器忽略。")])]),v._v(" "),e("p",[v._v("为了允许未来的规范修订在需要时添加新属性，属性空间分为两个范围。类型值在 "),e("code",[v._v("0x0000")]),v._v(" 和 "),e("code",[v._v("0x7FFF")]),v._v(" 之间的属性是理解所必需的属性("),e("code",[v._v("comprehension-required attributes")]),v._v(")，这意味着除非 "),e("code",[v._v("STUN")]),v._v(" 代理了解该属性，否则无法成功处理消息。类型值在 "),e("code",[v._v("0x8000")]),v._v(" 和 "),e("code",[v._v("0xFFFF")]),v._v(" 之间的属性是可选理解属性("),e("code",[v._v("comprehension-optional attributes")]),v._v(")，这意味着如果 "),e("code",[v._v("STUN")]),v._v(" 代理不了解这些属性，可以忽略它们。")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 属性类型的集合由 "),e("code",[v._v("IANA")]),v._v(" 维护。本规范定义的初始集合见第 18.2 节。")]),v._v(" "),e("p",[v._v("本节其余部分描述了本规范中定义的各种属性的格式。")]),v._v(" "),e("h2",{attrs:{id:"mapped-address"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mapped-address"}},[v._v("#")]),v._v(" "),e("code",[v._v("MAPPED-ADDRESS")])]),v._v(" "),e("p",[e("code",[v._v("MAPPED-ADDRESS")]),v._v(" 属性表示客户端的反射性传输地址。它包括一个 8 位地址族和一个 16 位端口，后面是表示 "),e("code",[v._v("IP")]),v._v(" 地址的固定长度值。如果地址族是 "),e("code",[v._v("IPv4")]),v._v("，则地址必须是 32 位。如果地址族是 "),e("code",[v._v("IPv6")]),v._v("，则地址必须是 128 位。所有字段必须以网络字节顺序。")]),v._v(" "),e("p",[e("code",[v._v("MAPPED-ADDRESS")]),v._v(" 属性的格式是：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |0 0 0 0 0 0 0 0|    Family     |           Port                |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |                                                               |\n      |                 Address (32 bits or 128 bits)                 |\n      |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n")])])]),e("p",[v._v("地址族可以取以下值：")]),v._v(" "),e("ul",[e("li",[v._v("0x01：IPv4")]),v._v(" "),e("li",[v._v("0x02：IPv6")])]),v._v(" "),e("p",[e("strong",[e("code",[v._v("MAPPED-ADDRESS")]),v._v(" 的前 8 位必须设置为 0，并且接收者必须忽略。这些位存在是为了在自然 32 位边界上对齐参数。")])]),v._v(" "),e("p",[v._v("此属性仅由服务器用于实现与 ["),e("code",[v._v("RFC3489")]),v._v("]客户端的向后兼容性。")]),v._v(" "),e("h2",{attrs:{id:"xor-mapped-address"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#xor-mapped-address"}},[v._v("#")]),v._v(" "),e("code",[v._v("XOR-MAPPED-ADDRESS")])]),v._v(" "),e("p",[e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 属性与 "),e("code",[v._v("MAPPED-ADDRESS")]),v._v(" 属性相同，只是反射性传输地址通过 "),e("code",[v._v("XOR")]),v._v(" 函数进行了混淆。")]),v._v(" "),e("p",[e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 的格式是：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("      0                   1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |x x x x x x x x|    Family     |         X-Port                |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |                X-Address (Variable)\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n")])])]),e("p",[e("code",[v._v("Family")]),v._v(" 表示 "),e("code",[v._v("IP")]),v._v(" 地址族，编码方式与 "),e("code",[v._v("MAPPED-ADDRESS")]),v._v(" 中的 "),e("code",[v._v("Family")]),v._v(" 相同。")]),v._v(" "),e("p",[e("code",[v._v("X-Port")]),v._v(" 通过获取以主机字节顺序表示的映射端口，与 "),e("code",[v._v("Magic cookie")]),v._v(" 的最高 16 位进行 "),e("code",[v._v("XOR")]),v._v(" 运算，然后将结果转换为网络字节顺序。如果 "),e("code",[v._v("IP")]),v._v(" 地址族是 "),e("code",[v._v("IPv4")]),v._v("，"),e("code",[v._v("X-Address")]),v._v(" 通过获取以主机字节顺序表示的映射 "),e("code",[v._v("IP")]),v._v(" 地址，与 "),e("code",[v._v("Magic cookie")]),v._v(" 进行 "),e("code",[v._v("XOR")]),v._v(" 运算，并将结果转换为网络字节顺序。如果 "),e("code",[v._v("IP")]),v._v(" 地址族是 "),e("code",[v._v("IPv6")]),v._v("，"),e("code",[v._v("X-Address")]),v._v(" 通过获取以主机字节顺序表示的映射 "),e("code",[v._v("IP")]),v._v(" 地址，与 "),e("code",[v._v("Magic cookie")]),v._v(" 和 96 位事务 "),e("code",[v._v("ID")]),v._v(" 的连接进行 "),e("code",[v._v("XOR")]),v._v(" 运算，然后将结果转换为网络字节顺序。")]),v._v(" "),e("p",[v._v("对属性值的前 8 位的编码和处理规则，处理属性多次出现的规则以及处理地址族的规则与 MAPPED-ADDRESS 相同。")]),v._v(" "),e("p",[v._v("注意："),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 和 "),e("code",[v._v("MAPPED-ADDRESS")]),v._v(" 仅在传输地址的编码上有区别。前者通过对传输地址与 "),e("code",[v._v("Magic cookie")]),v._v(" 进行异或运算进行编码。后者直接以二进制编码。"),e("code",[v._v("RFC3489")]),v._v(" 最初只指定了 "),e("code",[v._v("MAPPED-ADDRESS")]),v._v("。然而，部署经验发现，一些 "),e("code",[v._v("NAT")]),v._v(" 会重写包含 "),e("code",[v._v("NAT")]),v._v(" 公共 "),e("code",[v._v("IP")]),v._v(" 地址的 32 位二进制有效载荷，如 "),e("code",[v._v("STUN")]),v._v(" 的 "),e("code",[v._v("MAPPED-ADDRESS")]),v._v(" 属性，试图提供通用 "),e("code",[v._v("ALG")]),v._v(" 功能，但这种做法是错误的。这种行为干扰了 "),e("code",[v._v("STUN")]),v._v(" 的操作，并导致 "),e("code",[v._v("STUN")]),v._v(" 的消息完整性检查失败。")]),v._v(" "),e("blockquote",[e("p",[e("code",[v._v("XOR")]),v._v(" 运算，即异或运算，是一种二进制位运算。它对两个二进制位进行比较，当两个比较的位相同（都是 0 或都是 1）时，结果为 0；当两个比较的位不同（一个为 0，一个为 1）时，结果为 1。")])]),v._v(" "),e("h2",{attrs:{id:"username"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#username"}},[v._v("#")]),v._v(" "),e("code",[v._v("USERNAME")])]),v._v(" "),e("p",[e("strong",[e("code",[v._v("USERNAME")]),v._v(" 属性用于消息完整性。它识别用于消息完整性检查的用户名和密码组合。")])]),v._v(" "),e("p",[e("code",[v._v("USERNAME")]),v._v(" 的值是一个可变长度值。它必须包含一个少于 513 字节的 "),e("code",[v._v("UTF-8")]),v._v(" 编码序列（["),e("code",[v._v("RFC3629")]),v._v("]），并且必须经过 "),e("code",[v._v("SASLprep")]),v._v(" 处理（["),e("code",[v._v("RFC4013")]),v._v("]）。")]),v._v(" "),e("h2",{attrs:{id:"message-integrity"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#message-integrity"}},[v._v("#")]),v._v(" "),e("code",[v._v("MESSAGE-INTEGRITY")])]),v._v(" "),e("p",[e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性包含 "),e("code",[v._v("STUN")]),v._v(" 消息的 "),e("code",[v._v("HMAC-SHA1")]),v._v("（["),e("code",[v._v("RFC2104")]),v._v("]）。"),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性可以出现在任何类型的 "),e("code",[v._v("STUN")]),v._v(" 消息中。由于它使用 "),e("code",[v._v("SHA1")]),v._v(" 哈希，"),e("code",[v._v("HMAC")]),v._v(" 本身是 20 字节。"),e("strong",[v._v("作为 "),e("code",[v._v("HMAC")]),v._v(" 输入的文本是 "),e("code",[v._v("STUN")]),v._v(" 消息，包括头部，直至包括 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性之前的属性。")]),v._v(" 除 "),e("code",[v._v("FINGERPRINT")]),v._v(" 属性外（在 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 之后出现），代理必须忽略 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 之后的所有其他属性。")]),v._v(" "),e("p",[e("code",[v._v("HMAC")]),v._v(" 的密钥取决于使用长期凭证还是短期凭证。对于长期凭证，密钥为 16 字节：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v('key = MD5(username ":" realm ":" SASLprep(password))\n')])])]),e("p",[v._v("即，通过对以下五个字段进行连接并对结果进行 MD5 哈希来形成 16 字节密钥：")]),v._v(" "),e("ul",[e("li",[v._v("从 "),e("code",[v._v("USERNAME")]),v._v(" 属性中获取的用户名（去掉任何引号和尾随的空值，已经应用了 "),e("code",[v._v("SASLprep")]),v._v("）；")]),v._v(" "),e("li",[v._v("一个冒号；")]),v._v(" "),e("li",[v._v("去掉任何引号和尾随空值的领域；")]),v._v(" "),e("li",[v._v("一个冒号；")]),v._v(" "),e("li",[v._v("删除尾随的空值并使用 "),e("code",[v._v("SASLprep")]),v._v(" 处理的密码。")])]),v._v(" "),e("p",[v._v("例如，如果用户名是'"),e("code",[v._v("user")]),v._v("'，领域是'"),e("code",[v._v("realm")]),v._v("'，密码是'"),e("code",[v._v("pass")]),v._v("'，那么 16 字节的 "),e("code",[v._v("HMAC")]),v._v(" 密钥将是对字符串'"),e("code",[v._v("user:realm:pass")]),v._v("'进行 "),e("code",[v._v("MD5")]),v._v(" 哈希的结果，得到的哈希值为 0x8493fbc53ba582fb4c044c456bdc40eb。")]),v._v(" "),e("p",[v._v("对于短期凭证：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("key = SASLprep(password)\n")])])]),e("p",[v._v("其中 "),e("code",[v._v("MD5")]),v._v(" 在（["),e("code",[v._v("RFC1321")]),v._v("]）中定义，"),e("code",[v._v("SASLprep()")]),v._v("在（["),e("code",[v._v("RFC4013")]),v._v("]）中定义。")]),v._v(" "),e("p",[v._v("当与长期凭证一起使用时，密钥的结构有助于在同时使用 "),e("code",[v._v("SIP")]),v._v(" 的系统中部署。通常，使用 "),e("code",[v._v("SIP")]),v._v(" 摘要认证机制的 "),e("code",[v._v("SIP")]),v._v(" 系统并不实际在数据库中存储密码。相反，它们存储一个称为 "),e("code",[v._v("H(A1)")]),v._v("的值，该值等于上面定义的密钥。")]),v._v(" "),e("p",[v._v("根据上述规则，用于构建 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 的哈希包括 "),e("code",[v._v("STUN")]),v._v(" 消息头中的长度字段。在执行哈希之前，必须将 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性插入到消息中（带有虚拟内容）。然后，长度必须设置为指向消息的长度，直至包括 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性本身，但不包括其后的任何属性。一旦计算完成，就可以填充 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性的值，并将 "),e("code",[v._v("STUN")]),v._v(" 头中的长度值设置为正确值——整个消息的长度。同样，在验证 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 时，应在计算 "),e("code",[v._v("HMAC")]),v._v(" 之前调整长度字段，使其指向 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性的结尾。在 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 之后出现的属性（如 "),e("code",[v._v("FINGERPRINT")]),v._v("）需要进行此类调整。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("在执行哈希之前，将MESSAGE-INTEGRITY属性插入到消息中（带有虚拟内容）。\n这意味着，在计算HMAC哈希之前，您需要将MESSAGE-INTEGRITY属性添加到STUN消息的属性列表中，\n但不需要立即填充实际的哈希值。您可以先用一些占位符填充。\n\n设置长度以指向消息的长度，直至包括MESSAGE-INTEGRITY属性本身，但不包括其后的任何属性。\n在计算HMAC哈希时，您需要调整STUN头部中的长度字段，使其表示从消息开始到\nMESSAGE-INTEGRITY属性（包括该属性）的长度。这样，哈希计算将基于截至\nMESSAGE-INTEGRITY属性的消息内容。\n\n计算HMAC哈希值并填充MESSAGE-INTEGRITY属性的值。\n使用调整后的消息长度，您可以计算HMAC哈希值，然后将该值填充到MESSAGE-INTEGRITY属性中。\n\n将STUN头中的长度值设置为整个消息的长度。\n完成HMAC哈希计算并填充MESSAGE-INTEGRITY属性后，您需要将STUN头部中的长度字段设置\n为整个消息的实际长度，包括MESSAGE-INTEGRITY属性之后的所有属性。\n\n在验证MESSAGE-INTEGRITY时，应在计算HMAC之前调整长度字段，使其指向\nMESSAGE-INTEGRITY属性的结尾。\n\n当接收方验证STUN消息的完整性时，也需要进行类似的调整。在计算HMAC哈希以验证消息之前，\n应将长度字段调整为截至MESSAGE-INTEGRITY属性的消息长度。\n这样，接收方可以正确计算和比较哈希值以验证消息的完整性。\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("SASLprep的主要目的是在使用Unicode字符串进行身份验证之前，\n确保字符串在不同的系统和协议之间具有一致的表示形式。SASLprep对输入字符串执行以下操作：\n\n1. 将字符串规范化：这意味着将具有多种等效表示形式的Unicode字符转换为统一的标准形式，以消除歧义。\n2. 删除非打印字符：这些字符通常在文本处理中没有实际意义，可能导致安全问题。\n3. 映射和替换字符：将一些字符映射到特定的替换字符或删除它们，以确保字符串在不同环境中的一致性。\n\n在处理用户名和密码等敏感信息时，使用SASLprep是很重要的，\n因为它有助于防止在不同系统和实现之间产生歧义，从而增加了安全性。\n")])])]),e("h2",{attrs:{id:"指纹-fingerprint"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#指纹-fingerprint"}},[v._v("#")]),v._v(" 指纹（"),e("code",[v._v("FINGERPRINT")]),v._v("）")]),v._v(" "),e("p",[e("code",[v._v("FINGERPRINT")]),v._v(" 属性可以出现在所有的 "),e("code",[v._v("STUN")]),v._v(" 消息中。该属性的值是通过计算 "),e("code",[v._v("STUN")]),v._v(" 消息（不包括 "),e("code",[v._v("FINGERPRINT")]),v._v(" 属性本身）的 "),e("code",[v._v("CRC-32")]),v._v("，然后与 32 位值 "),e("code",[v._v("0x5354554E")]),v._v(" 进行异或操作得到的（在应用程序数据包也使用 "),e("code",[v._v("CRC-32")]),v._v(" 的情况下，异或操作是有帮助的）。这里使用的 32 位 "),e("code",[v._v("CRC")]),v._v(" 是在 ["),e("code",[v._v("ITU.V42.2002")]),v._v("]中定义的，生成多项式为 x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1。"),e("strong",[v._v("当 "),e("code",[v._v("FINGERPRINT")]),v._v(" 属性存在时，它必须是消息中的最后一个属性，因此会在 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性之后出现。")])]),v._v(" "),e("p",[e("code",[v._v("FINGERPRINT")]),v._v(" 属性有助于区分 "),e("code",[v._v("STUN")]),v._v(" 数据包和其他协议的数据包。参见第 8 节。")]),v._v(" "),e("p",[v._v("与 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 一样，"),e("code",[v._v("FINGERPRINT")]),v._v(" 属性中使用的 "),e("code",[v._v("CRC")]),v._v(" 涵盖了 "),e("code",[v._v("STUN")]),v._v(" 消息头中的长度字段。因此，在计算 "),e("code",[v._v("CRC")]),v._v(" 之前，这个值必须是正确的，并将 "),e("code",[v._v("CRC")]),v._v(" 属性作为消息长度的一部分。在消息中使用 "),e("code",[v._v("FINGERPRINT")]),v._v(" 属性时，首先将属性放入消息中并赋予一个虚拟值，然后计算 "),e("code",[v._v("CRC")]),v._v("，最后更新属性的值。如果还存在 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性，那么在计算 "),e("code",[v._v("CRC")]),v._v(" 之前，必须先使用正确的消息完整性值，因为 "),e("code",[v._v("CRC")]),v._v(" 是在 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性的值上计算的。")]),v._v(" "),e("h2",{attrs:{id:"错误代码-error-code"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误代码-error-code"}},[v._v("#")]),v._v(" 错误代码（"),e("code",[v._v("ERROR-CODE")]),v._v("）")]),v._v(" "),e("p",[v._v("错误代码属性用于错误响应消息中。它包含一个范围在 300 到 699 之间的数字错误代码值以及一个以 "),e("code",[v._v("UTF-8")]),v._v(" 编码的文本原因短语["),e("code",[v._v("RFC3629")]),v._v("]，并且在代码分配和语义上与 "),e("code",[v._v("SIP")]),v._v(" ["),e("code",[v._v("RFC3261")]),v._v("]和 "),e("code",[v._v("HTTP")]),v._v(" ["),e("code",[v._v("RFC2616")]),v._v("]一致。原因短语是供用户阅读的，可以是适合错误代码的任何内容。为已定义的错误代码推荐的原因短语已包含在 "),e("code",[v._v("IANA")]),v._v(" 的错误代码注册表中。原因短语必须是少于 128 个字符（最多可达 763 字节）的 "),e("code",[v._v("UTF-8")]),v._v(" 编码序列["),e("code",[v._v("RFC3629")]),v._v("]。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |           Reserved, should be 0         |Class|     Number    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |      Reason Phrase (variable)                                ..\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n")])])]),e("p",[v._v("为了便于处理，错误代码的类别（百位数）与代码的其他部分分开编码，如图所示。")]),v._v(" "),e("p",[v._v("保留位应为 0，用于在 32 位边界上对齐。接收者必须忽略这些位。类别表示错误代码的百位数字。该值必须在 3 到 6 之间。数字表示错误代码模 100，其值必须在 0 到 99 之间。")]),v._v(" "),e("p",[v._v("定义了以下错误代码以及相应的推荐原因短语：")]),v._v(" "),e("p",[v._v("300 尝试替代（"),e("code",[v._v("Try Alternate")]),v._v("）：客户端应联系备用服务器处理此请求。此错误响应仅在请求中包含 "),e("code",[v._v("USERNAME")]),v._v(" 属性和有效的 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性时才发送；否则，禁止发送并建议使用错误代码 400（"),e("code",[v._v("Bad Request")]),v._v("）。此错误响应必须使用 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性进行保护，接收者在将自己重定向到备用服务器之前必须验证此响应的 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v("。")]),v._v(" "),e("p",[v._v("注意：未为 300 响应生成和验证消息完整性将允许在路径上的攻击者伪造 300 响应，从而导致后续的 "),e("code",[v._v("STUN")]),v._v(" 消息发送给受害者。")]),v._v(" "),e("p",[v._v("400 错误请求（"),e("code",[v._v("Bad Request")]),v._v("）：请求格式错误。客户端不应在未对先前尝试进行修改的情况下重试请求。服务器可能无法为此错误生成有效的 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v("，因此客户端不应期望在此响应上看到有效的 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 属性。")]),v._v(" "),e("p",[v._v("401 未授权（"),e("code",[v._v("Unauthorized")]),v._v("）：请求中未包含正确的凭据。客户端应使用正确的凭据重试请求。")]),v._v(" "),e("p",[v._v("420 未知属性（"),e("code",[v._v("Unknown Attribute")]),v._v("）：服务器收到了一个包含未理解的需理解属性的 "),e("code",[v._v("STUN")]),v._v(" 包。服务器必须将此未知属性放入其错误响应的 "),e("code",[v._v("UNKNOWN-ATTRIBUTE")]),v._v(" 属性中。")]),v._v(" "),e("p",[v._v("438 过期的随机数（"),e("code",[v._v("Stale Nonce")]),v._v("）：客户端使用的 "),e("code",[v._v("NONCE")]),v._v(" 已不再有效。客户端应使用响应中提供的 "),e("code",[v._v("NONCE")]),v._v(" 进行重试。")]),v._v(" "),e("p",[v._v("500 服务器错误（"),e("code",[v._v("Server Error")]),v._v("）：服务器遇到临时错误。客户端应再次尝试。")]),v._v(" "),e("h2",{attrs:{id:"realm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#realm"}},[v._v("#")]),v._v(" "),e("code",[v._v("REALM")])]),v._v(" "),e("p",[e("code",[v._v("REALM")]),v._v(" 属性可能出现在请求和响应中。它包含符合 ["),e("code",[v._v("RFC3261")]),v._v(']中描述的"'),e("code",[v._v("realm-value")]),v._v('"语法的文本，但不包括双引号及其周围的空白。也就是说，它是一个未加引号的 '),e("code",[v._v("realm-value")]),v._v("（因此是一系列 "),e("code",[v._v("qdtext")]),v._v(" 或 "),e("code",[v._v("quoted-pair")]),v._v("）。它必须是一个使用 "),e("code",[v._v("SASLprep")]),v._v("处理过的、长度少于 128 个字符（最多可以达到 763 字节）的 "),e("code",[v._v("UTF-8")]),v._v("编码序列。")]),v._v(" "),e("p",[v._v("请求中 "),e("code",[v._v("REALM")]),v._v(" 属性的存在表明正在使用长期凭据进行身份验证。在某些错误响应中出现表明服务器希望客户端使用长期凭据进行身份验证。")]),v._v(" "),e("h2",{attrs:{id:"nonce"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nonce"}},[v._v("#")]),v._v(" "),e("code",[v._v("NONCE")])]),v._v(" "),e("p",[e("code",[v._v("NONCE")]),v._v(" 属性可能出现在请求和响应中。它包含一系列 "),e("code",[v._v("qdtext")]),v._v(" 或 "),e("code",[v._v("quoted-pair")]),v._v("，这些在 ["),e("code",[v._v("RFC3261")]),v._v("]中有定义。请注意，这意味着 "),e("code",[v._v("NONCE")]),v._v(" 属性实际上不包含引号字符。关于服务器中 "),e("code",[v._v("nonce")]),v._v(" 值的选择，请参阅 ["),e("code",[v._v("RFC2617")]),v._v("]的第 4.3 节。它必须少于 128 个字符（最多可以达到 763 字节）。")]),v._v(" "),e("blockquote",[e("p",[e("code",[v._v("NONCE")]),v._v("（随机数）在 "),e("code",[v._v("STUN")]),v._v(" 协议中的主要作用是为了增加安全性，防止重放攻击。当 "),e("code",[v._v("STUN")]),v._v(" 服务器要求客户端使用长期凭证进行身份验证时，它会在某些错误响应中包含一个 "),e("code",[v._v("NONCE")]),v._v(" 属性。客户端需要在后续的请求中包含此 "),e("code",[v._v("NONCE")]),v._v(" 值，以向服务器证明自己具有合法的凭证。这样，服务器可以确保客户端的请求是最新的，而非之前捕获的旧请求被重新发送。通过这种方式，"),e("code",[v._v("NONCE")]),v._v(" 有助于确保 "),e("code",[v._v("STUN")]),v._v(" 协议的安全性。")])]),v._v(" "),e("h2",{attrs:{id:"unknown-attributes-未知属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#unknown-attributes-未知属性"}},[v._v("#")]),v._v(" "),e("code",[v._v("UNKNOWN-ATTRIBUTES")]),v._v("（未知属性）")]),v._v(" "),e("p",[e("code",[v._v("UNKNOWN-ATTRIBUTES")]),v._v(" 属性仅出现在错误响应中，当 "),e("code",[v._v("ERROR-CODE")]),v._v(" 属性中的响应代码为 420 时。该属性包含一系列 16 位值，每个值表示服务器无法理解的属性类型。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("       0                   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |      Attribute 1 Type           |     Attribute 2 Type        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |      Attribute 3 Type           |     Attribute 4 Type    ...\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n")])])]),e("p",[v._v("注意：在["),e("code",[v._v("RFC3489")]),v._v("]中，通过复制最后一个属性将该字段填充为 32 位。在本规范的此版本中，改为使用属性的正常填充规则。")]),v._v(" "),e("h2",{attrs:{id:"software-软件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#software-软件"}},[v._v("#")]),v._v(" "),e("code",[v._v("SOFTWARE")]),v._v("（软件）")]),v._v(" "),e("p",[e("code",[v._v("SOFTWARE")]),v._v(" 属性包含了发送消息的代理所使用软件的文本描述。它由客户端和服务器使用。其值应包含制造商和版本号。该属性对协议的操作没有影响，仅作为诊断和调试工具使用。"),e("code",[v._v("SOFTWARE")]),v._v(" 的值是可变长度的。它必须是一个 "),e("code",[v._v("UTF-8")]),v._v(" 编码的序列，长度小于 128 个字符（最长可达 763 字节）。")]),v._v(" "),e("h2",{attrs:{id:"alternate-server-备用服务器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#alternate-server-备用服务器"}},[v._v("#")]),v._v(" "),e("code",[v._v("ALTERNATE-SERVER")]),v._v("（备用服务器）")]),v._v(" "),e("p",[v._v("备用服务器表示一个不同的 "),e("code",[v._v("STUN")]),v._v(" 服务器的替代传输地址，"),e("code",[v._v("STUN")]),v._v(" 客户端应尝试连接该地址。它的编码方式与 "),e("code",[v._v("MAPPED-ADDRESS")]),v._v(" 相同，因此通过 "),e("code",[v._v("IP")]),v._v(" 地址引用单个服务器。"),e("code",[v._v("IP")]),v._v(" 地址族必须与请求的源 "),e("code",[v._v("IP")]),v._v(" 地址相同。")]),v._v(" "),e("h1",{attrs:{id:"安全性考虑"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#安全性考虑"}},[v._v("#")]),v._v(" 安全性考虑")]),v._v(" "),e("h2",{attrs:{id:"针对协议的攻击"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#针对协议的攻击"}},[v._v("#")]),v._v(" 针对协议的攻击")]),v._v(" "),e("h3",{attrs:{id:"外部攻击"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#外部攻击"}},[v._v("#")]),v._v(" 外部攻击")]),v._v(" "),e("p",[v._v("攻击者可能会尝试在传输过程中修改 "),e("code",[v._v("STUN")]),v._v(" 消息，以导致 "),e("code",[v._v("STUN")]),v._v(" 操作失败。通过使用短期或长期凭据的消息完整性机制，可以检测到这些攻击，无论是针对请求还是响应。当然，一旦检测到，被操纵的数据包将被丢弃，导致 "),e("code",[v._v("STUN")]),v._v(" 事务实际上失败。这种攻击仅可能由在路径上的攻击者实施。")]),v._v(" "),e("p",[v._v("攻击者可以观察但不能修改传输中的 "),e("code",[v._v("STUN")]),v._v(" 消息（例如，出现在共享访问介质上的攻击者，如 "),e("code",[v._v("Wi-Fi")]),v._v("），可以看到 "),e("code",[v._v("STUN")]),v._v(" 请求，然后立即发送 "),e("code",[v._v("STUN")]),v._v(" 响应，通常是错误响应，以破坏 "),e("code",[v._v("STUN")]),v._v(" 处理。这种攻击也可以通过使用 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 来防止。然而，某些错误响应，特别是与认证相关的响应，无法通过 "),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v(" 保护。当 "),e("code",[v._v("STUN")]),v._v(" 本身在安全传输协议（如 "),e("code",[v._v("TLS")]),v._v("）上运行时，这些攻击被完全缓解。")]),v._v(" "),e("p",[v._v("根据 "),e("code",[v._v("STUN")]),v._v(" 的使用情况，这些攻击可能影响较小，因此不需要消息完整性来减轻。例如，当 "),e("code",[v._v("STUN")]),v._v(" 用于基本 "),e("code",[v._v("STUN")]),v._v(" 服务器以发现用于 "),e("code",[v._v("ICE")]),v._v(" 的服务器反射候选时，不需要认证和消息完整性，因为这些攻击在连接检查阶段被检测到。然而，为了保证 "),e("code",[v._v("ICE")]),v._v(" 整体的正常运行，连接检查本身需要保护。如第 14 节所述，"),e("code",[v._v("STUN")]),v._v(" 用法描述了何时需要认证和消息完整性。")]),v._v(" "),e("p",[v._v("由于 "),e("code",[v._v("STUN")]),v._v(" 使用共享密钥的 "),e("code",[v._v("HMAC")]),v._v(" 进行认证和完整性保护，因此容易受到离线字典攻击。当使用认证时，应该使用强密码，以避免容易受到离线字典攻击。使用 "),e("code",[v._v("TLS")]),v._v(" 保护通道本身可以缓解这些攻击。然而，"),e("code",[v._v("STUN")]),v._v(" 通常在 "),e("code",[v._v("UDP")]),v._v(" 上运行，在这些情况下，强密码是防止这些攻击的唯一方法。")]),v._v(" "),e("h3",{attrs:{id:"内部攻击"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内部攻击"}},[v._v("#")]),v._v(" 内部攻击")]),v._v(" "),e("p",[v._v("一个恶意客户端可能会尝试通过向服务器发送大量 "),e("code",[v._v("STUN")]),v._v(" 请求来发起 "),e("code",[v._v("DoS")]),v._v(" 攻击。幸运的是，"),e("code",[v._v("STUN")]),v._v(" 请求可以由服务器无状态地处理，使得这种攻击难以发起。")]),v._v(" "),e("p",[v._v("恶意客户端可能使用 "),e("code",[v._v("STUN")]),v._v(" 服务器作为反射器，向其发送伪造源 "),e("code",[v._v("IP")]),v._v(" 地址和端口的请求。在这种情况下，响应将被发送到该源 "),e("code",[v._v("IP")]),v._v(" 和端口。这种攻击没有放大数据包数量（"),e("code",[v._v("STUN")]),v._v(" 服务器为客户端发送的每个数据包发送一个数据包），尽管响应数据量略有增加，因为 "),e("code",[v._v("STUN")]),v._v(" 响应通常比请求大。这种攻击可通过入口源地址过滤来缓解。")]),v._v(" "),e("p",[v._v("通过 "),e("code",[v._v("SOFTWARE")]),v._v(" 属性揭示代理的特定软件版本可能使其更容易受到针对已知包含安全漏洞软件的攻击。实现者应将使用 "),e("code",[v._v("SOFTWARE")]),v._v(" 属性作为可配置选项。")]),v._v(" "),e("h2",{attrs:{id:"影响使用的攻击"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#影响使用的攻击"}},[v._v("#")]),v._v(" 影响使用的攻击")]),v._v(" "),e("p",[v._v("本节列举了可能针对 "),e("code",[v._v("STUN")]),v._v(" 使用发起的攻击。每个 "),e("code",[v._v("STUN")]),v._v(" 使用都必须考虑这些攻击是否适用于它，如果适用，需要讨论相应的对策。\n本节中的大部分攻击都围绕攻击者修改 "),e("code",[v._v("STUN")]),v._v(" 客户端通过绑定请求/响应事务所学到的反射地址展开。由于反射地址的使用取决于具体使用场景，因此这些攻击的适用性和补救措施是特定于使用场景的。在常见情况下，路径上的攻击者很容易修改反射地址。例如，"),e("code",[v._v("STUN")]),v._v(" 直接在 "),e("code",[v._v("UDP")]),v._v(" 上运行的常见情况。在这种情况下，路径上的攻击者可以在绑定请求到达 "),e("code",[v._v("STUN")]),v._v(" 服务器之前修改源 "),e("code",[v._v("IP")]),v._v(" 地址。然后，"),e("code",[v._v("STUN")]),v._v(" 服务器会将此 "),e("code",[v._v("IP")]),v._v(" 地址返回到客户端的 "),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 属性中，并将响应发送回该（伪造的）"),e("code",[v._v("IP")]),v._v(" 地址和端口。如果攻击者还可以拦截此响应，它可以将其引导回客户端。由于消息完整性值无法覆盖源 "),e("code",[v._v("IP")]),v._v(" 地址（因为介入的 "),e("code",[v._v("NAT")]),v._v(" 必须能够修改此值），所以使用消息完整性检查来防止此攻击是不可能的。相反，防止下面列出的攻击的一种解决方案是让客户端验证所学到的反射地址，就像在 "),e("code",[v._v("ICE")]),v._v("["),e("code",[v._v("MMUSIC-ICE")]),v._v("]中所做的那样。其他用途可能使用其他方法来防止这些攻击。")]),v._v(" "),e("h3",{attrs:{id:"攻击-i-针对目标的分布式拒绝服务-ddos-攻击"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#攻击-i-针对目标的分布式拒绝服务-ddos-攻击"}},[v._v("#")]),v._v(" 攻击 I：针对目标的分布式拒绝服务（"),e("code",[v._v("DDoS")]),v._v("）攻击")]),v._v(" "),e("p",[v._v("在这种攻击中，攻击者为一个或多个客户端提供指向预期目标的伪造反射地址。这会欺骗 "),e("code",[v._v("STUN")]),v._v(" 客户端，使它们认为自己的反射地址与目标的地址相同。如果客户端将该反射地址分发出去以便在其上接收流量（例如，在 "),e("code",[v._v("SIP")]),v._v(" 消息中），流量将被发送到目标。当与使用 "),e("code",[v._v("STUN")]),v._v(" 启用多媒体应用的客户端一起使用时，这种攻击可能会产生大量放大效果。然而，这种攻击只能针对那些 "),e("code",[v._v("STUN")]),v._v(" 服务器到目标的数据包通过攻击者的目标发起，从而限制了可能的情况。")]),v._v(" "),e("h3",{attrs:{id:"攻击-ii-使客户端沉默"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#攻击-ii-使客户端沉默"}},[v._v("#")]),v._v(" 攻击 II：使客户端沉默")]),v._v(" "),e("p",[v._v("在这种攻击中，攻击者向 "),e("code",[v._v("STUN")]),v._v(" 客户端提供一个伪造的反射地址。它提供的反射地址是一个指向无路由的传输地址。因此，当客户端分发反射地址时，它不会收到任何它期望接收的数据包。对于攻击者来说，这种利用并不是很有趣。它影响的是单个客户端，而这通常不是攻击者想要的目标。此外，任何能够发起攻击的攻击者也可以通过其他方式拒绝对客户端的服务，例如阻止客户端接收来自 "),e("code",[v._v("STUN")]),v._v(" 服务器或 "),e("code",[v._v("DHCP")]),v._v(" 服务器的任何响应。与第 16.2.1 节中的攻击一样，只有当攻击者处于从 "),e("code",[v._v("STUN")]),v._v(" 服务器发送到这个未使用的 "),e("code",[v._v("IP")]),v._v(" 地址的数据包的路径上时，这种攻击才有可能。")]),v._v(" "),e("h3",{attrs:{id:"攻击-iii-扮演客户端身份"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#攻击-iii-扮演客户端身份"}},[v._v("#")]),v._v(" 攻击 III：扮演客户端身份")]),v._v(" "),e("p",[v._v("这种攻击与攻击 II 相似。然而，伪造的反射地址指向攻击者本身。这使得攻击者能够接收原本发送给客户端的流量。")]),v._v(" "),e("h3",{attrs:{id:"攻击-iv-窃听"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#攻击-iv-窃听"}},[v._v("#")]),v._v(" 攻击 IV：窃听")]),v._v(" "),e("p",[v._v("在这种攻击中，攻击者强迫客户端使用指向自己的反射地址。然后，攻击者将收到的任何数据包转发给客户端。这种攻击将使攻击者能够观察发送给客户端的所有数据包。然而，为了发起这种攻击，攻击者必须已经能够观察到来自客户端到 "),e("code",[v._v("STUN")]),v._v(" 服务器的数据包。在大多数情况下（例如当攻击从接入网络发起时），这意味着攻击者已经可以观察到发送给客户端的数据包。因此，这种攻击仅对路径上的攻击者有用，可以观察从客户端到 "),e("code",[v._v("STUN")]),v._v(" 服务器的流量，但通常无法观察到被路由到客户端的数据包。")]),v._v(" "),e("h2",{attrs:{id:"哈希敏捷性计划"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#哈希敏捷性计划"}},[v._v("#")]),v._v(" 哈希敏捷性计划")]),v._v(" "),e("p",[v._v("本规范使用 "),e("code",[v._v("HMAC-SHA-1")]),v._v(" 计算消息完整性。如果在以后的某个时候，"),e("code",[v._v("HMAC-SHA-1")]),v._v(" 被发现受到了损害，将应用以下补救措施。\n我们将定义一个 "),e("code",[v._v("STUN")]),v._v(" 扩展，引入一个新的消息完整性属性，使用新的哈希计算。客户端需要在其请求或指示中包含新旧消息完整性属性。新服务器将使用新的消息完整性属性，旧服务器将使用旧的。在混合实现部署的过渡期之后，另一个规范将废弃旧的消息完整性属性，客户端将停止在请求中包含它。\n还需要注意的是，"),e("code",[v._v("HMAC")]),v._v(" 是使用一个密钥完成的，该密钥本身是使用用户密码的 "),e("code",[v._v("MD5")]),v._v(" 计算的。选择 "),e("code",[v._v("MD5")]),v._v(" 哈希是因为存在存储以该形式的密码的遗留数据库。如果将来的工作发现 "),e("code",[v._v("HMAC")]),v._v(" 对 "),e("code",[v._v("MD5")]),v._v(" 输入不安全，需要使用不同的哈希，也可以使用此计划进行更改。然而，这将需要管理员重新填充他们的数据库。")]),v._v(" "),e("h1",{attrs:{id:"iab-考虑因素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#iab-考虑因素"}},[v._v("#")]),v._v(" "),e("code",[v._v("IAB")]),v._v(" 考虑因素")]),v._v(" "),e("p",[e("code",[v._v("IAB")]),v._v("（互联网架构委员会）已经研究了单边自我地址修正（"),e("code",[v._v("Unilateral Self-Address Fixing")]),v._v("，"),e("code",[v._v("UNSAF")]),v._v("）问题，这是一个通用过程，通过协作协议反射机制（["),e("code",[v._v("RFC3424")]),v._v("]），客户端试图在 "),e("code",[v._v("NAT")]),v._v(" 另一侧的另一个领域中确定其地址。如果一个代理位于 "),e("code",[v._v("NAT")]),v._v(" 后面，另一个代理位于 "),e("code",[v._v("NAT")]),v._v(" 的公共侧，则 "),e("code",[v._v("STUN")]),v._v(" 可以使用绑定请求/响应事务来执行此功能。\n"),e("code",[v._v("IAB")]),v._v(" 规定为此目的开发的协议必须记录一系列特定的考虑因素。因为一些 "),e("code",[v._v("STUN")]),v._v(" 使用提供了 "),e("code",[v._v("UNSAF")]),v._v(" 功能（例如 "),e("code",[v._v("ICE")]),v._v(" ["),e("code",[v._v("MMUSIC-ICE")]),v._v("]），而其他的则没有（例如 "),e("code",[v._v("SIP Outbound")]),v._v(" ["),e("code",[v._v("SIP-OUTBOUND")]),v._v("]），这些考虑因素的答案需要由使用本身来解决。")]),v._v(" "),e("h1",{attrs:{id:"iana-考虑因素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#iana-考虑因素"}},[v._v("#")]),v._v(" "),e("code",[v._v("IANA")]),v._v(" 考虑因素")]),v._v(" "),e("p",[e("code",[v._v("IANA")]),v._v(' 已经创建了三个新的注册表：一个 "'),e("code",[v._v("STUN")]),v._v(' 方法注册表"（'),e("code",[v._v("STUN Methods Registry")]),v._v('），一个 "'),e("code",[v._v("STUN")]),v._v(' 属性注册表"（'),e("code",[v._v("STUN Attributes Registry")]),v._v('），和一个 "'),e("code",[v._v("STUN")]),v._v(' 错误代码注册表"（'),e("code",[v._v("STUN Error Codes Registry")]),v._v("）。"),e("code",[v._v("IANA")]),v._v(" 还将为 "),e("code",[v._v("STUN")]),v._v(" 分配的 "),e("code",[v._v("IANA")]),v._v(' 端口名称从 "'),e("code",[v._v("nat-stun-port")]),v._v('" 更改为 "'),e("code",[v._v("stun")]),v._v('"。')]),v._v(" "),e("h1",{attrs:{id:"stun-方法注册表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stun-方法注册表"}},[v._v("#")]),v._v(" "),e("code",[v._v("STUN")]),v._v(" 方法注册表")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 方法是一个在 0x000 - 0xFFF 范围内的十六进制数字。将 "),e("code",[v._v("STUN")]),v._v(" 方法编码到 "),e("code",[v._v("STUN")]),v._v(" 消息中的方法在第 6 节中描述。\n最初的 STUN 方法是：")]),v._v(" "),e("ul",[e("li",[v._v("0x000:（保留）")]),v._v(" "),e("li",[v._v("0x001: 绑定（"),e("code",[v._v("Binding")]),v._v("）")]),v._v(" "),e("li",[v._v("0x002:（保留；曾为 "),e("code",[v._v("SharedSecret")]),v._v("）")])]),v._v(" "),e("p",[v._v("在 0x000 - 0x7FF 范围内的 "),e("code",[v._v("STUN")]),v._v(" 方法由 "),e("code",[v._v("IETF")]),v._v(" 审查（RFC5226）分配。在 0x800 - 0xFFF 范围内的 "),e("code",[v._v("STUN")]),v._v(" 方法由指定专家（"),e("code",[v._v("RFC5226")]),v._v("）分配。专家的职责是验证所选代码点是否未在使用中，以及请求是否不是一个异常大量的代码点。对扩展本身的技术审查超出了指定专家职责范围。")]),v._v(" "),e("h2",{attrs:{id:"stun-属性注册表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stun-属性注册表"}},[v._v("#")]),v._v(" "),e("code",[v._v("STUN")]),v._v(" 属性注册表")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 属性类型是一个在 0x0000 - 0xFFFF 范围内的十六进制数字。在 0x0000 - 0x7FFF 范围内的 "),e("code",[v._v("STUN")]),v._v(" 属性类型被视为理解所必需的（"),e("code",[v._v("comprehension-required")]),v._v("）；在 0x8000 - 0xFFFF 范围内的 "),e("code",[v._v("STUN")]),v._v(" 属性类型被视为理解可选的（"),e("code",[v._v("comprehension-optional``）。STUN")]),v._v(" 代理对未知的理解所必需的属性和理解可选的属性的处理方式不同。")]),v._v(" "),e("p",[v._v("初始 "),e("code",[v._v("STUN")]),v._v(" 属性类型如下：")]),v._v(" "),e("p",[v._v("理解所必需范围（0x0000-0x7FFF）：")]),v._v(" "),e("ul",[e("li",[v._v("0x0000: (保留)")]),v._v(" "),e("li",[v._v("0x0001: 映射地址（"),e("code",[v._v("MAPPED-ADDRESS")]),v._v("）")]),v._v(" "),e("li",[v._v("0x0002: (保留；曾为 "),e("code",[v._v("RESPONSE-ADDRESS")]),v._v(")")]),v._v(" "),e("li",[v._v("0x0003: (保留；曾为 "),e("code",[v._v("CHANGE-ADDRESS")]),v._v(")")]),v._v(" "),e("li",[v._v("0x0004: (保留；曾为 "),e("code",[v._v("SOURCE-ADDRESS")]),v._v(")")]),v._v(" "),e("li",[v._v("0x0005: (保留；曾为 "),e("code",[v._v("CHANGED-ADDRESS")]),v._v(")")]),v._v(" "),e("li",[v._v("0x0006: 用户名（"),e("code",[v._v("USERNAME")]),v._v("）")]),v._v(" "),e("li",[v._v("0x0007: (保留；曾为 "),e("code",[v._v("PASSWORD")]),v._v(")")]),v._v(" "),e("li",[v._v("0x0008: 消息完整性（"),e("code",[v._v("MESSAGE-INTEGRITY")]),v._v("）")]),v._v(" "),e("li",[v._v("0x0009: 错误代码（"),e("code",[v._v("ERROR-CODE")]),v._v("）")]),v._v(" "),e("li",[v._v("0x000A: 未知属性（"),e("code",[v._v("UNKNOWN-ATTRIBUTES")]),v._v("）")]),v._v(" "),e("li",[v._v("0x000B: (保留；曾为 "),e("code",[v._v("REFLECTED-FROM")]),v._v(")")]),v._v(" "),e("li",[v._v("0x0014: 领域（"),e("code",[v._v("REALM")]),v._v("）")]),v._v(" "),e("li",[v._v("0x0015: 随机数（"),e("code",[v._v("NONCE")]),v._v("）")]),v._v(" "),e("li",[v._v("0x0020: "),e("code",[v._v("XOR")]),v._v("-映射地址（"),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v("）")])]),v._v(" "),e("p",[v._v("理解可选范围（0x8000-0xFFFF）：")]),v._v(" "),e("ul",[e("li",[v._v("0x8022: 软件（"),e("code",[v._v("SOFTWARE")]),v._v("）")]),v._v(" "),e("li",[v._v("0x8023: 备用服务器（"),e("code",[v._v("ALTERNATE-SERVER")]),v._v("）")]),v._v(" "),e("li",[v._v("0x8028: 指纹（"),e("code",[v._v("FINGERPRINT")]),v._v("）")])]),v._v(" "),e("p",[v._v("在理解所必需范围的前半部分（0x0000 - 0x3FFF）和理解可选范围的前半部分（0x8000 - 0xBFFF）内的 "),e("code",[v._v("STUN")]),v._v(" 属性类型由 "),e("code",[v._v("IETF")]),v._v(" 审查（RFC5226）分配。在理解所必需范围的后半部分（0x4000 - 0x7FFF）和理解可选范围的后半部分（0xC000 - 0xFFFF）内的 "),e("code",[v._v("STUN")]),v._v(" 属性类型由指定专家（RFC5226）分配。专家的职责是验证所选代码点是否未在使用中，以及请求是否不是一个异常大量的代码点。对扩展本身的技术审查超出了指定专家职责范围。")]),v._v(" "),e("h2",{attrs:{id:"stun-错误代码注册表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stun-错误代码注册表"}},[v._v("#")]),v._v(" "),e("code",[v._v("STUN")]),v._v(" 错误代码注册表")]),v._v(" "),e("p",[e("code",[v._v("STUN")]),v._v(" 错误代码是一个在 0 - 699 范围内的数字。"),e("code",[v._v("STUN")]),v._v(" 错误代码附带一个仅供人类消费的 "),e("code",[v._v("UTF-8")]),v._v(" 文本原因短语，可以是任何适当的内容；本文档仅提议一些建议值。"),e("code",[v._v("STUN")]),v._v(" 错误代码在代码点分配和语义上与 "),e("code",[v._v("SIP")]),v._v(" 和 "),e("code",[v._v("HTTP")]),v._v(" 保持一致。")]),v._v(" "),e("p",[v._v("此注册表中的初始值在第 15.6 节中给出。")]),v._v(" "),e("p",[v._v("基于 "),e("code",[v._v("IETF")]),v._v(" 审查 ["),e("code",[v._v("RFC5226")]),v._v("] 分配新的 "),e("code",[v._v("STUN")]),v._v(" 错误代码。在批准请求之前，规范必须仔细考虑不理解此错误代码的客户端如何处理它。请参阅第 7.3.4 节中的规则。")]),v._v(" "),e("h2",{attrs:{id:"stun-udp-和-tcp-端口号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stun-udp-和-tcp-端口号"}},[v._v("#")]),v._v(" "),e("code",[v._v("STUN UDP")]),v._v(" 和 "),e("code",[v._v("TCP")]),v._v(" 端口号")]),v._v(" "),e("p",[e("code",[v._v("IANA")]),v._v(" 之前为 "),e("code",[v._v("STUN")]),v._v(" 分配了端口 3478。这个端口在 "),e("code",[v._v("IANA")]),v._v(' 注册表中以 "'),e("code",[v._v("nat-stun-port")]),v._v('" 的名称出现。为了使 '),e("code",[v._v("DNS SRV")]),v._v(" 过程与已注册的协议服务保持一致，"),e("code",[v._v("IANA")]),v._v(' 被要求将分配给端口 3478 的协议名称从 "'),e("code",[v._v("nat-stun-port")]),v._v('" 更改为 "'),e("code",[v._v("stun")]),v._v('"，并将文本名称从 "'),e("code",[v._v("Simple Traversal of UDP Through NAT (STUN)")]),v._v('" 更改为 "'),e("code",[v._v("Session Traversal Utilities for NAT")]),v._v('"，以便 '),e("code",[v._v("IANA")]),v._v(" 端口注册表显示为：")]),v._v(" "),e("p",[v._v("stun 3478/tcp Session Traversal Utilities for NAT (STUN) 端口\nstun 3478/udp Session Traversal Utilities for NAT (STUN) 端口")]),v._v(" "),e("p",[v._v("此外，"),e("code",[v._v("IANA")]),v._v(" 为定义在 "),e("code",[v._v("TCP")]),v._v(" 和 "),e("code",[v._v("UDP")]),v._v(' 上的 "'),e("code",[v._v("stuns")]),v._v('" 服务分配了端口号 5349。'),e("code",[v._v("UDP")]),v._v(" 端口目前尚未定义；然而，它被保留供将来使用。")])])}),[],!1,null,null,null);_.default=o.exports}}]);