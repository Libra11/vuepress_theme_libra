---
title: 浏览器重绘和回流
category: css
desc: 浏览器重绘和回流
tag:
  - css
picture: https://libra321.oss-cn-huhehaote.aliyuncs.com/img/ReflowRepaint.png
date: "2023-02-24"
---

## 重绘和回流

重绘和回流是浏览器渲染页面的两个过程，它们都会影响页面的性能和用户体验。

重绘：**由于节点的几何属性发生改变或者由于样式发生改变而*不会影响布局*的，称为重绘**，例如 `outline`, `visibility`, `color` 、 `background-color` 等。

回流：**是布局或者几何属性需要改变就称为回流**。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。 **一个元素的回流可能会导致了其所有子元素以及`DOM`中紧随其后的节点、祖先节点元素的回流**。

在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。**回流一定会重绘，但重绘不一定会引起回流**。

避免重绘和回流的方法有以下几种：

- 使用 `transform` 替代 `top` 和 `left`

```html
<!--transform 不会引起回流，是因为它不会改变元素在文档流中的位置和大小，而只是对元素的视觉效果进行变换。浏览器会将 transform 应用到元素的位图上，并利用 GPU 的硬件加速来绘制变换后的位图3。这样就避免了重新计算布局和绘制像素，提高了性能。-->

<!-- 使用 transform 替代 top 和 left -->
<div
  id="box"
  style="position: absolute; width: 100px; height: 100px; background-color: red;"
></div>
<script>
  var box = document.getElementById("box");
  // box.style.top = "100px"; // 引起回流和重绘
  box.style.transform = "translateY(100px)"; // 只引起重绘
</script>
```

- 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引起回流（改变了布局）

```html
<!-- 使用 visibility 替换 display: none -->
<div id="box" style="width: 100px; height: 100px; background-color: red;"></div>
<script>
  var box = document.getElementById("box");
  // box.style.display = "none"; // 引起回流和重绘
  box.style.visibility = "hidden"; // 只引起重绘
</script>
```

- 避免使用 `table` 布局，可能很小的一个小改动会造成整个 `table` 的重新布局
- 尽可能在 `DOM` 树的最末端改变 `class`

```html
<div id="container">
  <div id="box1" class="box"></div>
  <div id="box2" class="box"></div>
</div>
<style>
  .box {
    width: 100px;
    height: 100px;
    margin: 10px;
  }
  .big {
    width: 200px;
    height: 200px;
  }
</style>
<script>
  // 如果改变 container 的 class ，会引起 container 和它的两个子元素 box1 和 box2 的回流
  // document.getElementById("container").className = "big";

  // 如果改变 box1 的 class ，只会引起 box1 和它后面的兄弟元素 box2 的回流
  document.getElementById("box1").className = "box big";
</script>
```

- 避免设置多层内联样式

```html
<!--避免设置多层内联样式的原因是，因为每个都会造成回流，影响页面性能。

内联样式也会增加 HTML 文档的大小，降低可维护性和可读性。

样式应该合并在一个外部类，这样当该元素的 class 属性可被操控时仅会产生一个回流。 -->

<!-- 不推荐 -->
<div style="color: red; font-size: 20px; margin: 10px;">Hello</div>

<!-- 推荐 -->
<style>
  .hello {
    color: red;
    font-size: 20px;
    margin: 10px;
  }
</style>
<div class="hello">Hello</div>
```

- 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上

```html
<!-- 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上 -->
<div id="container" style="position: relative;">
  <div
    id="box"
    style="position: absolute; width: 100px; height: 100px; background-color: red; left: 0;"
  ></div>
</div>
<script>
  var box = document.getElementById("box");
  setInterval(function() {
    box.style.left = parseInt(box.style.left) + 1 + "px";
    // 只引起容器内部元素位置调整而不影响其他元素布局
    // 如果 box 的 position 属性为 static 或 relative ，那么每次移动都会引起整个页面的回流和重绘
  }, 16);
</script>
```

- 避免频繁操作样式，最好一次性重写 `style` 属性，或者将样式列表定义为 `class` 并一次性更改 `class` 属性
- 避免频繁操作 `DOM` ，创建一个 `documentFragment`，在它上面应用所有 `DOM` 操作，最后再把它添加到文档中

```js
/*
DocumentFragment 是一个轻量级的文档片段，它可以在内存中创建和修改 DOM 节点，而不影响真实的文档4。所以，当我们需要频繁地添加或删除 DOM 节点时，可以先创建一个 DocumentFragment 对象，在它上面进行所有的操作，然后再一次性地把它添加到文档中。这样就可以避免多次触发回流和重绘，提高性能。
*/
var parent = document.getElementById("parent");
var frag = document.createDocumentFragment();
for (var i = 0; i < 10000; i++) {
  var child = document.createElement("li");
  var text = document.createTextNode("" + i);
  child.appendChild(text);
  frag.appendChild(child);
}
parent.appendChild(frag);
```

- 也可以先为元素设置 `display: none` ，进行 `DOM` 操作，完成后再把 display 属性设置回来

```js
// 假设有一个 ul 元素需要添加 1000 个 li 元素
var ul = document.getElementById("ul");
// 如果直接添加 li 元素，每次添加都会触发一次回流
// for (var i = 0; i < 1000; i++) {
//     var li = document.createElement("li");
//     li.innerHTML = "Item " + i;
//     ul.appendChild(li);
// }

// 如果先将 ul 的 display 设置为 none ，再添加 li 元素，最后再将 display 设置回来
ul.style.display = "none"; // 只触发一次回流
for (var i = 0; i < 1000; i++) {
  var li = document.createElement("li");
  li.innerHTML = "Item " + i;
  ul.appendChild(li);
}
ul.style.display = ""; // 只触发一次回流
```
