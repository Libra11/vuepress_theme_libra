(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{412:function(v,_,e){"use strict";e.r(_);var o=e(12),c=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"预备知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#预备知识"}},[v._v("#")]),v._v(" 预备知识")]),v._v(" "),e("h3",{attrs:{id:"ice"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ice"}},[v._v("#")]),v._v(" "),e("code",[v._v("ICE")])]),v._v(" "),e("p",[e("code",[v._v("ICE")]),v._v(" ("),e("code",[v._v("Interactive Connectivity Establishment")]),v._v(") 是一种用于在不同网络环境中建立实时通信的协议。它是一种 "),e("code",[v._v("NAT")]),v._v(" 穿透技术，允许两个端点在它们之间存在的任何 "),e("code",[v._v("NAT")]),v._v("、防火墙或代理设备等网络障碍的存在下，建立一个直接的通信连接。"),e("code",[v._v("ICE")]),v._v(" 协议通过将 "),e("code",[v._v("STUN")]),v._v(" （"),e("code",[v._v("Session Traversal Utilities for NAT")]),v._v("）和 "),e("code",[v._v("TURN")]),v._v(" （"),e("code",[v._v("Traversal Using Relays around NAT")]),v._v("）协议组合使用，尝试直接连接两个端点，若无法直接连接，再通过中继服务器进行通信。")]),v._v(" "),e("p",[e("code",[v._v("ICE")]),v._v(" 协议通过在不同的网络地址上测试 "),e("code",[v._v("STUN")]),v._v(" 服务器响应，确定哪个网络地址可以用于实时通信，这个过程称为候选地址发现（"),e("code",[v._v("Candidate Address Discovery")]),v._v("）。然后，"),e("code",[v._v("ICE")]),v._v(" 协议会测试这些地址，以找到一种方式来建立直接连接。如果候选地址无法建立直接连接，则 "),e("code",[v._v("ICE")]),v._v(" 协议使用 "),e("code",[v._v("TURN")]),v._v(" 中继服务器。")]),v._v(" "),e("p",[e("code",[v._v("ICE")]),v._v(" 协议通常用于实时通信协议中，如 "),e("code",[v._v("VoIP")]),v._v(" 通信、视频会议和 "),e("code",[v._v("WebRTC")]),v._v("。")]),v._v(" "),e("h4",{attrs:{id:"ice-candidate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ice-candidate"}},[v._v("#")]),v._v(" "),e("code",[v._v("ICE candidate")])]),v._v(" "),e("p",[e("code",[v._v("ICE")]),v._v("（"),e("code",[v._v("Interactive Connectivity Establishment")]),v._v("）候选者（"),e("code",[v._v("candidate")]),v._v("）是指在进行对等连接时，一个网络节点（比如计算机）用于标识自己网络接口地址（包括 "),e("code",[v._v("IP")]),v._v(" 和端口）的一种方式。一个 "),e("code",[v._v("ICE")]),v._v(" 候选者由一个地址（地址族、"),e("code",[v._v("IP")]),v._v(" 地址、端口号等组成）以及与其相关的传输协议（"),e("code",[v._v("TCP")]),v._v("、"),e("code",[v._v("UDP")]),v._v(" 等）和一些其他可选信息组成。"),e("code",[v._v("ICE")]),v._v(" 候选者有两种类型：主机候选者和服务器反射候选者。主机候选者是指节点本身的 "),e("code",[v._v("IP")]),v._v(" 地址和端口号，而服务器反射候选者是指通过 "),e("code",[v._v("NAT")]),v._v(" 后，"),e("code",[v._v("NAT")]),v._v(" 映射的公网地址和端口号。")]),v._v(" "),e("p",[v._v("在 "),e("code",[v._v("ICE")]),v._v(" 过程中，通信节点需要通过收集本地的候选者和远程对等方发送过来的候选者来确定最佳的连接路径。为了方便候选者的传输，"),e("code",[v._v("ICE")]),v._v(" 候选者通常使用 "),e("code",[v._v("SDP")]),v._v("（"),e("code",[v._v("Session Description Protocol")]),v._v("）格式进行交换和表示。在使用 "),e("code",[v._v("SDP")]),v._v(" 表示 "),e("code",[v._v("ICE")]),v._v(" 候选者时，一般使用 "),e("code",[v._v("cand-type")]),v._v(" 字段标识其类型，主机候选者的类型为“"),e("code",[v._v("host")]),v._v("”，服务器反射候选者的类型为“"),e("code",[v._v("srflx")]),v._v("”（"),e("code",[v._v("server reflexive")]),v._v("）。")]),v._v(" "),e("p",[e("code",[v._v("ICE")]),v._v(" 候选者的收集和选择是 "),e("code",[v._v("ICE")]),v._v(" 中非常重要的一个步骤，决定了通信的成功与否以及通信的质量。因此，正确地选择合适的 "),e("code",[v._v("ICE")]),v._v(" 候选者是保证实时通信质量的关键。")]),v._v(" "),e("h3",{attrs:{id:"sip"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sip"}},[v._v("#")]),v._v(" "),e("code",[v._v("SIP")])]),v._v(" "),e("p",[e("code",[v._v("SIP")]),v._v(" 是 "),e("code",[v._v("Session Initiation Protocol")]),v._v("（会话初始化协议）的缩写，是一种用于建立、管理和终止多媒体会话（音频、视频、聊天等）的信令协议。它可以被用于创建、修改和终止两个或多个参与者之间的会话。在 "),e("code",[v._v("IP")]),v._v(" 网络中，"),e("code",[v._v("SIP")]),v._v(" 是一个应用层协议，使用 "),e("code",[v._v("TCP")]),v._v(" 或 "),e("code",[v._v("UDP")]),v._v(" 传输层协议。它定义了会话的处理和信令通信的操作。"),e("code",[v._v("SIP")]),v._v(" 广泛应用于 "),e("code",[v._v("VoIP")]),v._v("（"),e("code",[v._v("Voice over IP")]),v._v("）和视频会议系统中。")]),v._v(" "),e("h2",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),e("p",[v._v("在 "),e("code",[v._v("NAT")]),v._v(" 环境下，如果两个位于不同 "),e("code",[v._v("NAT")]),v._v(" 之后的主机需要进行通信，由于直接进行通信是不可能的，因此需要使用中继节点。"),e("code",[v._v("TURN")]),v._v(" 是一种协议，允许 "),e("code",[v._v("NAT")]),v._v(" 后的主机（称为 "),e("code",[v._v("TURN")]),v._v(" 客户端）请求另一台主机（称为 "),e("code",[v._v("TURN")]),v._v(" 服务器）充当中继。客户端可以安排服务器中继某些其他主机（称为对等方"),e("code",[v._v("peers")]),v._v("）的数据包，并可以控制中继的方式。"),e("code",[v._v("TURN")]),v._v(" 客户端必须有一种方式"),e("strong",[v._v("将中继地址传递给其对等方，并想办法知道每个对等方的 "),e("code",[v._v("IP")]),v._v(" 地址和端口")]),v._v("。"),e("code",[v._v("TURN")]),v._v(" 和 "),e("code",[v._v("ICE")]),v._v(" 一起使用时，中继地址和对等方的 "),e("code",[v._v("IP")]),v._v(" 地址和端口包含在 "),e("code",[v._v("ICE candidate")]),v._v(" 信息中。如果使用 "),e("code",[v._v("SIP")]),v._v(" 等其他协议，那么 "),e("code",[v._v("SIP")]),v._v(" 起到了充当中继地址和对等方信息传递的角色。")]),v._v(" "),e("p",[e("code",[v._v("TURN")]),v._v(" 协议的作用是允许一个位于 "),e("code",[v._v("NAT")]),v._v(" 后面的主机（即 "),e("code",[v._v("TURN")]),v._v(" 客户端）请求另一个主机（即 "),e("code",[v._v("TURN")]),v._v(" 服务器）充当一个中继，以便与其他主机进行通信。当无法找到直接的通信路径时，"),e("code",[v._v("TURN")]),v._v(" 服务器充当中继，通过互联网中转数据包，让两个位于 "),e("code",[v._v("NAT")]),v._v(" 后面的主机之间进行通信。")]),v._v(" "),e("p",[v._v("其次，"),e("code",[v._v("TURN")]),v._v(" 协议最初是为支持使用 "),e("code",[v._v("SIP")]),v._v(" 信令协议进行信令的多媒体会话而设计的。因为 "),e("code",[v._v("SIP")]),v._v(" 支持分叉，所以 "),e("code",[v._v("TURN")]),v._v(" 支持一个中继传输地址对应多个对等方的功能，这是其他方法（例如 "),e("code",[v._v("SOCKS")]),v._v("）不支持的。不过，"),e("code",[v._v("TURN")]),v._v(" 也适用于其他类型的应用程序。")]),v._v(" "),e("p",[e("code",[v._v("ICE")]),v._v(" 是一种网络协议，用于在 "),e("code",[v._v("NAT")]),v._v(" 网络环境下建立点对点通信连接。在 "),e("code",[v._v("RFC 5766")]),v._v(" 中，建议使用 "),e("code",[v._v("ICE")]),v._v(" 和 "),e("code",[v._v("TURN")]),v._v(" 协议进行 "),e("code",[v._v("NAT")]),v._v(" 穿越。当客户端和对等方使用 "),e("code",[v._v("ICE")]),v._v(" 协议确定通信路径时，"),e("code",[v._v("ICE")]),v._v(" 会首先尝试使用洞穿技术寻找直接路径，只有在找不到直接路径时才使用 "),e("code",[v._v("TURN")]),v._v(" 服务器。")]),v._v(" "),e("p",[v._v("最后，"),e("code",[v._v("TURN")]),v._v(" 协议是 "),e("code",[v._v("STUN")]),v._v("（"),e("code",[v._v("NAT")]),v._v(" 遍历会话实用程序）协议的扩展。大多数（但不是所有）"),e("code",[v._v("TURN")]),v._v(" 消息都是 "),e("code",[v._v("STUN")]),v._v(" 格式的消息。因此，"),e("code",[v._v("RFC 5766")]),v._v(" 建议读者在使用 "),e("code",[v._v("TURN")]),v._v(" 协议之前应该先了解 "),e("code",[v._v("STUN")]),v._v(" 协议。")]),v._v(" "),e("h2",{attrs:{id:"操作概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作概述"}},[v._v("#")]),v._v(" 操作概述")]),v._v(" "),e("p",[v._v("在一个典型的配置中，"),e("code",[v._v("TURN")]),v._v(" 客户端连接到一个私有网络，并通过一个或多个 "),e("code",[v._v("NAT")]),v._v(" 连接到公共互联网。在公共互联网上有一个 "),e("code",[v._v("TURN")]),v._v(" 服务器。在互联网的其他地方，有一个或多个 "),e("code",[v._v("TURN")]),v._v(" 客户端希望与之通信的对等方。这些对等方可能在一个或多个 "),e("code",[v._v("NAT")]),v._v(" 后面，也可能不在。客户端使用服务器作为中继将数据包发送到这些对等方，并从这些对等方接收数据包。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("                                        Peer A\n                                        Server-Reflexive    +---------+\n                                        Transport Address   |         |\n                                        192.0.2.150:32102   |         |\n                                            |              /|         |\n                          TURN              |            / ^|  Peer A |\n    Client's              Server            |           /  ||         |\n    Host Transport        Transport         |         //   ||         |\n    Address               Address           |       //     |+---------+\n   10.1.1.2:49721       192.0.2.15:3478     |+-+  //     Peer A\n            |               |               ||N| /       Host Transport\n            |   +-+         |               ||A|/        Address\n            |   | |         |               v|T|     192.168.100.2:49582\n            |   | |         |               /+-+\n +---------+|   | |         |+---------+   /              +---------+\n |         ||   |N|         ||         | //               |         |\n | TURN    |v   | |         v| TURN    |/                 |         |\n | Client  |----|A|----------| Server  |------------------|  Peer B |\n |         |    | |^         |         |^                ^|         |\n |         |    |T||         |         ||                ||         |\n +---------+    | ||         +---------+|                |+---------+\n                | ||                    |                |\n                | ||                    |                |\n                +-+|                    |                |\n                   |                    |                |\n                   |                    |                |\n             Client's                   |            Peer B\n             Server-Reflexive    Relayed             Transport\n             Transport Address   Transport Address   Address\n             192.0.2.1:7000      192.0.2.15:50000     192.0.2.210:49191\n")])])]),e("p",[v._v("在上图中，"),e("code",[v._v("TURN")]),v._v(" 客户端和 "),e("code",[v._v("TURN")]),v._v(" 服务器被一个 "),e("code",[v._v("NAT")]),v._v(" 隔离开来，客户端在私有网络上，服务器在公共网络上。假设这个 "),e("code",[v._v("NAT")]),v._v(" 是一个“坏”"),e("code",[v._v("NAT")]),v._v("，比如它可能有一个“地址和端口相关映射”的映射属性。客户端通过一个叫做 "),e("code",[v._v("HOST TRANSPORT ADDRESS")]),v._v(" 的 "),e("code",[v._v("IP")]),v._v(" 地址和端口的组合与服务器进行通信。客户端从其主机传输地址向 "),e("code",[v._v("TURN")]),v._v(" 服务器传输地址发送 "),e("code",[v._v("TURN")]),v._v(" 消息。客户端通过某种未指定的方式（例如配置）知道了 "),e("code",[v._v("TURN")]),v._v(" 服务器传输地址，通常有许多客户端同时使用该地址。由于客户端位于 "),e("code",[v._v("NAT")]),v._v(" 后面，因此服务器看到的来自客户端的数据包是从 "),e("code",[v._v("NAT")]),v._v(" 本身的传输地址发送过来的，这个地址称为客户端的 "),e("code",[v._v("SERVER-REFLEXIVE")]),v._v(" 传输地址。服务器向客户端的服务器反射传输地址发送的数据包将由 "),e("code",[v._v("NAT")]),v._v(" 转发到客户端的主机传输地址。")]),v._v(" "),e("p",[v._v("客户端使用 "),e("code",[v._v("TURN")]),v._v(" 命令在服务器上创建和操作分配（"),e("code",[v._v("ALLOCATION")]),v._v("）。分配是服务器上的数据结构，其中包含 "),e("code",[v._v("RELAYED")]),v._v(" 传输地址。"),e("code",[v._v("RELAYED")]),v._v(" 传输地址是服务器上的传输地址，对等方可以使用它让服务器中继数据到客户端。分配通过其中继传输地址唯一标识。")]),v._v(" "),e("p",[v._v("创建分配之后，客户端可以向服务器发送应用数据，并指示将数据发送给哪个对等方，服务器将中继这些数据到相应的对等方。客户端将应用数据发送到 "),e("code",[v._v("TURN")]),v._v(" 消息中的服务器，服务器从 "),e("code",[v._v("TURN")]),v._v(" 消息中提取数据并将其作为 "),e("code",[v._v("UDP")]),v._v(" 数据报发送到对等方。反向方向中，对等方可以在 "),e("code",[v._v("UDP")]),v._v(" 数据报中将应用数据发送到分配的中继传输地址；然后服务器将此数据封装在 "),e("code",[v._v("TURN")]),v._v(" 消息中，并将其与发送数据的对等方一起发送给客户端。"),e("strong",[v._v("由于 "),e("code",[v._v("TURN")]),v._v(" 消息始终包含客户端正在与哪个对等方通信的指示，因此客户端可以使用单个分配与多个对等方通信。")])]),v._v(" "),e("blockquote",[e("p",[v._v("当客户端创建一个 "),e("code",[v._v("allocation")]),v._v(" 并得到它的 "),e("code",[v._v("Relayed Transport Address")]),v._v(" 后，它可以使用这个地址与多个对等方通信。比如，客户端可以将其分配的 "),e("code",[v._v("Relayed Transport Address")]),v._v(" 告诉对等方 "),e("code",[v._v("A")]),v._v(" 和对等方 "),e("code",[v._v("B")]),v._v("，然后分别与对等方 "),e("code",[v._v("A")]),v._v(" 和对等方 "),e("code",[v._v("B")]),v._v(" 进行通信。当对等方 "),e("code",[v._v("A")]),v._v(" 发送数据包时，它会发送到 "),e("code",[v._v("Relayed Transport Address")]),v._v("，然后服务器会将该数据包中的目的地字段解码为对等方 "),e("code",[v._v("A")]),v._v("，并将其转发给客户端的 "),e("code",[v._v("Host Transport Address")]),v._v("。同样地，当对等方 "),e("code",[v._v("B")]),v._v(" 发送数据包时，它也会发送到 "),e("code",[v._v("Relayed Transport Address")]),v._v("，服务器会将该数据包中的目的地字段解码为对等方 "),e("code",[v._v("B")]),v._v("，并将其转发给客户端的 "),e("code",[v._v("Host Transport Address")]),v._v("。因此，客户端使用单个 "),e("code",[v._v("Relayed Transport Address")]),v._v(" 与多个对等方通信。")])]),v._v(" "),e("p",[v._v("当对等方位于 "),e("code",[v._v("NAT")]),v._v(" 后面时，客户端必须使用其服务器反射传输地址来标识对等方，而不是使用其主机传输地址。例如，在上面的例子中，要向对等方 "),e("code",[v._v("A")]),v._v(" 发送应用数据，客户端必须指定 "),e("code",[v._v("192.0.2.150:32102")]),v._v("（对等方 "),e("code",[v._v("A")]),v._v(" 的服务器反射传输地址），而不是 "),e("code",[v._v("192.168.100.2:49582")]),v._v("（对等方 "),e("code",[v._v("A")]),v._v(" 的主机传输地址）。")]),v._v(" "),e("p",[v._v("服务器上的每个分配属于单个客户端，只有一个中继传输地址可供该分配使用。因此，当数据包到达服务器上的中继传输地址时，服务器知道数据是为哪个客户端而来。")]),v._v(" "),e("p",[v._v("客户端可以同时在服务器上拥有多个分配。")]),v._v(" "),e("h3",{attrs:{id:"传输"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#传输"}},[v._v("#")]),v._v(" 传输")]),v._v(" "),e("p",[e("code",[v._v("TURN")]),v._v(" 协议在服务器和对等方之间始终使用 "),e("code",[v._v("UDP")]),v._v(" 传输，但协议允许在客户端和服务器之间使用 "),e("code",[v._v("UDP")]),v._v("、"),e("code",[v._v("TCP")]),v._v(" 或 "),e("code",[v._v("TLS-over-TCP")]),v._v("。如果使用 "),e("code",[v._v("TCP")]),v._v(" 或 "),e("code",[v._v("TLS-over-TCP")]),v._v(" 传输，则服务器会在将数据中继到对等方时将这些传输与 "),e("code",[v._v("UDP")]),v._v(" 传输之间进行转换。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("+----------------------------+---------------------+\n| TURN client to TURN server | TURN server to peer |\n+----------------------------+---------------------+\n|             UDP            |         UDP         |\n|             TCP            |         UDP         |\n|        TLS over TCP        |         UDP         |\n+----------------------------+---------------------+\n")])])]),e("p",[e("code",[v._v("TURN")]),v._v(" 协议支持 "),e("code",[v._v("TCP")]),v._v(" 传输的原因是某些防火墙配置为完全阻止 "),e("code",[v._v("UDP")]),v._v("。这些防火墙阻止 "),e("code",[v._v("UDP")]),v._v(" 但不阻止 "),e("code",[v._v("TCP")]),v._v("，部分原因是 "),e("code",[v._v("TCP")]),v._v(" 具有使防火墙更清楚受保护节点意图的属性。"),e("code",[v._v("TURN")]),v._v(" 协议也支持 "),e("code",[v._v("TLS-over-TCP")]),v._v(" 传输，因为 "),e("code",[v._v("TLS")]),v._v(" 提供了额外的安全性质，一些客户端可能希望利用它们。"),e("code",[v._v("TURN")]),v._v(" 协议只支持 "),e("code",[v._v("IPv4")]),v._v(" 地址，并且计划扩展协议以添加对 "),e("code",[v._v("IPv6")]),v._v(" 和 "),e("code",[v._v("IPv4")]),v._v(" 和 "),e("code",[v._v("IPv6")]),v._v(" 之间中继的支持。在某些情况下，"),e("code",[v._v("TURN")]),v._v(" 客户端可以在与服务器通信的主机传输地址上发送和接收 "),e("code",[v._v("TURN")]),v._v(" 消息以外的数据包。这通常发生在与 "),e("code",[v._v("ICE")]),v._v(" 一起使用 "),e("code",[v._v("TURN")]),v._v(" 的情况下。在这些情况下，客户端可以通过检查到达数据包的源地址来区分 "),e("code",[v._v("TURN")]),v._v(" 消息和其他消息，"),e("code",[v._v("TURN")]),v._v(" 服务器发送的数据包的源地址将始终是 "),e("code",[v._v("TURN")]),v._v(" 服务器的地址。")]),v._v(" "),e("h3",{attrs:{id:"分配"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分配"}},[v._v("#")]),v._v(" 分配")]),v._v(" "),e("p",[v._v("创建一个 "),e("code",[v._v("TURN")]),v._v(" 分配（"),e("code",[v._v("allocation")]),v._v("）需要进行 "),e("code",[v._v("Allocate")]),v._v(" 事务。客户端向服务器发送一个 "),e("code",[v._v("Allocate")]),v._v(" 请求，服务器会回复一个带有已分配中继传输地址（"),e("code",[v._v("relayed transport address")]),v._v("）的 "),e("code",[v._v("Allocate")]),v._v(" 成功响应。客户端可以在 "),e("code",[v._v("Allocate")]),v._v(" 请求中包含属性，以描述它所需的分配类型（例如分配的寿命）。由于中继数据传输具有安全性问题，服务器要求客户端进行身份验证，通常使用 "),e("code",[v._v("STUN")]),v._v(" 的长期凭证机制，以证明其被授权使用该服务器。")]),v._v(" "),e("p",[v._v("一旦分配了中继传输地址，客户端必须保持分配的活跃状态。为此，客户端定期向服务器发送 "),e("code",[v._v("Refresh")]),v._v(" 请求。"),e("code",[v._v("TURN")]),v._v(" 故意使用不同的方法（"),e("code",[v._v("Refresh")]),v._v(" 而不是 "),e("code",[v._v("Allocate")]),v._v("）来刷新，以确保客户端能够在分配因某种原因消失时得到通知。")]),v._v(" "),e("blockquote",[e("p",[v._v("客户端需要定期向 "),e("code",[v._v("TURN")]),v._v(' 服务器发送 "'),e("code",[v._v("Refresh")]),v._v('" 请求，以保持它们之间分配的 '),e("code",[v._v("Relayed Transport Address")]),v._v(' 的有效性。在这里，"'),e("code",[v._v("Refresh")]),v._v('" 是一种特定的请求类型，它的作用是告诉服务器这个分配仍然有效。'),e("code",[v._v("TURN")]),v._v(' 故意使用"'),e("code",[v._v("Refresh")]),v._v('"请求来刷新，而不是用"'),e("code",[v._v("Allocate")]),v._v('"请求重新分配，是因为这样做可以使客户端在分配消失时得到通知。如果使用"'),e("code",[v._v("Allocate")]),v._v('"请求重新分配，客户端可能不会意识到分配已经消失了，因为它们会认为这是一个新的分配。因此，使用"'),e("code",[v._v("Refresh")]),v._v('"请求来刷新更加安全，因为它可以让客户端知道分配已经失效，从而采取适当的措施。')])]),v._v(" "),e("p",[e("code",[v._v("Refresh")]),v._v(" 事务的频率由分配的寿命决定。默认的分配寿命为 "),e("code",[v._v("10")]),v._v(" 分钟，这个值被选择得足够长，以便刷新通常不会对客户端造成负担，同时在客户端意外退出时分配会在适当的时间内过期。但是，客户端可以在 "),e("code",[v._v("Allocate")]),v._v(" 请求中请求更长的寿命，并可以在 "),e("code",[v._v("Refresh")]),v._v(" 请求中修改其请求，服务器总是在响应中指示实际寿命。客户端必须在“寿命”秒内发出新的 "),e("code",[v._v("Refresh")]),v._v(" 事务，以前一个 "),e("code",[v._v("Allocate")]),v._v(" 或 "),e("code",[v._v("Refresh")]),v._v(" 事务为准。一旦客户端不再希望使用分配，它应使用请求寿命为 "),e("code",[v._v("0")]),v._v(" 的 "),e("code",[v._v("Refresh")]),v._v(" 请求删除分配。")]),v._v(" "),e("p",[v._v("服务器和客户端都会跟踪一个名为 "),e("code",[v._v("5-TUPLE")]),v._v(" 的值。在客户端，5 元组由客户端的主机传输地址、服务器传输地址和客户端用于与服务器通信的传输协议组成。在服务器上，5 元组的值相同，只是客户端的主机传输地址被客户端的服务器反射地址所替代，因为这是服务器看到的客户端地址。")]),v._v(" "),e("p",[v._v("客户端和服务器都记得 "),e("code",[v._v("Allocate")]),v._v(" 请求中使用的 "),e("code",[v._v("5-tuple")]),v._v(" 值。之后客户端和服务器之间的消息都会使用相同的 "),e("code",[v._v("5-tuple")]),v._v("。这样，客户端和服务器就知道所指的分配是哪个。如果客户端希望分配第二个中继传输地址，则必须使用不同的 "),e("code",[v._v("5-tuple")]),v._v(" 创建第二个分配（例如通过使用不同的客户端主机地址或端口）。")]),v._v(" "),e("p",[v._v("注意：虽然本文档中使用的术语是“"),e("code",[v._v("5-tuple")]),v._v("”，但 "),e("code",[v._v("TURN")]),v._v(" 服务器可以存储任何产生相同结果的标识符。特别是，实现可以使用文件描述符代替 "),e("code",[v._v("5-tuple")]),v._v(" 来表示 "),e("code",[v._v("TCP")]),v._v(" 连接。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("TURN                                 TURN           Peer          Peer\n  client                               server          A             B\n    |-- Allocate request ---------------\x3e|             |             |\n    |                                    |             |             |\n    |<--------------- Allocate failure --|             |             |\n    |                 (401 Unauthorized) |             |             |\n    |                                    |             |             |\n    |-- Allocate request ---------------\x3e|             |             |\n    |                                    |             |             |\n    |<---------- Allocate success resp --|             |             |\n    |            (192.0.2.15:50000)      |             |             |\n    //                                   //            //            //\n    |                                    |             |             |\n    |-- Refresh request ----------------\x3e|             |             |\n    |                                    |             |             |\n    |<----------- Refresh success resp --|             |             |\n    |                                    |             |             |\n")])])]),e("p",[v._v("在上图中,客户端向服务器发送一个未携带凭据的 "),e("code",[v._v("Allocate")]),v._v(" 请求。由于服务器要求使用 "),e("code",[v._v("STUN")]),v._v(" 的长期凭据机制对所有请求进行身份验证，因此服务器用 "),e("code",[v._v("401")]),v._v("（未授权）错误代码拒绝该请求。然后客户端再次尝试，这次携带了凭据（未显示）。这次服务器接受 "),e("code",[v._v("Allocate")]),v._v(" 请求并返回一个 "),e("code",[v._v("Allocate")]),v._v(" 成功响应，其中包含分配的中继传输地址等信息。稍后，客户端决定刷新分配，因此向服务器发送一个 "),e("code",[v._v("Refresh")]),v._v(" 请求。刷新被接受，服务器回复一个 "),e("code",[v._v("Refresh")]),v._v(" 成功响应。")]),v._v(" "),e("h3",{attrs:{id:"权限"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#权限"}},[v._v("#")]),v._v(" 权限")]),v._v(" "),e("p",[e("code",[v._v("TURN")]),v._v(" 支持权限管理机制，类似于地址受限制的 "),e("code",[v._v("NAT")]),v._v("。一个分配可以拥有零个或多个权限，每个权限包含一个 "),e("code",[v._v("IP")]),v._v(" 地址和一个生命周期。当服务器接收到一个 "),e("code",[v._v("UDP")]),v._v(" 数据报时，它首先检查权限列表。如果数据报的源 "),e("code",[v._v("IP")]),v._v(" 地址与权限匹配，则应用程序数据将被中继到客户端，否则 "),e("code",[v._v("UDP")]),v._v(" 数据报将被静默丢弃。权限将在 5 分钟后过期，除非刷新，否则无法明确删除权限。客户端可以使用 "),e("code",[v._v("CreatePermission")]),v._v(" 请求或 "),e("code",[v._v("ChannelBind")]),v._v(" 请求安装或刷新权限。多个权限可以通过单个请求进行安装或刷新。注意，"),e("strong",[v._v("权限是在分配的上下文中进行管理的，因此在一个分配中添加或删除权限不会影响其他分配。")])]),v._v(" "),e("h3",{attrs:{id:"发送机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#发送机制"}},[v._v("#")]),v._v(" 发送机制")]),v._v(" "),e("p",[v._v("在 "),e("code",[v._v("TURN")]),v._v(" 协议中，有两种机制用于客户端和对等方使用 "),e("code",[v._v("TURN")]),v._v(" 服务器交换应用程序数据。第一种机制使用 "),e("code",[v._v("Send")]),v._v(" 和 "),e("code",[v._v("Data")]),v._v(" 方法，第二种机制使用通道。无论使用哪种机制，客户端都可以使用单个分配的中继传输地址与多个对等方进行通信；因此，两种机制都包括一种方式，使客户端能够向服务器指示哪个对等方应该接收数据，并使服务器向客户端指示哪个对等方发送了数据。")]),v._v(" "),e("p",[e("code",[v._v("Send")]),v._v(" 机制使用 "),e("code",[v._v("Send")]),v._v(" 和 "),e("code",[v._v("Data")]),v._v(" 指示。 "),e("code",[v._v("Send")]),v._v(" 指示用于从客户端发送应用程序数据到服务器，而 "),e("code",[v._v("Data")]),v._v(" 指示用于从服务器发送应用程序数据到客户端。")]),v._v(" "),e("p",[v._v("当使用 "),e("code",[v._v("Send")]),v._v(" 机制时，客户端向 "),e("code",[v._v("TURN")]),v._v(" 服务器发送一个 "),e("code",[v._v("Send")]),v._v(" 指示，其中包含（a）指定对等方（服务器反射）传输地址的 "),e("code",[v._v("XOR-PEER-ADDRESS")]),v._v(" 属性，和（b）保持应用程序数据的 "),e("code",[v._v("DATA")]),v._v(" 属性。当 "),e("code",[v._v("TURN")]),v._v(" 服务器接收到 "),e("code",[v._v("Send")]),v._v(" 指示时，它会从 "),e("code",[v._v("DATA")]),v._v(" 属性中提取应用程序数据，并将其作为 "),e("code",[v._v("UDP")]),v._v(" 数据报发送到对等方，使用分配的中继地址作为源地址。请注意，无需指定中继传输地址，因为它隐含在用于 "),e("code",[v._v("Send")]),v._v(" 指示的 5 元组中。")]),v._v(" "),e("p",[v._v("在反向方向上，到达 "),e("code",[v._v("TURN")]),v._v(" 服务器上的中继传输地址的 "),e("code",[v._v("UDP")]),v._v(" 数据报会被转换为 "),e("code",[v._v("Data")]),v._v(" 指示，并将其发送到客户端，其中包括对等方的服务器反射传输地址在 "),e("code",[v._v("XOR-PEER-ADDRESS")]),v._v(" 属性中，数据本身在 "),e("code",[v._v("DATA")]),v._v(" 属性中。由于中继传输地址唯一标识分配，因此服务器知道哪个客户端应该接收数据。")]),v._v(" "),e("p",[v._v("由于长期凭据机制不支持对指示进行身份验证，因此无法对 "),e("code",[v._v("Send")]),v._v(" 和 "),e("code",[v._v("Data")]),v._v(" 指示进行身份验证。这不像起初看起来那么严重，因为客户端到服务器的路径只占总路径的一半。希望实现适当安全性的应用程序应该加密客户端和对等方之间发送的数据。")]),v._v(" "),e("p",[v._v("由于 "),e("code",[v._v("Send")]),v._v(" 指示无法进行身份验证，因此攻击者有可能向服务器发送虚假的 "),e("code",[v._v("Send")]),v._v(" 指示，然后将其中继到对等方。为了部分减轻这种攻击，"),e("code",[v._v("TURN")]),v._v(" 要求客户端在向对等方发送数据之前向其安装权限。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("  TURN                                 TURN           Peer          Peer\n  client                               server          A             B\n    |                                    |             |             |\n    |-- CreatePermission req (Peer A) --\x3e|             |             |\n    |<-- CreatePermission success resp --|             |             |\n    |                                    |             |             |\n    |--- Send ind (Peer A)--------------\x3e|             |             |\n    |                                    |=== data ===>|             |\n    |                                    |             |             |\n    |                                    |<== data ====|             |\n    |<-------------- Data ind (Peer A) --|             |             |\n    |                                    |             |             |\n    |                                    |             |             |\n    |--- Send ind (Peer B)--------------\x3e|             |             |\n    |                                    | dropped     |             |\n    |                                    |             |             |\n    |                                    |<== data ==================|\n    |                            dropped |             |             |\n    |                                    |             |             |\n")])])]),e("p",[v._v("上图中,客户端已经创建了一个分配，并希望向其对等方发送数据。客户端首先通过向服务器发送一个 "),e("code",[v._v("CreatePermission")]),v._v(" 请求来创建一个权限，其中在 "),e("code",[v._v("XOR-PEER-ADDRESS")]),v._v(" 属性中指定了 "),e("code",[v._v("Peer A")]),v._v(" 的（服务器反射）"),e("code",[v._v("IP")]),v._v(" 地址；如果没有这样做，服务器将不会在客户端和服务器之间中继数据。然后，客户端使用 "),e("code",[v._v("Send")]),v._v(" 指示将数据发送到 "),e("code",[v._v("Peer A")]),v._v("；在服务器上，应用程序数据被提取并转发到 "),e("code",[v._v("Peer A")]),v._v("，使用分配的中继传输地址作为源传输地址。当从 "),e("code",[v._v("Peer A")]),v._v(" 收到 "),e("code",[v._v("UDP")]),v._v(" 数据包时，在数据指示中放置其内容并将其转发给客户端。稍后，客户端尝试与 "),e("code",[v._v("Peer B")]),v._v(" 交换数据；但是，没有为 "),e("code",[v._v("Peer B")]),v._v(" 安装权限，因此来自客户端的 "),e("code",[v._v("Send")]),v._v(" 指示和来自对等方的 "),e("code",[v._v("UDP")]),v._v(" 数据包都被服务器丢弃。")]),v._v(" "),e("blockquote",[e("p",[v._v("这个过程是为了让客户端和对等方之间能够交换应用程序数据，因为 "),e("code",[v._v("TURN")]),v._v(" 服务器充当中继，可以使客户端和对等方互相通信，即使它们在不同的网络上。客户端使用 "),e("code",[v._v("Send")]),v._v(" 方法将数据发送到 "),e("code",[v._v("TURN")]),v._v(" 服务器，"),e("code",[v._v("TURN")]),v._v(" 服务器将数据中继到对等方，对等方可以对数据做出响应并将其发送回 "),e("code",[v._v("TURN")]),v._v(" 服务器。"),e("code",[v._v("TURN")]),v._v(" 服务器将响应中继回客户端，以便客户端可以处理数据并采取相应的措施。这个过程使得客户端和对等方之间能够互相通信，从而实现了点对点的连接。")])]),v._v(" "),e("h3",{attrs:{id:"通道"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通道"}},[v._v("#")]),v._v(" 通道")]),v._v(" "),e("p",[v._v("对于某些应用程序（例如 "),e("code",[v._v("VoIP")]),v._v("），使用 "),e("code",[v._v("Send")]),v._v(" 和 "),e("code",[v._v("Data")]),v._v(" 指示符会增加 36 个字节的开销，从而增加了客户端和服务器之间所需的带宽。为了解决这个问题，"),e("code",[v._v("TURN")]),v._v(" 提供了第二种方法，即使用另一种数据包格式——"),e("code",[v._v("ChannelData")]),v._v(" 消息。")]),v._v(" "),e("p",[v._v("与使用 "),e("code",[v._v("Send")]),v._v(" 和 "),e("code",[v._v("Data")]),v._v(" 指示符不同，"),e("code",[v._v("ChannelData")]),v._v(" 消息不使用其他 "),e("code",[v._v("TURN")]),v._v(" 消息使用的 "),e("code",[v._v("STUN")]),v._v(" 头，而是具有一个 4 字节的头，其中包括一个称为通道号的数字。每个使用的通道号都绑定到特定的对等方，因此"),e("strong",[v._v("可作为对等方主机传输地址的简称")]),v._v("。")]),v._v(" "),e("p",[v._v("要将通道绑定到对等方，客户端向服务器发送一个 "),e("code",[v._v("ChannelBind")]),v._v(" 请求，并包括一个未绑定的通道号和对等方的传输地址。一旦通道绑定，客户端可以使用 "),e("code",[v._v("ChannelData")]),v._v(" 消息将数据发送到服务器，以便转发到对等方。同样，服务器可以使用 "),e("code",[v._v("ChannelData")]),v._v(" 消息将从对等方传输的数据中继回客户端。")]),v._v(" "),e("p",[v._v("通道绑定持续 "),e("code",[v._v("10")]),v._v(" 分钟，除非进行刷新。这个生命周期被选择得比权限生命周期长。通过发送另一个 "),e("code",[v._v("ChannelBind")]),v._v(" 请求将通道重新绑定到对等方，可以刷新通道绑定。与权限（但不同于分配），"),e("strong",[v._v("通道绑定没有显式删除的方法；客户端必须等待其超时")]),v._v("。")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("  TURN                                 TURN           Peer          Peer\n  client                               server          A             B\n    |                                    |             |             |\n    |-- ChannelBind req ----------------\x3e|             |             |\n    | (Peer A to 0x4001)                 |             |             |\n    |                                    |             |             |\n    |<---------- ChannelBind succ resp --|             |             |\n    |                                    |             |             |\n    |-- [0x4001] data ------------------\x3e|             |             |\n    |                                    |=== data ===>|             |\n    |                                    |             |             |\n    |                                    |<== data ====|             |\n    |<------------------ [0x4001] data --|             |             |\n    |                                    |             |             |\n    |--- Send ind (Peer A)--------------\x3e|             |             |\n    |                                    |=== data ===>|             |\n    |                                    |             |             |\n    |                                    |<== data ====|             |\n    |<------------------ [0x4001] data --|             |             |\n    |                                    |             |             |\n\n")])])]),e("p",[v._v("上图展示了通道机制的使用。客户端已经创建了一个分配并希望将一个通道绑定到 "),e("code",[v._v("A")]),v._v(" 对等体。为此，客户端向服务器发送一个 "),e("code",[v._v("ChannelBind")]),v._v(" 请求，指定了对等体 "),e("code",[v._v("A")]),v._v(" 的传输地址和一个通道号（"),e("code",[v._v("0x4001")]),v._v("）。之后，客户端可以使用 "),e("code",[v._v("ChannelData")]),v._v(" 消息发送封装在其中的应用程序数据到 "),e("code",[v._v("A")]),v._v(' 对等体：这在"[0x4001] '),e("code",[v._v("data")]),v._v('"中表示，其中 '),e("code",[v._v("0x4001")]),v._v(" 是通道号。当 "),e("code",[v._v("ChannelData")]),v._v(" 消息到达服务器时，服务器将数据转移到 "),e("code",[v._v("UDP")]),v._v(" 数据报中并将其发送到 "),e("code",[v._v("A")]),v._v(" 对等体（这是绑定到通道号 "),e("code",[v._v("0x4001")]),v._v(" 的对等体）。")]),v._v(" "),e("p",[v._v("在反向方向上，当对等体 "),e("code",[v._v("A")]),v._v(" 向中继传输地址发送 "),e("code",[v._v("UDP")]),v._v(" 数据报时，该 "),e("code",[v._v("UDP")]),v._v(" 数据报到达服务器并到达分配所分配的中继传输地址。由于 "),e("code",[v._v("UDP")]),v._v(" 数据报是从对等体 "),e("code",[v._v("A")]),v._v(" 接收的，该对等体有一个分配给它的通道号，因此服务器在将数据发送到客户端时将数据封装到一个 "),e("code",[v._v("ChannelData")]),v._v(" 消息中。")]),v._v(" "),e("p",[v._v("一旦绑定了通道，客户端就可以自由地混合 "),e("code",[v._v("ChannelData")]),v._v(" 消息和 "),e("code",[v._v("Send")]),v._v(" 指示。在图中，客户端稍后决定使用 "),e("code",[v._v("Send")]),v._v(" 指示而不是 "),e("code",[v._v("ChannelData")]),v._v(" 消息向 "),e("code",[v._v("A")]),v._v(" 对等体发送附加数据。例如，客户端可能会这样做，以便它可以使用 "),e("code",[v._v("DONT-FRAGMENT")]),v._v(" 属性（请参见下一节）。但是，一旦绑定了通道，服务器将始终使用 "),e("code",[v._v("ChannelData")]),v._v(" 消息，如呼叫流程所示。")]),v._v(" "),e("p",[v._v("请注意，"),e("code",[v._v("ChannelData")]),v._v(" 消息仅适用于客户端已将通道绑定到的对等体。在上面的示例中，已将对等体 "),e("code",[v._v("A")]),v._v(" 绑定到通道，但尚未将对等体 "),e("code",[v._v("B")]),v._v(" 绑定到通道，因此与对等体 "),e("code",[v._v("B")]),v._v(" 之间的应用程序数据将使用 "),e("code",[v._v("Send")]),v._v(" 机制。")]),v._v(" "),e("h3",{attrs:{id:"不需要特殊权限的-turn-服务器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不需要特殊权限的-turn-服务器"}},[v._v("#")]),v._v(" 不需要特殊权限的 "),e("code",[v._v("TURN")]),v._v(" 服务器")]),v._v(" "),e("p",[v._v("这个版本的 "),e("code",[v._v("TURN")]),v._v(" 设计得可以作为运行在普通操作系统下的用户空间应用程序，而不需要特殊权限。这个设计决策的目的是使部署 "),e("code",[v._v("TURN")]),v._v(" 服务器变得更加容易，例如，允许将 "),e("code",[v._v("TURN")]),v._v(" 服务器集成到点对点应用程序中，以便一个对等方可以为另一个对等方提供 "),e("code",[v._v("NAT")]),v._v(" 穿透服务。")]),v._v(" "),e("p",[v._v("这个设计决策对由 "),e("code",[v._v("TURN")]),v._v(" 服务器中继的数据有以下影响：")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("Diffserv")]),v._v(" 字段的值可能无法在服务器中保留；")]),v._v(" "),e("li",[e("code",[v._v("Time to Live (TTL)")]),v._v("字段可能在服务器上被重置而不是递减；")]),v._v(" "),e("li",[v._v("显式拥塞通知 ("),e("code",[v._v("ECN")]),v._v(")字段可能被服务器重置；")]),v._v(" "),e("li",[e("code",[v._v("ICMP")]),v._v(" 消息不会被服务器中继；")]),v._v(" "),e("li",[v._v("由于数据包在服务器上重新组装，因此没有端到端分段。")]),v._v(" "),e("li",[v._v("未来的工作可能会指定替代的 "),e("code",[v._v("TURN")]),v._v(" 语义，以解决这些限制。")])]),v._v(" "),e("blockquote",[e("p",[v._v("这段话在说明 "),e("code",[v._v("TURN")]),v._v(" 服务器可以作为一个普通应用程序运行，不需要特殊权限，这样就可以更容易地部署 "),e("code",[v._v("TURN")]),v._v(" 服务器，比如将 "),e("code",[v._v("TURN")]),v._v(" 服务器集成到点对点应用程序中，以使一个对等方可以为另一个对等方提供 "),e("code",[v._v("NAT")]),v._v(" 穿透服务。但是，这样做会对由 "),e("code",[v._v("TURN")]),v._v(" 服务器中继的数据产生一些影响，如 "),e("code",[v._v("DiffServ")]),v._v(" 字段可能不会在服务器上保留、"),e("code",[v._v("TTL")]),v._v(" 字段可能会被重置、"),e("code",[v._v("ECN")]),v._v(" 字段可能会被重置，服务器不会中继 "),e("code",[v._v("ICMP")]),v._v(" 消息，且由于在服务器上重新组装数据包，因此不存在端到端分段。未来可能会指定替代 "),e("code",[v._v("TURN")]),v._v(" 语义来解决这些限制。")])]),v._v(" "),e("h3",{attrs:{id:"避免-ip-分片-ip-fragmentation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#避免-ip-分片-ip-fragmentation"}},[v._v("#")]),v._v(" 避免 IP 分片（"),e("code",[v._v("IP fragmentation")]),v._v("）")]),v._v(" "),e("p",[v._v("分片会影响数据传输的效率和性能。")]),v._v(" "),e("p",[v._v("对于使用 "),e("code",[v._v("UDP")]),v._v(" 协议的应用程序，它们需要自行处理分片问题。为了避免分片，可以采用两种方法：")]),v._v(" "),e("p",[v._v("第一种方法是避免在 "),e("code",[v._v("TURN")]),v._v(" 消息"),e("code",[v._v("/UDP")]),v._v(" 数据报中发送大量应用数据。这种方法主要用于 "),e("code",[v._v("VoIP")]),v._v(" 应用程序。因为根据 "),e("code",[v._v("IP")]),v._v(" 规范，"),e("code",[v._v("IP")]),v._v(" 数据包最大应该不超过 576 字节，如果超过这个大小，就会被分片。因此，应该尽量控制单个 "),e("code",[v._v("TURN")]),v._v(" 消息"),e("code",[v._v("/UDP")]),v._v(" 数据报中发送的应用数据不超过 500 字节。")]),v._v(" "),e("p",[v._v("另一种方法是使用路径 "),e("code",[v._v("MTU")]),v._v(" 发现算法，该算法可以自动检测数据包可以传输的最大大小。然而，由于这个版本的 "),e("code",[v._v("TURN")]),v._v(" 服务器不会中继 "),e("code",[v._v("ICMP")]),v._v(" 消息，所以不能使用标准的路径 "),e("code",[v._v("MTU")]),v._v(" 发现算法（"),e("code",[v._v("RFC1191")]),v._v("）。因此，可以使用 "),e("code",[v._v("Packetized Path MTU Discovery")]),v._v(" 算法（"),e("code",[v._v("RFC4821")]),v._v("）来避免分片问题。")]),v._v(" "),e("p",[v._v("不过，该算法的具体实现还在研究中。为了解决这个问题，这个版本的 "),e("code",[v._v("TURN")]),v._v(" 协议引入了一个 "),e("code",[v._v("DONT-FRAGMENT")]),v._v(" 属性，当客户端在发送一个发送指示时包含这个属性，它告诉服务器在将 "),e("code",[v._v("UDP")]),v._v(" 数据报发送给对等方时将 "),e("code",[v._v("DF")]),v._v(" 位设置为 1。如果服务器无法设置 "),e("code",[v._v("DF")]),v._v(" 位，则需要拒绝分配请求。")]),v._v(" "),e("h3",{attrs:{id:"rtp支持"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rtp支持"}},[v._v("#")]),v._v(" "),e("code",[v._v("RTP")]),v._v("支持")]),v._v(" "),e("p",[v._v("旧版本的 "),e("code",[v._v("RTP")]),v._v(" 要求 "),e("code",[v._v("RTP")]),v._v(" 流使用偶数端口，而关联的 "),e("code",[v._v("RTP")]),v._v(" 控制协议（"),e("code",[v._v("RTCP")]),v._v("）流（如果存在）则使用下一个最高端口号。为了允许客户端与仍然需要使用旧版本 "),e("code",[v._v("RTP")]),v._v(" 的对等方进行通信，"),e("code",[v._v("TURN")]),v._v(" 协议允许客户端请求服务器分配一个具有偶数端口号的转发传输地址，并可选择请求服务器保留下一个最高的端口号以供后续使用。")]),v._v(" "),e("h3",{attrs:{id:"支持通过-udp-进行-turn-服务器的-anycast-发现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#支持通过-udp-进行-turn-服务器的-anycast-发现"}},[v._v("#")]),v._v(" 支持通过 "),e("code",[v._v("UDP")]),v._v(" 进行 "),e("code",[v._v("TURN")]),v._v(" 服务器的 "),e("code",[v._v("anycast")]),v._v(" 发现")]),v._v(" "),e("p",[v._v("具体地说，"),e("code",[v._v("TURN")]),v._v(" 服务器可以通过拒绝 "),e("code",[v._v("Allocate")]),v._v(" 请求并建议客户端尝试另一个服务器来支持 "),e("code",[v._v("anycast")]),v._v(" 发现。为了避免某些类型的攻击，客户端必须与备选服务器使用与初始服务器相同的凭证。")]),v._v(" "),e("blockquote",[e("p",[e("code",[v._v("TURN")]),v._v(" 支持通过 "),e("code",[v._v("UDP")]),v._v(" 进行任播（"),e("code",[v._v("anycast")]),v._v("）发现 "),e("code",[v._v("TURN")]),v._v(" 服务器的方法。具体来说，如果一个 "),e("code",[v._v("TURN")]),v._v(" 服务器无法为客户端分配一个有效的地址，则服务器可以建议客户端尝试其他备用服务器。需要注意的是，为了避免某些类型的攻击，客户端必须在备用服务器上使用与初始服务器相同的凭据进行身份验证。因此，"),e("code",[v._v("TURN")]),v._v(" 支持任播发现可以帮助客户端更可靠地发现并连接到可用的 "),e("code",[v._v("TURN")]),v._v(" 服务器，以提供更好的服务质量和可靠性。")])]),v._v(" "),e("h2",{attrs:{id:"术语"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#术语"}},[v._v("#")]),v._v(" 术语")]),v._v(" "),e("p",[v._v("本文中的关键词“"),e("code",[v._v("MUST")]),v._v("”、“"),e("code",[v._v("MUST NOT")]),v._v("”、“"),e("code",[v._v("REQUIRED")]),v._v("”、“"),e("code",[v._v("SHALL")]),v._v("”、“"),e("code",[v._v("SHALL NOT")]),v._v("”、“"),e("code",[v._v("SHOULD")]),v._v("”、“"),e("code",[v._v("SHOULD NOT")]),v._v("”、“"),e("code",[v._v("RECOMMENDED")]),v._v("”、“"),e("code",[v._v("MAY")]),v._v("”和“"),e("code",[v._v("OPTIONAL")]),v._v("”按照 "),e("code",[v._v("RFC 2119")]),v._v(" 中的描述进行解释。")]),v._v(" "),e("p",[v._v("读者应熟悉 "),e("code",[v._v("RFC 5389")]),v._v(" 和其中定义的术语。")]),v._v(" "),e("p",[v._v("本文中使用以下术语：")]),v._v(" "),e("p",[e("code",[v._v("TURN")]),v._v("："),e("code",[v._v("TURN")]),v._v(" 客户端和 "),e("code",[v._v("TURN")]),v._v(" 服务器之间通信的协议。它是 "),e("code",[v._v("STUN")]),v._v(" 协议 [RFC5389] 的扩展。该协议允许客户端分配和使用中继传输地址。")]),v._v(" "),e("p",[e("code",[v._v("TURN")]),v._v(" 客户端：实现本规范的 "),e("code",[v._v("STUN")]),v._v(" 客户端。")]),v._v(" "),e("p",[e("code",[v._v("TURN")]),v._v(" 服务器：实现本规范的 "),e("code",[v._v("STUN")]),v._v(" 服务器。它在 "),e("code",[v._v("TURN")]),v._v(" 客户端和其对等方之间中继数据。")]),v._v(" "),e("p",[v._v("对等方："),e("code",[v._v("TURN")]),v._v(" 客户端希望与之通信的主机。"),e("code",[v._v("TURN")]),v._v(" 服务器中继 "),e("code",[v._v("TURN")]),v._v(" 客户端和其对等方之间的流量。对等方不使用本文档中定义的协议与 "),e("code",[v._v("TURN")]),v._v(" 服务器进行交互。相反，对等方通过 "),e("code",[v._v("TURN")]),v._v(" 服务器接收发送的数据，并将数据发送到 "),e("code",[v._v("TURN")]),v._v(" 服务器。")]),v._v(" "),e("p",[v._v("传输地址："),e("code",[v._v("IP")]),v._v(" 地址和端口的组合。")]),v._v(" "),e("p",[v._v("主机传输地址：客户端或对等方的传输地址。")]),v._v(" "),e("p",[v._v("服务器反射传输地址：在 "),e("code",[v._v("NAT")]),v._v(" 的“公共侧”的传输地址。该地址由 "),e("code",[v._v("NAT")]),v._v(" 分配，以对应特定的主机传输地址。")]),v._v(" "),e("p",[v._v("中继传输地址：用于在客户端和对等方之间中继数据包的 "),e("code",[v._v("TURN")]),v._v(" 服务器上的传输地址。对等方向这个地址发送数据，然后数据包被中继到客户端。")]),v._v(" "),e("p",[e("code",[v._v("TURN")]),v._v(" 服务器传输地址：用于将 "),e("code",[v._v("TURN")]),v._v(" 消息发送到服务器的传输地址。这是客户端用来与服务器通信的传输地址。")]),v._v(" "),e("p",[v._v("对等方传输地址：服务器所看到的对等方的传输地址。当对等方在 "),e("code",[v._v("NAT")]),v._v(" 后面时，这是对等方的服务器反射传输地址。")]),v._v(" "),e("p",[v._v("分配：通过 "),e("code",[v._v("Allocate")]),v._v(" 请求授予客户端的中继传输地址，以及相关状态，例如权限和过期计时器。")]),v._v(" "),e("p",[v._v("5 元组：用于在客户端和服务器之间通信的组合（客户端 "),e("code",[v._v("IP")]),v._v(" 地址和端口、服务器 "),e("code",[v._v("IP")]),v._v(" 地址和端口以及传输协议（目前为 "),e("code",[v._v("UDP")]),v._v("、"),e("code",[v._v("TCP")]),v._v(" 或 "),e("code",[v._v("TLS")]),v._v("））。5 元组唯一标识此通信流。5 元组还唯一标识服务器上的分配。")]),v._v(" "),e("p",[v._v("通道：通道号和关联的对等方传输地址。一旦将通道号绑定到对等方的传输地址，客户端和服务器可以使用更有效带宽的 "),e("code",[v._v("ChannelData")]),v._v(" 消息交换数据。")]),v._v(" "),e("p",[v._v("权限：允许向 "),e("code",[v._v("TURN")]),v._v(" 服务器发送流量并使该流量中继到 "),e("code",[v._v("TURN")]),v._v(" 客户端的对等方的 "),e("code",[v._v("IP")]),v._v(" 地址和传输协议（但不是端口）。"),e("code",[v._v("TURN")]),v._v(" 服务器仅会从匹配现有权限的对等方")]),v._v(" "),e("h2",{attrs:{id:"一般行为"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一般行为"}},[v._v("#")]),v._v(" 一般行为")]),v._v(" "),e("p",[e("code",[v._v("TURN")]),v._v(" 是 "),e("code",[v._v("STUN")]),v._v(" 的扩展。除了 "),e("code",[v._v("ChannelData")]),v._v(" 消息外，所有 "),e("code",[v._v("TURN")]),v._v(" 消息都是 "),e("code",[v._v("STUN")]),v._v(" 格式的消息。所有在[RFC5389]中描述的基本处理规则都适用于 "),e("code",[v._v("STUN")]),v._v(" 格式的消息。这意味着本文档中所有关于消息形成和消息处理的描述都隐含着[RFC5389]的规则。")]),v._v(" "),e("p",[v._v("[RFC5389]规定了一种称为长期凭据机制的身份验证机制。"),e("code",[v._v("TURN")]),v._v(" 服务器和客户端必须实现此机制。服务器必须要求客户端使用此机制对所有请求进行身份验证，或者使用等同或更强的客户端身份验证机制。**长期凭据机制仅适用于请求，不能用于认证 "),e("code",[v._v("indication")]),v._v("。**因此，"),e("code",[v._v("TURN")]),v._v(" 中的 "),e("code",[v._v("indication")]),v._v(" 永远不会得到认证。如果服务器要求请求进行身份验证，则服务器的管理员必须选择一个域值，以便唯一标识用户名和密码组合，即使客户端在不同的管理下使用不同的服务器。服务器的管理员可以为每个客户端分配唯一的用户名，也可以为多个客户端分配相同的用户名（例如，为同一部门或公司的所有客户端分配相同的用户名）。对于每个分配，服务器在首次尝试分配时应该使用[RFC4086]中的建议的随机性原则生成一个新的随机 "),e("code",[v._v("nonce")]),v._v("，并且在分配的生命周期中应该每小时至少过期 "),e("code",[v._v("nonce")]),v._v(" 一次。")]),v._v(" "),e("p",[v._v("除了初始 "),e("code",[v._v("Allocate")]),v._v(" 请求之外的所有请求必须使用与创建分配时使用的相同的用户名，以防止攻击者劫持客户端的分配。具体来说，如果服务器要求使用长期凭据机制，并且如果非 "),e("code",[v._v("Allocate")]),v._v(" 请求在此机制下通过了身份验证，并且如果 "),e("code",[v._v("5-tuple")]),v._v(" 标识现有分配，但请求未使用与创建分配时使用的相同的用户名，则请求必须用 441（"),e("code",[v._v("Wrong Credentials")]),v._v("）错误拒绝。")]),v._v(" "),e("p",[v._v("当 "),e("code",[v._v("TURN")]),v._v(" 消息从客户端到达服务器时，服务器使用消息中的 "),e("code",[v._v("5-tuple")]),v._v(" 来标识相关的分配。对于所有 "),e("code",[v._v("TURN")]),v._v(" 消息（包括 "),e("code",[v._v("ChannelData")]),v._v("），如果 "),e("code",[v._v("5-tuple")]),v._v(" 未标识现有分配，则消息必须使用 437 "),e("code",[v._v("Allocation Mismatch")]),v._v(" 错误拒绝（如果它是请求），或者默默地被忽略（如果它是 "),e("code",[v._v("indication")]),v._v(" 或 "),e("code",[v._v("ChannelData")]),v._v(" 消息）。接收到除 "),e("code",[v._v("Allocate")]),v._v(" 之外的请求的 437 错误响应的客户端必须假定分配不再存在。")]),v._v(" "),e("p",[v._v("[RFC5389]定义了许多属性，包括 "),e("code",[v._v("SOFTWARE")]),v._v(" 和 "),e("code",[v._v("FINGERPRINT")]),v._v(" 属性。客户端应该在所有 "),e("code",[v._v("Allocate")]),v._v(" 和 "),e("code",[v._v("Refresh")]),v._v(" 请求中包括 "),e("code",[v._v("SOFTWARE")]),v._v(" 属性，并可以在任何其他请求或 "),e("code",[v._v("indication")]),v._v(" 中包括它。服务器应该在所有 "),e("code",[v._v("Allocate")]),v._v(" 和 "),e("code",[v._v("Refresh")]),v._v(" 响应（成功或失败）中包含 "),e("code",[v._v("SOFTWARE")]),v._v(" 属性，并可以在其他响应或 "),e("code",[v._v("indication")]),v._v(" 中包含它。客户端和服务器可以在")]),v._v(" "),e("p",[e("code",[v._v("TURN")]),v._v(" 协议不使用 "),e("code",[v._v("STUN")]),v._v(" 协议中描述的向后兼容机制。"),e("code",[v._v("TURN")]),v._v(" 只支持 "),e("code",[v._v("IPv4")]),v._v("，客户端的 "),e("code",[v._v("IP")]),v._v(" 地址、服务器的 "),e("code",[v._v("IP")]),v._v(" 地址以及出现在转发传输地址中的所有 "),e("code",[v._v("IP")]),v._v(" 地址都必须是 "),e("code",[v._v("IPv4")]),v._v(" 地址。"),e("code",[v._v("TURN")]),v._v(" 默认使用与 "),e("code",[v._v("STUN")]),v._v(" 相同的端口号："),e("code",[v._v("UDP")]),v._v(" 和 "),e("code",[v._v("TCP")]),v._v(" 上的 3478 端口，"),e("code",[v._v("TLS")]),v._v(" 上的 5349 端口。但是，"),e("code",[v._v("TURN")]),v._v(" 也有自己的服务记录（"),e("code",[v._v("SRV")]),v._v("）名称："),e("code",[v._v("UDP")]),v._v(" 和 "),e("code",[v._v("TCP")]),v._v(' 上的 "'),e("code",[v._v("turn")]),v._v('"，'),e("code",[v._v("TLS")]),v._v(' 上的 "'),e("code",[v._v("turns")]),v._v('"。可以使用 '),e("code",[v._v("SRV")]),v._v(" 过程或在第 6 节中描述的 "),e("code",[v._v("ALTERNATE-SERVER")]),v._v(" 过程来在不同的端口上运行 "),e("code",[v._v("TURN")]),v._v("。为确保互操作性，"),e("code",[v._v("TURN")]),v._v(" 服务器必须支持客户端和服务器之间的 "),e("code",[v._v("UDP")]),v._v(" 传输，并应支持 "),e("code",[v._v("TCP")]),v._v(" 和 "),e("code",[v._v("TLS")]),v._v(" 传输。")]),v._v(" "),e("p",[v._v("当使用 "),e("code",[v._v("UDP")]),v._v(" 传输时，如果客户端在一定的超时时间内没有收到响应，则会重新发送请求。因此，服务器可能会接收到具有相同 5 元组和相同事务 "),e("code",[v._v("ID")]),v._v(" 的两个或多个请求。"),e("code",[v._v("STUN")]),v._v(' 要求服务器识别这种情况并将请求视为幂等的（参见[RFC5389]）。一些实现可能会通过记住所有接收到的请求及其相应的响应 40 秒来满足这个要求。其他实现可能会重新处理请求并安排这种重新处理返回基本相同的响应。为帮助选择后者（即所谓的 "无状态堆栈方法"）的实现者，本规范包括一些实现说明。实现可以选择任一方法或选择给出相同结果的其他方法。')]),v._v(" "),e("p",[v._v("当在客户端和服务器之间使用 "),e("code",[v._v("TCP")]),v._v(" 传输时，一个比特错误可能会导致 "),e("code",[v._v("TURN")]),v._v(" 包中的长度字段被损坏，从而导致接收方与传入的 "),e("code",[v._v("TURN")]),v._v(" 消息流失去同步。检测到在 "),e("code",[v._v("TCP")]),v._v(" 传输上长时间的无效的 "),e("code",[v._v("TURN")]),v._v(" 消息序列的客户端或服务器应关闭相应的 "),e("code",[v._v("TCP")]),v._v(" 连接，以帮助另一端更快地检测到此情况。")]),v._v(" "),e("p",[v._v("为了缓解客户端的拒绝服务攻击，"),e("code",[v._v("TURN")]),v._v(" 服务器应对给定用户名的同时处于活动状态的分配数量和这些分配所使用的带宽量进行限制。服务器应该使用 486 ("),e("code",[v._v("Allocation Quota Exceeded")]),v._v(") 拒绝超出允许的同时处于活动状态的分配数量的新分配（参见第 6.2 节），并且应该丢弃超出带宽配额的应用数据流量。")]),v._v(" "),e("h2",{attrs:{id:"allocations"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#allocations"}},[v._v("#")]),v._v(" "),e("code",[v._v("allocations")])]),v._v(" "),e("p",[v._v("在 "),e("code",[v._v("TURN")]),v._v(" 中，所有操作都围绕着 "),e("code",[v._v("allocation")]),v._v(" 进行，所有 "),e("code",[v._v("TURN")]),v._v(" 消息都与一个 "),e("code",[v._v("allocation")]),v._v(" 相关联。")]),v._v(" "),e("p",[v._v("一个 "),e("code",[v._v("allocation")]),v._v(" 包括以下状态数据：")]),v._v(" "),e("ul",[e("li",[v._v("转发传输地址；")]),v._v(" "),e("li",[v._v("5 元组：（客户端 "),e("code",[v._v("IP")]),v._v(" 地址，客户端端口，服务器 "),e("code",[v._v("IP")]),v._v(" 地址，服务器端口，传输协议）；")]),v._v(" "),e("li",[v._v("鉴权信息；")]),v._v(" "),e("li",[v._v("到期时间；")]),v._v(" "),e("li",[v._v("权限列表；")]),v._v(" "),e("li",[v._v("通道到对等体绑定的列表。")])]),v._v(" "),e("p",[v._v("其中，转发传输地址是由服务器为与对等体通信而分配的传输地址，5 元组描述了客户端和服务器之间的通信路径。在客户端，5 元组使用客户端的主机传输地址；在服务器端，5 元组使用客户端的服务器反射传输地址。")]),v._v(" "),e("p",[v._v("转发传输地址和 5 元组必须在所有分配中唯一，因此可以使用其中一个来唯一标识分配。")]),v._v(" "),e("p",[v._v("鉴权信息（例如用户名、密码、领域和 "),e("code",[v._v("nonce")]),v._v("）用于验证后续请求和计算响应的消息完整性。用户名、领域和 "),e("code",[v._v("nonce")]),v._v(" 值最初是在身份验证 "),e("code",[v._v("Allocate")]),v._v(" 请求中使用的，创建 "),e("code",[v._v("allocation")]),v._v("，尽管服务器可以在 "),e("code",[v._v("allocation")]),v._v(" 的生命周期内使用 438（"),e("code",[v._v("Stale Nonce")]),v._v("）应答更改 "),e("code",[v._v("nonce")]),v._v(" 值。注意，出于安全原因，服务器可能希望存储密钥值，而不是明文存储密码，密钥值是对用户名、领域和密码进行 "),e("code",[v._v("MD5")]),v._v(" 哈希的结果。")]),v._v(" "),e("p",[v._v("到期时间是指到 "),e("code",[v._v("allocation")]),v._v(" 过期的剩余时间（以秒为单位）。每个 "),e("code",[v._v("Allocate")]),v._v(" 或 "),e("code",[v._v("Refresh")]),v._v(" 事务都设置此计时器，然后向 0 滴答。默认情况下，每个 "),e("code",[v._v("Allocate")]),v._v(" 或 "),e("code",[v._v("Refresh")]),v._v(" 事务将此计时器重置为默认生存时间值 600 秒（10 分钟），但客户端可以在 "),e("code",[v._v("Allocate")]),v._v(" 和 "),e("code",[v._v("Refresh")]),v._v(" 请求中请求不同的值。"),e("code",[v._v("Allocation")]),v._v(" 只能使用 "),e("code",[v._v("Refresh")]),v._v(" 请求进行刷新；向对等方发送数据不会刷新分配。当一个 "),e("code",[v._v("allocation")]),v._v(" 过期时，与 "),e("code",[v._v("allocation")]),v._v(" 相关联的状态数据可以被释放。")]),v._v(" "),e("p",[v._v("权限列表在第 8 节中描述，通道列表在第 11 节中描述。")]),v._v(" "),e("h2",{attrs:{id:"allocation-的创建"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#allocation-的创建"}},[v._v("#")]),v._v(" "),e("code",[v._v("allocation")]),v._v(" 的创建")]),v._v(" "),e("p",[v._v("在服务器上创建一个分配使用 "),e("code",[v._v("Allocate")]),v._v(" 事务。")]),v._v(" "),e("h3",{attrs:{id:"发送-allocate-请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#发送-allocate-请求"}},[v._v("#")]),v._v(" 发送 "),e("code",[v._v("Allocate")]),v._v(" 请求")]),v._v(" "),e("p",[v._v("客户端按照以下方式形成 "),e("code",[v._v("Allocate")]),v._v(" 请求。")]),v._v(" "),e("p",[v._v("客户端首先选择一个主机传输地址。推荐客户端选择一个当前未使用的传输地址，通常是通过允许底层操作系统为新的套接字选择当前未使用的端口来实现。")]),v._v(" "),e("p",[v._v("然后客户端选择在客户端和服务器之间使用的传输协议。传输协议必须是 "),e("code",[v._v("UDP")]),v._v("、"),e("code",[v._v("TCP")]),v._v(" 或 "),e("code",[v._v("TLS-over-TCP")]),v._v(" 之一。由于本规范仅允许服务器和对等方之间使用 "),e("code",[v._v("UDP")]),v._v("，因此除非客户端有理由使用不同的传输方式，否则建议客户端选择 "),e("code",[v._v("UDP")]),v._v("。选择不同传输的一个原因是客户端相信，通过配置或实验，它无法使用 "),e("code",[v._v("UDP")]),v._v(" 联系任何 "),e("code",[v._v("TURN")]),v._v(" 服务器。更多讨论请参见第 2.1 节。")]),v._v(" "),e("p",[v._v("客户端还要选择服务器传输地址，应按以下方式完成。客户端接收到（可能通过配置）用于 "),e("code",[v._v("TURN")]),v._v(" 服务器的域名。然后客户端使用[RFC5389]中描述的 "),e("code",[v._v("DNS")]),v._v(' 过程，但使用 "'),e("code",[v._v("turn")]),v._v('"（或 "'),e("code",[v._v("turns")]),v._v('" 用于 '),e("code",[v._v("TURN over TLS")]),v._v("）作为 "),e("code",[v._v("SRV")]),v._v(' 服务名称，而不是 "'),e("code",[v._v("stun")]),v._v('"（或 "'),e("code",[v._v("stuns")]),v._v('"）。例如，要在 '),e("code",[v._v("example.com")]),v._v(" 域中查找服务器，则客户端将查找 '"),e("code",[v._v("_turn._udp.example.com")]),v._v("'、'"),e("code",[v._v("_turn._tcp.example.com")]),v._v("' 和 '"),e("code",[v._v("_turns._tcp.example.com")]),v._v("'，如果客户端希望使用 "),e("code",[v._v("UDP")]),v._v("、"),e("code",[v._v("TCP")]),v._v(" 或 "),e("code",[v._v("TLS-over-TCP")]),v._v(" 与服务器通信，则分别执行上述操作。")]),v._v(" "),e("p",[v._v("客户端必须在请求中包括 "),e("code",[v._v("REQUESTED-TRANSPORT")]),v._v(" 属性。该属性指定服务器和对等方之间的传输协议（请注意，这不是出现在 5 元组中的传输协议）。在本规范中，**"),e("code",[v._v("REQUESTED-TRANSPORT")]),v._v(" 类型始终为 "),e("code",[v._v("UDP")]),v._v("。**包含此属性是为了允许将来的扩展指定其他协议。")]),v._v(" "),e("p",[v._v("如果客户端希望服务器将分配的 "),e("code",[v._v("time-to-expiry")]),v._v(" 字段初始化为某个除默认生存时间以外的值，则可以包括 "),e("code",[v._v("LIFETIME")]),v._v(" 属性指定其所需值。这只是一个请求，服务器可以选择使用不同的值。请注意，服务器将忽略将字段初始化为小于默认值的请求。")]),v._v(" "),e("p",[v._v("如果客户端希望稍后在此分配中的一个或多个 "),e("code",[v._v("Send")]),v._v(" 指示中使用 "),e("code",[v._v("DONT-FRAGMENT")]),v._v(" 属性，则客户端应在 "),e("code",[v._v("Allocate")]),v._v(" 请求中包括 "),e("code",[v._v("DONT-FRAGMENT")]),v._v(" 属性。这允许客户端测试服务器是否支持此属性。")]),v._v(" "),e("p",[v._v("如果客户端要求转发传输地址的端口号为偶数，则客户端包括 "),e("code",[v._v("EVEN-PORT")]),v._v(" 属性。如果未包括此属性，则端口可以是偶数或奇数。通过将 "),e("code",[v._v("EVEN-PORT")]),v._v(" 属性中的 "),e("code",[v._v("R")]),v._v(" 位设置为 1，客户端可以请求服务器")]),v._v(" "),e("p",[v._v("客户端还可以在请求中包括 "),e("code",[v._v("RESERVATION-TOKEN")]),v._v(" 属性，以请求服务器为分配使用先前保留的端口。如果包括 "),e("code",[v._v("RESERVATION-TOKEN")]),v._v(" 属性，则必须省略 "),e("code",[v._v("EVEN-PORT")]),v._v(" 属性。客户端构造好请求之后，会在 "),e("code",[v._v("5-tuple")]),v._v(" 上发送 "),e("code",[v._v("Allocate")]),v._v(" 请求。")]),v._v(" "),e("h3",{attrs:{id:"接收-allocate-请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接收-allocate-请求"}},[v._v("#")]),v._v(" 接收 "),e("code",[v._v("Allocate")]),v._v(" 请求")]),v._v(" "),e("p",[v._v("关于接收 "),e("code",[v._v("Allocate")]),v._v(" 请求的处理步骤，下面是处理的具体流程：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("服务器必须验证请求的身份，使用 "),e("code",[v._v("RFC5389")]),v._v(" 中的长期凭证机制进行身份验证，除非客户端和服务器约定使用此文档范围之外的其他机制。")])]),v._v(" "),e("li",[e("p",[v._v("服务器检查 "),e("code",[v._v("5-tuple")]),v._v(" 是否已被现有分配占用。如果是，则使用 437（分配不匹配）错误拒绝请求。")])]),v._v(" "),e("li",[e("p",[v._v("服务器检查请求是否包含 "),e("code",[v._v("REQUESTED-TRANSPORT")]),v._v(" 属性。如果未包含或格式错误，则使用 400（错误请求）错误拒绝请求。否则，如果属性包含但指定的协议不是 "),e("code",[v._v("UDP")]),v._v("，则使用 442（不支持的传输协议）错误拒绝请求。")])]),v._v(" "),e("li",[e("p",[v._v("请求可能包含 "),e("code",[v._v("DONT-FRAGMENT")]),v._v(" 属性。如果包含，但服务器不支持将 "),e("code",[v._v("UDP")]),v._v(" 数据报发送时将 "),e("code",[v._v("DF")]),v._v(" 位设置为 1，则服务器将在分配请求中将 "),e("code",[v._v("DONT-FRAGMENT")]),v._v(" 属性视为未知的必选属性。")])]),v._v(" "),e("li",[e("p",[v._v("服务器检查请求是否包含 "),e("code",[v._v("RESERVATION-TOKEN")]),v._v(" 属性。如果是，并且请求还包含 "),e("code",[v._v("EVEN-PORT")]),v._v(" 属性，则服务器将使用 400（错误请求）错误拒绝请求。否则，它将检查令牌是否有效（即，令牌在范围内且未过期，并且相应的中继传输地址仍可用）。如果由于某种原因令牌无效，则服务器将使用 508（容量不足）错误拒绝请求。")])])]),v._v(" "),e("p",[v._v("服务器检查请求是否包含 "),e("code",[v._v("EVEN-PORT")]),v._v(" 属性。如果是，则服务器将检查是否能够满足请求（即，可以分配中继传输地址，如下所述）。如果服务器无法满足请求，则服务器将使用 508（容量不足）错误拒绝请求。")]),v._v(" "),e("p",[v._v("服务器可以随时选择使用 486（分配配额已达上限）错误拒绝请求，如果服务器认为客户端试图超过某些本地定义的分配配额。服务器可以自由地定义此分配配额的方式，但应基于用于验证请求的用户名定义，而不是客户端的传输地址。")]),v._v(" "),e("p",[v._v("也可以随时选择使用 300（尝试其他）错误拒绝请求，如果服务器希望将客户端重定向到另一个服务器。使用此错误代码和属性遵循 [RFC5389] 中的规范。")]),v._v(" "),e("p",[v._v("如果所有检查都通过，服务器将创建分配。"),e("code",[v._v("5-tuple")]),v._v(" 设置为 "),e("code",[v._v("Allocate")]),v._v(" 请求中的 "),e("code",[v._v("5-tuple")]),v._v("，而权限列表和通道列表最初为空。")]),v._v(" "),e("p",[v._v("服务器为分配选择中继传输地址，如下所示：")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("如果请求包含 "),e("code",[v._v("RESERVATION-TOKEN")]),v._v("，则服务器使用与包含的令牌对应的先前保留的传输地址（如果仍可用）。请注意，保留是服务器范围的保留，不针对特定分配，因为包含 "),e("code",[v._v("RESERVATION-TOKEN")]),v._v(" 的 "),e("code",[v._v("Allocate")]),v._v(" 请求使用不同的 5 元组，而不是进行预订的 "),e("code",[v._v("Allocate")]),v._v(" 请求。包含 "),e("code",[v._v("RESERVATION-TOKEN")]),v._v(" 属性的 "),e("code",[v._v("Allocate")]),v._v(" 请求的 5 元组可以是任何允许的 5 元组；它可以使用不同的客户端 "),e("code",[v._v("IP")]),v._v(" 地址和端口，不同的传输协议，甚至不同的服务器 "),e("code",[v._v("IP")]),v._v(" 地址和端口（当然，服务器 "),e("code",[v._v("IP")]),v._v(" 地址和端口是服务器用于侦听 "),e("code",[v._v("TURN")]),v._v(" 请求的地址）。")])]),v._v(" "),e("li",[e("p",[v._v("如果请求包含 "),e("code",[v._v("R")]),v._v(" 位设置为 0 的 "),e("code",[v._v("EVEN-PORT")]),v._v(" 属性，则服务器分配具有偶数端口号的中继传输地址。")])]),v._v(" "),e("li",[e("p",[v._v("如果请求包含 "),e("code",[v._v("R")]),v._v(" 位设置为 1 的 "),e("code",[v._v("EVEN-PORT")]),v._v(" 属性，则服务器查找同一 "),e("code",[v._v("IP")]),v._v(" 地址上的一对端口号 "),e("code",[v._v("N")]),v._v(" 和 "),e("code",[v._v("N + 1")]),v._v("，其中 "),e("code",[v._v("N")]),v._v(" 为偶数。端口 "),e("code",[v._v("N")]),v._v(" 用于当前分配，而分配 "),e("code",[v._v("N + 1")]),v._v(" 的中继传输地址被分配一个令牌并保留供将来使用。服务器必须至少保留此保留 30 秒，并且可以选择保留更长时间（例如，直到端口 "),e("code",[v._v("N")]),v._v(" 的分配到期）。然后，服务器在成功响应中包含令牌中的 "),e("code",[v._v("RESERVATION-TOKEN")]),v._v(" 属性。")])]),v._v(" "),e("li",[e("p",[v._v("否则，服务器分配任何可用的中继传输地址。")])])]),v._v(" "),e("p",[v._v("在所有情况下，服务器应仅从范围为 "),e("code",[v._v("49152-65535")]),v._v("（动态和/或私有端口范围[Port-Numbers]）中分配端口，除非 "),e("code",[v._v("TURN")]),v._v(" 服务器应用程序通过此处未指定的某些方式知道该主机上运行的其他应用程序不会受到分配超出此范围的端口的影响。这个条件通常可以通过在专用机器上运行 "),e("code",[v._v("TURN")]),v._v(" 服务器应用程序和/或安排机器上的任何其他应用程序在 "),e("code",[v._v("TURN")]),v._v(" 服务器应用程序启动之前分配端口来满足")]),v._v(" "),e("p",[e("code",[v._v("TURN")]),v._v(" 协议中 "),e("code",[v._v("Allocate")]),v._v(" 请求的处理过程。"),e("code",[v._v("Allocate")]),v._v(" 请求用于创建一个新的转发地址，从而使得客户端可以通过 "),e("code",[v._v("TURN")]),v._v(" 服务器进行数据包的转发。")]),v._v(" "),e("p",[v._v("首先，服务器接收到 "),e("code",[v._v("Allocate")]),v._v(" 请求后，会根据请求中的 "),e("code",[v._v("LIFETIME")]),v._v(" 属性和服务器的最大允许生存时间，计算出一个时间到期的值，用于设置这个转发地址的生存时间。如果计算出来的时间到期值大于默认的生存时间，则使用计算出来的生存时间，否则使用默认的生存时间。")]),v._v(" "),e("p",[v._v("服务器创建完成这个转发地址后，会向客户端返回一个成功的响应，包括转发地址、生存时间、保留令牌和客户端的 "),e("code",[v._v("IP")]),v._v(" 地址和端口等信息。其中，客户端的 "),e("code",[v._v("IP")]),v._v(" 地址和端口信息可以用于 "),e("code",[v._v("ICE")]),v._v(" 协议中的网络地址收集过程，以帮助客户端选择最佳的对等方通信。")]),v._v(" "),e("p",[v._v("需要注意的是，当 "),e("code",[v._v("Allocate")]),v._v(" 请求使用 "),e("code",[v._v("UDP")]),v._v(" 进行传输时，服务器需要处理可能的请求重传问题，以避免重复创建多个转发地址。为了实现这一点，服务器可以使用“无状态堆栈”方法来检测请求是否为重复请求，并根据之前创建的转发地址状态数据来生成响应。如果之前创建的请求已经成功创建了一个转发地址，则服务器可以从之前的状态数据中获取时间到期值，并在响应中使用该值作为生存时间。如果之前的请求失败了，则服务器可能不会采取任何特殊措施。但是需要注意，由于某些条件的改变，原始请求被拒绝但是重复请求被接受的情况很少见。如果客户端接收到了第一个失败的响应，则会忽略第二个（成功的）响应，并认为未成功创建转发地址。这种情况下创建的转发地址最终会超时，因为客户端不会进行刷新。此外，如果客户端稍后使用相同的 5 元组但不同的事务 "),e("code",[v._v("ID")]),v._v(" 重试，则会收到一个 437（分配不匹配）的响应，这将导致客户端尝试使用不同的 5 元组。服务器可以使用较小的最大生存时间值来最小化以这种方式“丢失”的转发地址的生存时间。")]),v._v(" "),e("h3",{attrs:{id:"接收分配成功响应"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接收分配成功响应"}},[v._v("#")]),v._v(" 接收分配成功响应")]),v._v(" "),e("p",[v._v("如果客户端收到分配成功响应，则必须检查映射地址和中继传输地址是否属于客户端理解和准备处理的地址族。本规范仅涵盖这两个地址为 "),e("code",[v._v("IPv4")]),v._v(" 地址的情况。如果这两个地址不属于客户端准备处理的地址族，则客户端必须删除分配（第 7 节）并且在认为不匹配已得到修复之前，不得尝试在该服务器上创建另一个分配。")]),v._v(" "),e("p",[e("code",[v._v("IETF")]),v._v(" 目前正在考虑在 "),e("code",[v._v("IPv4")]),v._v(" 和 "),e("code",[v._v("IPv6")]),v._v(" 之间进行过渡的机制，可能导致客户端通过 "),e("code",[v._v("IPv6")]),v._v(" 发起 "),e("code",[v._v("Allocate")]),v._v(" 请求，但该请求会通过 "),e("code",[v._v("IPv4")]),v._v(" 到达服务器，反之亦然。")]),v._v(" "),e("p",[v._v("否则，客户端将创建自己的分配数据结构的副本以跟踪服务器上正在发生的情况。特别地，客户端需要记住从服务器接收到的实际生存时间，而不是发送到服务器请求中的值。")]),v._v(" "),e("p",[v._v("客户端还必须记住用于请求的 5 元组，以及用于验证请求的用户名和密码，以确保在后续消息中重用它们。客户端还需要跟踪在服务器上建立的通道和权限。")]),v._v(" "),e("p",[v._v("客户端可能希望将中继传输地址发送给对等方（使用此处未指定的某种方法），以便对等方可以与其通信。客户端还可以希望在其 "),e("code",[v._v("ICE")]),v._v(" 处理中使用在 "),e("code",[v._v("XOR-MAPPED-ADDRESS")]),v._v(" 属性中接收到的服务器反射地址。")]),v._v(" "),e("h3",{attrs:{id:"接收到分配错误响应"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接收到分配错误响应"}},[v._v("#")]),v._v(" 接收到分配错误响应")]),v._v(" "),e("p",[v._v("如果客户端收到分配错误响应，则处理取决于返回的实际错误代码：")]),v._v(" "),e("ul",[e("li",[v._v("（请求超时）：服务器存在问题，或使用选择的传输无法到达服务器。客户端认为当前事务已失败，但可以选择使用其他传输（例如，使用 "),e("code",[v._v("TCP")]),v._v(" 替代 "),e("code",[v._v("UDP")]),v._v("）重试分配请求。")]),v._v(" "),e("li",[v._v("300（尝试备用）：服务器希望客户端使用 "),e("code",[v._v("ALTERNATE-SERVER")]),v._v(" 属性中指定的服务器。客户端认为当前事务已失败，但应该首先尝试使用备用服务器进行分配请求，然后再尝试使用其他服务器（例如，使用 "),e("code",[v._v("SRV")]),v._v(" 程序发现的其他服务器）。在使用备用服务器进行分配请求时，客户端遵循[RFC5389]中指定的 "),e("code",[v._v("ALTERNATE-SERVER")]),v._v(" 过程。")]),v._v(" "),e("li",[v._v("400（错误请求）：服务器认为客户端的请求有误。客户端认为当前事务已失败。客户端可以通知用户或操作员，并且在认为问题已经解决之前不应该再次尝试使用此服务器发送请求。")]),v._v(" "),e("li",[v._v("401（未经授权）：如果客户端遵循了长期凭证机制的程序，仍然收到此错误，则服务器不接受客户端的凭证。在这种情况下，客户端认为当前事务已失败，并应该通知用户或操作员。客户端不应该向此服务器发送任何进一步的请求，直到它认为问题已经解决。")]),v._v(" "),e("li",[v._v("403（禁止）：请求有效，但服务器拒绝执行它，可能是由于管理员限制。客户端认为当前事务已失败。客户端可以通知用户或操作员，在认为问题已经解决之前不应该再次尝试使用此服务器发送相同的请求。")]),v._v(" "),e("li",[v._v("420（未知属性）：如果客户端在请求中包含 "),e("code",[v._v("DONT-FRAGMENT")]),v._v(" 属性，并且服务器用 420 错误代码拒绝请求，并在错误响应中列出了 "),e("code",[v._v("UNKNOWN-ATTRIBUTES")]),v._v(" 属性中的 "),e("code",[v._v("DONT-FRAGMENT")]),v._v(" 属性，则客户端现在知道服务器不支持 "),e("code",[v._v("DONT-FRAGMENT")]),v._v(" 属性。客户端认为当前事务已失败，但可以选择在不使用 "),e("code",[v._v("DONT-FRAGMENT")]),v._v(" 属性的情况下重试分配请求。")]),v._v(" "),e("li",[v._v("437（分配不匹配）：这表示客户端选择了服务器视为已在使用中的 5 元组。这种情况可能发生的一种方式是，介入的 "),e("code",[v._v("NAT")]),v._v(" 分配了一个映射的传输地址，并被另一个最近崩溃的客户端使用。客户端认为当前事务已失败。客户端应该选择另一个客户端传输地址，并重新尝试使用分配请求（使用不同的事务 "),e("code",[v._v("ID")]),v._v("）。客户端应该尝试三个不同的客户端传输地址，然后放弃此服务器。一旦客户端放弃服务器，客户端应该在 2 分钟内不再尝试在服务器上创建另一个分配。")]),v._v(" "),e("li",[v._v("438（陈旧的随机数）：参见长期凭证机制的过程[RFC5389]。")]),v._v(" "),e("li",[v._v("441（错误凭证）：客户端不应在响应 "),e("code",[v._v("Allocate")]),v._v(" 请求时收到此错误。客户端可以通知用户或操作员，并在认为问题已经解决之前不应再次尝试使用此服务器发送相同的请求。")]),v._v(" "),e("li",[v._v("442（不支持的传输地址）：客户端不应在 "),e("code",[v._v("UDP")]),v._v(" 分配请求的响应中收到此错误。客户端可以通知用户或操作员，在认为问题已解决之前不应再次尝试使用此服务器。")]),v._v(" "),e("li",[v._v("486（分配配额已达到）：服务器当前无法使用此用户名创建更多分配。客户端认为当前事务已失败。客户端应该等待至少 1 分钟，然后再尝试在服务器上创建更多分配。")]),v._v(" "),e("li",[v._v("508（容量不足）：服务器没有更多中继传输地址可用，或没有具有请求属性的地址，或保留的地址不再可用。客户端认为当前操作已失败。如果客户端使用 "),e("code",[v._v("EVEN-PORT")]),v._v(" 或 "),e("code",[v._v("RESERVATION-TOKEN")]),v._v(" 属性之一，则客户端可以选择删除或修改该属性，并立即重试。否则，客户端应该等待至少 1 分钟，然后再尝试在此服务器上创建更多分配。")])]),v._v(" "),e("p",[v._v("未知的错误响应必须按[RFC5389]中的描述进行处理。")]),v._v(" "),e("h2",{attrs:{id:"刷新分配"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#刷新分配"}},[v._v("#")]),v._v(" 刷新分配")]),v._v(" "),e("p",[v._v("刷新事务可以用于刷新现有分配并更新其到期时间，或者删除现有分配。")]),v._v(" "),e("p",[v._v("如果客户端希望继续使用分配，则在到期前必须刷新它。**建议客户端在到期前大约 1 分钟刷新分配。**如果客户端不再希望使用分配，则应明确删除分配。客户端可以随时出于其他原因刷新分配。")]),v._v(" "),e("h3",{attrs:{id:"发送刷新请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#发送刷新请求"}},[v._v("#")]),v._v(" 发送刷新请求")]),v._v(" "),e("p",[v._v("如果客户端希望立即删除现有分配，则将 "),e("code",[v._v("LIFETIME")]),v._v(" 属性和值为 0 包含在请求中。其他所有形式的请求都会刷新分配。")]),v._v(" "),e("p",[v._v("刷新事务更新分配的到期时间计时器。如果客户端希望服务器将到期时间计时器设置为非默认寿命的值，则包括请求值为 "),e("code",[v._v("LIFETIME")]),v._v(" 的属性。然后服务器计算新的到期时间值，方法与分配事务相同，但请求寿命为 0 会立即删除分配。")]),v._v(" "),e("h3",{attrs:{id:"接收刷新请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接收刷新请求"}},[v._v("#")]),v._v(" 接收刷新请求")]),v._v(" "),e("p",[v._v("当服务器接收到刷新请求时，它会按照第 4 节和本节中提到的特定规则进行处理。")]),v._v(" "),e("p",[v._v("服务器计算一个称为“期望寿命”的值，如下所示：如果请求包含 "),e("code",[v._v("LIFETIME")]),v._v(" 属性且属性值为 0，则“期望寿命”为 0。否则，如果请求包含 "),e("code",[v._v("LIFETIME")]),v._v(" 属性，则服务器计算客户端请求寿命和服务器允许的最大寿命的最小值。如果此计算值大于默认寿命，则“期望寿命”为计算值，否则“期望寿命”为默认寿命。")]),v._v(" "),e("p",[v._v("随后的处理取决于“期望寿命”值：")]),v._v(" "),e("ul",[e("li",[v._v("如果“期望寿命”为 0，则请求成功，分配将被删除。")]),v._v(" "),e("li",[v._v("如果“期望寿命”为非零值，则请求成功，并将分配的到期时间设置为“期望寿命”。")])]),v._v(" "),e("p",[v._v("如果请求成功，则服务器发送包含以下内容的成功响应：")]),v._v(" "),e("ul",[e("li",[v._v("包含当前时间到期计时器值的 "),e("code",[v._v("LIFETIME")]),v._v(" 属性。")])]),v._v(" "),e("p",[v._v("注意：服务器不需要做任何特殊处理来使用“无状态堆栈方法”通过 "),e("code",[v._v("UDP")]),v._v(" 实现 "),e("code",[v._v("Refresh")]),v._v(" 请求的幂等性。带有非零“期望寿命”的重传 "),e("code",[v._v("Refresh")]),v._v(" 请求将简单地刷新分配。使用零“期望寿命”的重传 "),e("code",[v._v("Refresh")]),v._v(" 请求将导致 437（分配不匹配）响应，如果分配已被删除，则客户端将将其视为成功响应（见下文）。")]),v._v(" "),e("h3",{attrs:{id:"接收刷新响应"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接收刷新响应"}},[v._v("#")]),v._v(" 接收刷新响应")]),v._v(" "),e("p",[v._v("如果客户端收到对其刷新请求的成功响应，并带有非零寿命，则它将使用响应中包含的到期时间值更新其分配数据结构的副本。")]),v._v(" "),e("p",[v._v("如果客户端收到 437（分配不匹配）错误响应以删除分配，则分配不再存在，客户端应将其请求视为已成功。")])])}),[],!1,null,null,null);_.default=c.exports}}]);